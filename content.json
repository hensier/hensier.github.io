{"posts":[{"title":"Blog Navigator","text":"信息竞赛随笔札记OI 2021：退役总结 题解区更多题解可前往洛谷博客处查看。 P6851 题解P7806 题解P7913 题解P7960 题解 远古拙作大赏P6474 题解P1928 题解 化学笔记1 原子的构造原理1.1 原子轨道1.2 能级交错练习与任务题解 2 元素周期律2.1 元素周期表2.2 元素周期律 Project Euler目前已完成 $1 \\sim 52$ 题，整理在此处。其中 $1 \\sim 50$ 题的相关文章不再显示在博客主页上。 数学精选题目整理 2022 新高考 I 卷 合集 【泰勒展开】第 7 题 【立体几何+导数】第 8 题 【三角函数】第 18 题 【立体几何】第 19 题","link":"/navigator/"},{"title":"Attention Is All You Need?","text":"C 数列之和 数列 $a$ 由 $10^{100}$ 项组成，从第一项开始有 $a_i = 2i - 2$。 将数列 $a$ 中所有长度大于 $1$ 的连续子数列的元素和去重后从小到大构成一个新的数列，求这个数列的第 $k$ 项。 注意到，答案为 $2(k + \\lfloor \\log_2{(k + \\lfloor \\log_2 k \\rfloor)} \\rfloor)$，时间复杂度 $\\mathcal O(T)$。 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int T;long long k;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; T; while (T--) { cin &gt;&gt; k; cout &lt;&lt; 2 * (k + __lg(k + __lg(k))) &lt;&lt; '\\n'; } return 0;} 证明不妨设 $b_i = i - 1$（$i \\le 10^{100}$），即数列 ${0, 1, 2, \\cdots, 10^{100} - 1}$，最后再乘 $2$ 即可。 由于 $10^{100} \\gg \\max {k} = 10^{18}$，因此完全可以视为是无穷数列。 接着考虑什么样的数能够由数列 $b$ 中长度大于 $1$ 的连续子数列的元素和表示出来。 注意到，满足这样条件的正整数 $n$ 是比较特殊的，即存在一个正奇数 $p$ 和一个正整数 $q$，使得 $n = pq$。经过讨论，我们发现这类数总能被表示出来： 当 $q \\ge \\frac{p-1}{2}$ 时，构造以 $q$ 为中间元素、长度为 $p$ 的连续子数列，即包含 $q - \\frac{p-1}{2} \\sim q + \\frac{p-1}{2}$ 内的所有整数。 当 $q \\le \\frac{p+1}{2}$ 时，构造以 $\\frac{p-1}{2}$、$\\frac{p+1}{2}$ 为中间元素、长度为 $2q$ 的连续子数列，即包含 $\\frac{p+1}{2} - q \\sim \\frac{p-1}{2} + q$ 内的所有整数。 当 $q \\in {\\frac{p-1}{2}, \\frac{p+1}{2}}$ 时，这两种构造方式均有效，如 $n = 3, p = 3, q = 1$ 时，有 ${0, 1, 2}$ 和 ${1, 2}$ 两种构造方式。 进一步地，不难发现上述讨论实际上已经囊括了所有长度大于 $1$ 的连续子数列： 当子数列长度 $l$ 为奇数时，令 $p = l$，首项取遍 $\\mathbf N$，则中间元素取遍大于等于 $\\frac{p-1}{2}$ 的所有整数。令 $q$ 为中间元素，则 $q$ 取遍大于等于 $\\frac{p-1}{2}$ 的所有整数，此时恰与前述的情形 1 对应。 当子数列长度 $l$ 为偶数时，令 $2q = l$，首项取遍 $\\mathbf N$，则两个中间元素分别取遍大于等于 $q-1$ 和大于等于 $q$ 的所有整数。令 $\\frac{p-1}{2}$、$\\frac{p+1}{2}$ 为中间元素，则 $q$ 取遍小于等于 $\\frac{p+1}{2}$ 的所有整数，此时恰与前述的情形 2 对应。 因此，对于一个整数 $n$，当且仅当存在一个正奇数 $p$ 和一个正整数 $q$ 使得 $n = pq$ 时，$n$ 能够被数列 $b$ 中长度大于 $1$ 的连续子数列的元素和表示出来。 显然，这个条件又等价于 $n \\neq 2^k$（$k$ 为正整数），因为只有 $2$ 的正整数次幂没有奇因子。也就是说，答案数列为 ${0, 1, 3, 5, 6, 7, 9, \\cdots }$（A138591）。 最后乘 $2$ 即为本题答案。 J 铁刀磨成针 一把刀的初始攻击力为 $x$。现进行 $n$ 个回合，每回合依次包含下面两个阶段： 磨刀阶段：若磨刀石有剩余，可选择消耗 $1$ 个磨刀石使刀的攻击力提升 $1$。 攻击阶段：若刀的攻击力大于 $0$，可选择进行一次攻击，造成的伤害等于攻击力，随后刀的攻击力减 $1$。当刀的攻击力为 $0$ 时，刀损坏，此后不能再攻击。 注意到，答案为 $$ans(n, x, y) =\\begin{cases}n’(x + 1) &amp; n’ \\le \\min(x + 2, y) \\cr\\lfloor \\frac{(n’+x+1)^2}{4} \\rfloor - \\frac{(n’-y)(n’-y+1)}{2} &amp; n’ \\ge \\max(x + 2, y) \\cr\\lfloor \\frac{(n’+x+1)^2}{4} \\rfloor &amp; x + 2 \\lt n’ \\lt y \\crn’(x+1) - \\frac{(n’-y)(n’-y+1)}{2} &amp; y \\lt n’ \\lt x + 2\\end{cases}$$ （其中 $n’ = \\min(n, x + 2y - 1)$） 时间复杂度 $\\mathcal O(T)$。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int T, n, x, y;int solve(int n, int x, int y) { if (n &lt;= min(x + 2, y)) return n * (x + 1); if (n &gt;= max(x + 2, y)) return (n + x + 1) * (n + x + 1) / 4 - (n - y) * (n - y + 1) / 2; if (n &gt; x + 2 &amp;&amp; n &lt; y) return (n + x + 1) * (n + x + 1) / 4; if (n &gt; y &amp;&amp; n &lt; x + 2) return n * (x + 1) - (n - y) * (n - y + 1) / 2; assert(false);}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; T; while (T--) { cin &gt;&gt; n &gt;&gt; x &gt;&gt; y; n = min(n, x + 2 * y - 1); cout &lt;&lt; solve(n, x, y) &lt;&lt; '\\n'; } return 0;} 考场做法（如何注意到？）相比于 C 题，这道题有三个参数，需要的注意力比较高。因此只能退而求其次，先打个暴力。 设 $dp_{i,j}$ 表示在第 $i$ 轮的攻击力为 $j$ 的情况下，前 $i$ 轮造成的总伤害。不难发现，先用磨刀石总优于后用磨刀石，因此可得转移方程： 初始状态：$dp_{0,x} = 0$ 磨刀且攻击，伤害仍为 $j$（要求有磨刀石剩余，即 $i \\lt y$）： $$dp_{i+1,j} = \\max(dp_{i+1,j}, dp_{i,j} + j + 1)$$ 磨刀且不攻击，伤害变为 $j + 1$（要求有磨刀石剩余，即 $i \\lt y$）： $$dp_{i+1,j+1} = \\max(dp_{i+1,j+1}, dp_{i,j})$$ 不磨刀且攻击，伤害变为 $j - 1$（要求刀不损坏，即 $j \\gt 0$）： $$dp_{i+1,j-1} = \\max(dp_{i+1,j-1}, dp_{i,j} + j)$$ 不磨刀且不攻击，伤害仍为 $j$（对 $i, j$ 无限制）： $$dp_{i+1,j} = \\max(dp_{i+1,j}, dp_{i,j})$$ 注意到，只有前 $x + 2y - 1$ 轮才是有意义的。有石必磨刀总是更优，有效轮数最多的情况是先耗完所有磨刀石（$y$ 轮）再攻击（$x + y$ 轮），但最后一次磨刀和第一次攻击可以合并，需减 $1$。因此，我们可以直接上来就让 $n$ 变成 $\\min(n, x + 2y - 1)$。 1234567891011121314151617181920long long solve(int n, int x, int y) { memset(dp, 0x80, sizeof(dp)); n = min(n, x + 2 * y - 1); dp[0][x] = 0; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt;= x + y; j++) { if (i &lt; y) { dp[i+1][j] = max(dp[i+1][j], dp[i][j] + j + 1); dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j]); } else { if (j &gt; 0) dp[i+1][j-1] = max(dp[i+1][j-1], dp[i][j] + j); dp[i+1][j] = max(dp[i+1][j], dp[i][j]); } } } long long ans = 0; for (int i = 0; i &lt;= x + y; i++) ans = max(ans, dp[n][i]); return ans;} 不妨在 $1 \\sim 10$ 的范围内暴力枚举 $x, y$，对每个 $(x, y)$ 再从 $1 \\sim x + 2y - 1$ 暴力枚举 $n$： 12345678910int main() { for (int x = 1; x &lt;= 10; x++) { for (int y = 1; y &lt;= 10; y++) { printf(&quot;x=%d, y=%d\\n&quot;, x, y); for (int n = 1; n &lt;= x + 2 * y - 1; n++) printf(&quot;n=%2d:%3lld\\n&quot;, n, solve(n, x, y)); putchar('\\n'); } } return 0;} 注意到，当 $x, y$ 确定时，随着 $n$ 的增大，答案分批地呈现出一定的规律。下面以两组为例： 首先，最明显的是 $n$ 比较小的情形，这个时候答案总是 $n(x+1)$。结合多组数据可以注意到，这里 $n$ 的范围是 $n \\le \\min(x + 2, y)$。 当 $n$ 继续增大时，考虑相邻两项的差。 例如，对于 $x=3, y=9$，从 $n = 6$ 开始，每一项与前一项的差分别为 $(4, 4, \\cdots , 4), 5, 5, 6, \\color \\red 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1$。 对于 $x=10, y=4$，从 $n = 5$ 开始，每一项与前一项的差分别为 $(11, 11, \\cdots , 11), 10, 9, 8, 7, 6, 5, 4, \\color \\red 3, 3, 2, 2, 1, 1$。 对于 $x=4, y=3$，从 $n = 4$ 开始，每一项与前一项的差分别为 $(5, 5, \\cdots , 5), 4, 3, \\color \\red 2, 2, 1, 1$。 对于 $x=5, y=6$，从 $n = 7$ 开始，每一项与前一项的差分别为 $(6, 6, \\cdots , 6), \\color \\red 5, 5, 4, 4, 3, 3, 2, 2, 1, 1$。 不难发现，标红位置处是一个分界点，而此时 $n$ 恰好是 $\\max{x + 2, y}$。 注意到，这种邻项差构成等差数列的数列可以由 $a_n = \\frac{n(n+1)}{2}$ （$a_n - a_{n-1} = n$）转化获得；而这种邻项差构成每两项成等差数列的数列（如 ${5, 5, 6, 6, 7, 7, \\cdots}$）可以由 $b_n = \\lfloor \\frac{n^2}{4} \\rfloor$ （$b_{2k} - b_{2k-1} = \\lfloor \\frac{(2k)^2}{4} \\rfloor - \\lfloor \\frac{(2k-1)^2}{4} \\rfloor = k^2 - \\lfloor (k - \\frac{1}{2})^2 \\rfloor = k^2 - \\lfloor k^2 - k + \\frac{1}{4} \\rfloor = k$，$b_{2k+1} - b_{2k} = \\lfloor \\frac{(2k+1)^2}{4} \\rfloor - \\lfloor \\frac{(2k)^2}{4} \\rfloor = \\lfloor k^2 + k + \\frac{1}{4} \\rfloor - k^2 = k$，即 $b_n - b_{n-1} = \\lfloor \\frac{n}{2} \\rfloor$）转化获得（A002620）。同时，不难发现有 $b_n + b_{n+1} = a_n$。 归纳可知（简记 $ans_n$ 为答案）： 当 $x + 2 \\le y$ 时： i. 对于 $n \\in [x + 3, y - 1]$，$ans_n - ans_{n-1} = x + 2 + \\lfloor \\frac{n-x-3}{2} \\rfloor$。 则 $$ \\begin{aligned} ans_n &amp;= ans_{x+2} + \\sum_{i=x+3}^n (x + 2 + \\lfloor \\frac{i-x-3}{2} \\rfloor) \\cr &amp;= (x+2)(x+1) + (x+2)(n-x-2) + \\sum_{i=0}^{n-x-3} \\lfloor \\frac{i}{2} \\rfloor \\cr &amp;= (x+2)(n-1) + \\lfloor \\frac{(n-x-3)^2}{4} \\rfloor \\cr &amp;= \\frac{(n+x+1)^2 - (n-x-3)^2}{4} + \\lfloor \\frac{(n-x-3)^2}{4} \\rfloor \\cr &amp;= \\lfloor \\frac{(n+x+1)^2}{4} \\rfloor \\end{aligned} $$ （特别地，当 $y \\in {x + 2, x + 3}$ 时，$x + 3 \\gt y - 1$，此情形无效，已包含在 $x \\le \\min(x + 2, y)$ 的情形内） ii. 对于 $n \\in [y, x + 2y - 1]$，$ans_n - ans_{n-1} = \\lfloor \\frac{x + 2y - n + 1}{2} \\rfloor$。 则 $$ \\begin{aligned} ans_n &amp;= ans_{y-1} + \\sum_{i=y}^n \\lfloor \\frac{x + 2y - i + 1}{2} \\rfloor \\cr &amp;= \\lfloor \\frac{(x+y)^2}{4} \\rfloor + \\sum_{i=x+2y-n+1}^{x+y+1} \\lfloor \\frac{i}{2} \\rfloor \\cr &amp;= \\lfloor \\frac{(x+y)^2}{4} \\rfloor + \\lfloor \\frac{(x+y+1)^2}{4} \\rfloor - \\lfloor \\frac{(x+2y-n)^2}{4} \\rfloor \\cr &amp;= b_{x+y} + b_{x+y+1} - \\lfloor \\frac{(x+2y-n)^2}{4} \\rfloor \\cr &amp;= a_{x+y} - \\lfloor \\frac{(x+2y-n)^2}{4} \\rfloor \\cr &amp;= \\frac{(x+y)(x+y+1)}{2} - \\lfloor \\frac{(x+2y-n)^2}{4} \\rfloor \\cr &amp;= \\frac{(x+y)(x+y+1)}{2} - \\lfloor (\\frac{x-n}{2}+y)^2 \\rfloor \\cr &amp;= \\frac{(x+y)(x+y+1)}{2} - \\lfloor (\\frac{x-n}{2})^2 \\rfloor + y(n-x) - y^2 \\cr &amp;= \\frac{(x+y)(x+y+1)}{2} - \\lfloor (\\frac{x-n}{2})^2 \\rfloor + y(n-x) - y^2 \\cr &amp;= \\frac{y(y+2x+1)+2y(n-x)-2y^2}{2} + \\frac{x(x+1)}{2} - \\lfloor (\\frac{x-n}{2})^2 \\rfloor \\cr &amp;= \\frac{y(y+1)+2ny-2y^2}{2} + \\frac{x(x+1)}{2} - \\lfloor (\\frac{x-n}{2})^2 \\rfloor \\cr &amp;= \\frac{(2n+1)y-y^2}{2} + \\frac{x(x+1)}{2} - \\lfloor (\\frac{x-n}{2})^2 \\rfloor \\cr &amp;= -\\frac{n^2-2ny+y^2+n-y}{2} + \\frac{x(x+1)+n^2+n}{2} - \\lfloor (\\frac{x-n}{2})^2 \\rfloor \\cr &amp;= \\frac{x(x+1)+n^2+n}{2} - \\lfloor (\\frac{x-n}{2})^2 \\rfloor - \\frac{(n-y)(n-y+1)}{2} \\cr &amp;= \\frac{x^2}{4} - \\frac{nx}{2} + \\frac{n^2}{4} + \\frac{x^2+2x+n^2+2nx+2n}{4} - \\lfloor (\\frac{x-n}{2})^2 \\rfloor - \\frac{(n-y)(n-y+1)}{2} \\cr &amp;= (\\frac{x-n}{2})^2 + \\frac{(n+x)^2+2(n+x)}{4} - \\lfloor (\\frac{x-n}{2})^2 \\rfloor - \\frac{(n-y)(n-y+1)}{2} \\end{aligned} $$ 若 $n, x$ 同奇偶，则 $$ \\begin{aligned} ans_n &amp;= \\frac{(n+x)^2+2(n+x)}{4} - \\frac{(n-y)(n-y+1)}{2} \\cr &amp;= \\lfloor \\frac{(n+x)^2+2(n+x)+1}{4} \\rfloor - \\frac{(n-y)(n-y+1)}{2} \\cr &amp;= \\lfloor \\frac{(n+x+1)^2}{4} \\rfloor - \\frac{(n-y)(n-y+1)}{2} \\end{aligned} $$ 若 $n, x$ 不同奇偶，则 $$ \\begin{aligned} ans_n &amp;= (\\frac{x-n}{2})^2 + \\frac{(n+x)^2+2(n+x)}{4} - \\lfloor (\\frac{x-n}{2})^2 \\rfloor - \\frac{(n-y)(n-y+1)}{2} \\cr &amp;= (\\frac{x-n}{2})^2 + \\frac{(n+x)^2+2(n+x)}{4} - \\lfloor (\\frac{x-n-1}{2})^2 + \\frac{x-n-1}{2} + \\frac{1}{4} \\rfloor - \\frac{(n-y)(n-y+1)}{2} \\cr &amp;= (\\frac{x-n}{2})^2 + \\frac{(n+x)^2+2(n+x)}{4} - (\\frac{x-n-1}{2})^2 - \\frac{x-n-1}{2} - \\frac{(n-y)(n-y+1)}{2} \\cr &amp;= \\frac{1}{2}(x-n-\\frac{1}{2}) + \\frac{(n+x)^2+2(n+x)}{4} - \\frac{x-n-1}{2} - \\frac{(n-y)(n-y+1)}{2} \\cr &amp;= \\frac{1}{4} + \\frac{(n+x)^2+2(n+x)}{4} - \\frac{(n-y)(n-y+1)}{2} \\cr &amp;= \\frac{(n+x+1)^2}{4} - \\frac{(n-y)(n-y+1)}{2} \\cr &amp;= \\lfloor \\frac{(n+x+1)^2}{4} \\rfloor - \\frac{(n-y)(n-y+1)}{2} \\end{aligned} $$ 因此，无论 $n, x$ 的奇偶性是否相同，均有 $$ans_n = \\lfloor \\frac{(n+x+1)^2}{4} \\rfloor - \\frac{(n-y)(n-y+1)}{2}$$ 当 $x + 2 \\gt y$ 时： i. 对于 $n \\in [y + 1, x + 1]$，$ans_n - ans_{n-1} = x + y - n + 1$。 则 $$ \\begin{aligned} ans_n &amp;= ans_y + \\sum_{i=y+1}^n (x + y - i + 1) \\cr &amp;= y(x+1) + \\sum_{i=x+y-n+1}^x i \\cr &amp;= y(x+1) + \\frac{(2x+y-n+1)(n-y)}{2} \\cr &amp;= y(x+1) + x(n-y) - \\frac{(y-n)(y-n+1)}{2} \\cr &amp;= nx+y - \\frac{(y-n)(y-n+1)}{2} \\cr &amp;= n(x+1) - \\frac{(n-y)(n-y+1)}{2} \\cr \\end{aligned} $$ ii. 对于 $n \\in [x + 2, x + 2y - 1]$，$ans_n - ans_{n-1} = \\lfloor \\frac{x + 2y - n + 1}{2} \\rfloor$。 则 $$ \\begin{aligned} ans_n &amp;= ans_{x+1} + \\sum_{i=x+2}^n \\lfloor \\frac{x + 2y - i + 1}{2} \\rfloor \\cr &amp;= (x+1)x+y - \\frac{(y-x-1)(y-x)}{2} + \\sum_{i=x+2y-n+1}^{2y-1} \\lfloor \\frac{i}{2} \\rfloor \\cr &amp;= (x+1)x+y - \\frac{(y-x-1)(y-x)}{2} + \\lfloor \\frac{(2y-1)^2}{4} \\rfloor - \\lfloor \\frac{(x+2y-n)^2}{4} \\rfloor \\cr &amp;= (x+1)x+y - \\frac{(y-x-1)(y-x)}{2} + y^2 - y - \\lfloor \\frac{(x+2y-n)^2}{4} \\rfloor \\cr &amp;= (x+1)x + y^2 - \\frac{(y-x-1)(y-x)}{2} - \\lfloor \\frac{(x+2y-n)^2}{4} \\rfloor \\cr &amp;= \\frac{2(x+1)x + 2y^2 - (y-x-1)(y-x)}{2} - \\lfloor \\frac{(x+2y-n)^2}{4} \\rfloor \\cr &amp;= \\frac{2(x+1)x + 2y^2 - y(y-x) - (x+1)x + (x+1)y}{2} - \\lfloor \\frac{(x+2y-n)^2}{4} \\rfloor \\cr &amp;= \\frac{2(x+1)x + y^2 + xy - (x+1)x + (x+1)y}{2} - \\lfloor \\frac{(x+2y-n)^2}{4} \\rfloor \\cr &amp;= \\frac{(x+1)x + y(x+y) + (x+1)y}{2} - \\lfloor \\frac{(x+2y-n)^2}{4} \\rfloor \\cr &amp;= \\frac{(x+y)(x+y+1)}{2} - \\lfloor \\frac{(x+2y-n)^2}{4} \\rfloor \\cr &amp;= \\cdots \\cr &amp;= \\lfloor \\frac{(n+x+1)^2}{4} \\rfloor - \\frac{(n-y)(n-y+1)}{2} \\end{aligned} $$ 综上，对 $\\forall x, y \\ge 1, 1 \\le n \\le x + 2y - 1$，有 $$ans(n, x, y) =\\begin{cases}n(x + 1) &amp; n \\le \\min(x + 2, y) \\cr\\lfloor \\frac{(n+x+1)^2}{4} \\rfloor - \\frac{(n-y)(n-y+1)}{2} &amp; n \\ge \\max(x + 2, y) \\cr\\lfloor \\frac{(n+x+1)^2}{4} \\rfloor &amp; x + 2 \\lt n \\lt y \\crn(x+1) - \\frac{(n-y)(n-y+1)}{2} &amp; y \\lt n \\lt x + 2\\end{cases}$$ 证明接下来由果溯因。在暴力时已指出，先用磨刀石总优于后用磨刀石（性质 1）。 另外，注意到连续攻击总优于有间断地攻击（性质 2）： 假设在第 $i, j$ 回合之间攻击，而在第 $i + 1 \\sim j - 1$ 回合内都没有攻击，那么不如考虑只在第 $j - 1$ 和 $j$ 回合攻击，因为这两种方案的攻击次数相同（消耗刀的攻击力相同）且回合数相同，但第 $j - 1$ 回合造成的伤害一定不小于第 $i$ 回合造成的伤害（考虑第 $i + 1 \\sim j - 1$ 回合可能会磨刀）。 当 $n \\le y$ 时： 由性质 1，每一回合都会磨刀。另外，中途停止攻击是不优的，因为每回合都会磨刀，不存在刀的攻击力将为 $0$ 的情况。再结合性质 2，最优的方案一定是从某个回合开始攻击一直到结束。 假设从第 $k$ 回合开始攻击（中途停止攻击是不优的，因为每回合都能磨刀），那么攻击时造成的伤害恒为 $x + k$。则总伤害为 $$D(k) = (x + k)(n - k + 1) = -k^2 + (n-x+1)k + x(n+1)$$ 对称轴为 $k = \\frac{n-x+1}{2}$。 令 $f(n) = D_{\\max}$，则： i. 当 $\\frac{n-x+1}{2} \\le 1.5$ （即 $n \\le x + 2$）时，$f(n) = D(1) = -1+n-x+1+x(n+1) = n(x+1)$。 ii. 当 $\\frac{n-x+1}{2} \\gt 1.5$ （即 $n \\gt x + 2$）时 $$\\begin{aligned}f(n) &amp;= D(\\lfloor \\frac{n-x+1}{2} \\rfloor) \\cr&amp;= -(\\lfloor \\frac{n-x+1}{2} \\rfloor)^2 + (n-x+1) \\lfloor \\frac{n-x+1}{2} \\rfloor + x(n+1) \\cr&amp;= \\lfloor \\frac{n-x+1}{2} \\rfloor(n-x+1 - \\lfloor \\frac{n-x+1}{2} \\rfloor) + x(n+1) \\cr&amp;= \\lfloor \\frac{n-x+1}{2} \\rfloor \\lceil \\frac{n-x+1}{2} \\rceil + x(n+1) \\cr&amp;= \\lfloor \\frac{(n-x+1)^2}{4} \\rfloor + x(n+1) \\cr&amp;= \\lfloor \\frac{(n-x+1)^2}{4} \\rfloor + \\frac{(n+x+1)^2}{4} - \\frac{(n-x+1)^2}{4} \\cr&amp;= \\lfloor \\frac{(n+x+1)^2}{4} \\rfloor\\end{aligned}$$ 当 $y \\lt n \\le x + 2y - 1$ 时： 我们在情形 1（$n \\le y$）中指出中途停止攻击是不优的。类似地，当 $n \\gt y$ 时，如果中途停止攻击，那只能是因为磨刀石和刀攻击力都消耗完了，否则就相当于是在浪费回合。所以最优策略依然是从某个回合 $k$ （$k \\le y$）开始攻击，只不过这里的瓶颈除了回合数不足，还有可能是刀的攻击力降为 $0$。 先考虑 $y’ = n$ 的情形。此时策略与情形 1 是相同的，造成的总伤害的极大值点为： $$k =\\begin{cases}1 &amp; n \\le x + 2 \\cr\\min(y, \\lfloor \\frac{n-x+1}{2} \\rfloor) = \\lfloor \\frac{\\min(n, x + 2y - 1) - x + 1}{2} \\rfloor = \\lfloor \\frac{n-x+1}{2} \\rfloor &amp; n \\gt x + 2\\end{cases}$$ 但我们把 $y$ 变成了 $n$，所以需要扣除多算的伤害。从第 $y + 1$ 回合开始，真正的攻击力从 $x + k - 1, x + k - 2, \\cdots$ 依次递减，而它们都被当作 $x + k - 1$ 来算，所以需依次扣除 $1, 2, 3, \\cdots$ 才能得到真正的总伤害。 设第 $i$ 个回合时，攻击力会降为 $0$。则 $x + k - (i - y) = 0$，即 $i = x + y + k$。考察 $i - n = x + y + k - n$ 的符号： i. 当 $n \\le x + 2$ 时： 若 $y = 1$，则 $i - n = x - n + 2 \\ge 0$。 若 $y \\gt 1$，则 $n \\le x + 2 \\le x + y$，$i - n = x + y + k - n \\ge n + k - n \\gt 0$。 ii. 当 $n \\gt x + 2$ 时： $$\\begin{aligned}i - n &amp;= x + y + \\lfloor \\frac{n-x+1}{2} \\rfloor - n \\cr&amp;= \\lfloor \\frac{n-x-2y+1}{2} \\rfloor - n + x + 2y \\cr&amp;\\ge \\lceil \\frac{n-x-2y+1}{2} \\rceil - (n - x - 2y + 1) \\cr&amp;= \\lceil \\frac{t}{2} \\rceil - t \\quad (t = n - x - 2y + 1 \\le 0) \\cr&amp;\\ge 0\\end{aligned}$$ 因此，攻击力在 $n$ 轮结束前是不会降为 $0$ 的。则造成的总伤害为 $$f(n) - \\sum_{i=1}^{n-y} i = f(n) - \\frac{(n-y)(n-y+1)}{2}$$ 综上， $$f(n) =\\begin{cases}n(x+1) &amp; n \\le x + 2 \\cr\\lfloor \\frac{(n+x+1)^2}{4} \\rfloor &amp; n \\gt x + 2\\end{cases}$$ $$ans(n, x, y) =\\begin{cases}f(n) &amp; n \\le y \\crf(n) - \\frac{(n-y)(n-y+1)}{2} &amp; y \\lt n \\le x + 2y - 1\\end{cases}$$","link":"/AIAYN/"},{"title":"P11362 [NOIP2024] 遗失的赋值 题解","text":"首先，需要特判 $c_i = c_j$ 但 $d_i \\neq d_j$ 的情形，此时答案为 $0$。 否则，我们可以把每相邻的两条一元限制作为一个区间单独拎出来。这样做正确的原因是，每一个 $x_i$ 的取值只受前面一个数的影响。事实上，完全可以任意选取区间，只不过这样选可以利用已知的 $x_i$，依次讨论出 $a_{i+1}, b_{i+1}, a_{i+2}, b_{i+2}, \\cdots$ 的可能取值，便于计算答案。 我们随便找几个数举个例子： 此时分别考虑区间 $[2,6]$，$[6,7]$ 和 $[7,9]$ 即可。 对于相邻的两条一元限制 $(c_i, d_i)$，$(c_j, d_j)$（$c_i \\lt c_j$）： 区间 $[c_i,c_j]$ 内有 $c_j - c_i$ 条待定的二元限制。 由于要求的是至少存在一种合法的 $x_i$ 的赋值方案数，我们不妨考虑其反面，先找出所有的方案，使得不存在合法的 $x_i$ 的赋值方式。 先考虑最特殊的一种情形，即从 $c_i$ 位置开始，首先有 $a_{c_i} = d_i$，而后有 $b_{k-1} = a_k$（$c_i \\lt k \\lt c_j$）。换言之，这种构造可以使得从 $c_{i} + 1$ 位置到 $c_{j} - 1$ 位置的 $x$ 值都确定下来。既然想要使方案不合法，我们只需进一步使 $b_{c_j-1} \\neq d_j$ 即可。 例如，对于 $[2,6]$ 这个区间，一种不合法的方案是： 令 $a_2 = 1$，$b_2 = 3$，则 $x_3$ 被确定为 $3$。 令 $a_3 = 3$，$b_3 = 2$，则 $x_4$ 被确定为 $2$。 令 $a_4 = 2$，$b_4 = 3$，则 $x_5$ 被确定为 $3$。 令 $a_5 = 3$，$b_5 = 2$，则 $x_6$ 被确定为 $2$。 但从初始情况可知 $x_6$ 已经为 $1$，因此这种方案不合法。 从 $c_i$ 位置到 $c_j-2$ 位置，$b_k$ 可以在 $1 \\sim v$ 内任取，而 $b_{c_j-1}$ 又有 $v-1$ 种取法（因为要保证不与 $d_j$ 相同）。则在这种情形下不合法的方案数为 $\\color{red}{v^{c_j-c_i-1}(v-1)}$。 例如，对于上面的例子，若 $v = 5$，那么首先 $a_2$ 必须为 $1$，而 $b_2$ 可以取 $1 \\sim 5$ 内的任意一个值。进一步地： $a_3 = b_2$，但 $b_3$ 可在 $1 \\sim 5$ 内任取。 $a_4 = b_3$，但 $b_4$ 可在 $1 \\sim 5$ 内任取。 $a_5 = b_4$，由于要保证 $b_5 \\neq d_6$，因此 $b_5$ 可以取 $2 \\sim 5$ 内的任意一个值。 因此不合法的方案数为 $5^3 \\times 4 = 500$。 否则，区间内存在一个位置 $k$ （$c_i \\lt k \\lt c_j$）使得 $b_{k-1} \\neq a_k$。那么我们只需要让 $x_k$ 取任意一个不等于 $a_k$ 的数，就能使 $x_{k+1}$ 的取值不受约束。依此类推，后面的数都可以任意选取，因此一定存在至少一种符合题意的 $x_i$ 的构造方案。即这种情形下的方案均合法。 例如，对于 $[7,9]$ 这个区间，我们可以让 $a_7 = 4$，$b_7 = 5$，但 $a_8 = 3 \\neq b_7$（即 $a_8 \\neq x_8$）。这时，无论 $b_8$ 取何值，$x_9$ 的值都将不受约束。 当不考虑一元限制时，每个 $a_k$，$b_k$ 都各能在 $1 \\sim v$ 内任取，因此总方案数为 $\\color{red}{v^{2(c_j-c_i)}}$。 因此，对相邻的两条一元限制 $(c_i, d_i)$，$(c_j, d_j)$（$c_i \\lt c_j$），用总方案数减去不合法的方案数，即为合法的方案数：$\\color{red}{v^{2(c_j-c_i)} - v^{c_j-c_i-1}(v-1)}$。 当然，还需处理边界，每个 $a_k$，$b_k$ 都各能在 $1 \\sim v$ 内任取，因为我们总可以对应地构造出符合的 $x_k$，理由同上。 例如，对于 $[1,2]$ 这个区间，若 $v = 5$，$a_1$ 和 $b_1$ 都各能在 $1 \\sim 5$ 内的任取，因为只需使 $x_1 \\neq a_1$ 即可。 在代码实现上，可以对原 $(c_i, d_i)$ 序列进行排序、去重（或者直接用 map，通过迭代器来遍历），然后用快速幂计算即可。 时间复杂度：$O(m(\\log m + \\log n)) \\approx O(m \\log n)$。 空间复杂度：$O(m)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;const int p = 1000000007;int T, n, m, v;struct node { int c, d; bool operator&lt;(const node &amp;x) const { if (c != x.c) return c &lt; x.c; return d &lt; x.d; } bool operator==(const node &amp;x) const { return c == x.c &amp;&amp; d == x.d; }} con[100001];long long qpow(long long a, long long b) { long long s = 1; while (b) { if (b % 2 == 1) s = s * a % p; a = a * a % p; b /= 2; } return s;}namespace IO { char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf, obuf[1 &lt;&lt; 21], *p3 = obuf; char gc() { if (p1 == p2) { p1 = buf; p2 = buf + fread(buf, 1, 1 &lt;&lt; 21, stdin); } return p1 == p2 ? EOF : *p1++; } template&lt;typename T&gt; void read(T &amp;x) { x = 0; char ch = gc(); while (!isdigit(ch)) ch = gc(); while (isdigit(ch)) { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = gc(); } } void pc(char c) { if (p3 - obuf &lt; (1 &lt;&lt; 21)) *p3++ = c; else { fwrite(obuf, p3 - obuf, 1, stdout); p3 = obuf; *p3++ = c; } } template&lt;typename T&gt; void write(T x) { if (x &gt; 9) write(x / 10); pc(x % 10 + 48); }} using namespace IO;int main() { #ifndef ONLINE_JUDGE freopen(&quot;assign.in&quot;, &quot;r&quot;, stdin); freopen(&quot;assign.out&quot;, &quot;w&quot;, stdout); #endif read(T); while (T--) { read(n), read(m), read(v); long long ans = 1; for (int i = 1; i &lt;= m; i++) read(con[i].c), read(con[i].d); sort(con + 1, con + m + 1); for (int i = 1; i &lt;= m; i++) { if (con[i].c == con[i-1].c &amp;&amp; con[i].d != con[i-1].d) { ans = 0; break; } } if (ans != 0) { m = unique(con + 1, con + m + 1) - con - 1; ans = ans * qpow(v, 2 * (con[1].c - 1)); for (int i = 2; i &lt;= m; i++) { int d = con[i].c - con[i-1].c; long long cur = (qpow(v, 2 * d) + p - (1LL * (v - 1) * qpow(v, d - 1) % p)) % p; ans = ans * cur % p; } ans = ans * qpow(v, 2 * (n - con[m].c)) % p; } write(ans); pc('\\n'); } fwrite(obuf, p3 - obuf, 1, stdout); return 0;}","link":"/OI/P11362/"},{"title":"荆轲刺秦王 题解","text":"本题的核心思想为 $\\color{red}{\\text{BFS}+差分}$。 $30$ 分算法先输入矩阵。对于士兵，进行一个 $\\mathcal O(nm)$ 的外层循环寻找士兵，再进行一个 $\\mathcal O(nm)$ 的内层循环，标记士兵范围。以下为内层循环的函数： 1234567void find(int x,int y,int z){ for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(abs(i-x)+abs(j-y)&lt;z) newmap[i][j]=&quot;#&quot;; // 标记为 # 就表示该处为士兵可观测范围，士兵本身用 / 标记} 维护一个队列并不断拓展，会有以下四种情况： 事实上，上述的优先级是从上到下的——不使用技能是最好的，其次是瞬移、隐身和同时使用： 在所用时间相同情况下，荆轲希望使用的两种技能总次数尽可能少；在所用时间与技能次数相同情况下，荆轲希望使用的隐身次数尽可能少。 按照这个顺序，我们一一进行拓展即可，最终只要到了秦王所在的格子就输出结果。该算法其实是存在很多问题的，因为最优结果不一定是最先找到的，所以这样会导致 WA。而 RE 可能是因为数组元素量不够大导致的。TLE 则可能是由于多种因素导致的，我们要逐个解决。 $95$ 分算法本算法需要改进的地方： 考虑最优情况，而不是最先遍历的情况 尽量减少程序运行的时间，进行有必要的剪枝 输入不提。我们可以考虑在士兵控制范围方面做一些改进，之前的内层循环是从 $1$ 到 $n$ ，从 $1$ 到 $m$ 的，但其实这都是不必要的。 假如一个士兵位于 $A(5,4)$ ，且数值为 $4$。则它的水平、竖直方向与其相差 $\\lt 4$ 格的均可被其看到，而根据曼哈顿距离的性质，一个士兵最终的可视范围就是一个正方形，而且这个正方形的对角线长为 $2(x-1)$（以下称 $x$ 为其数值，即范围），而边长为 $\\sqrt{2}(x-1)$。 这个可以观测到的点就是在这个正方形内部（包括边和士兵本身），如下图所示的棕色区域： 从特殊到一般对于任意一个位于 $city_{i,j}$（以下称输入的地图为 $city$）的士兵，它所形成的正方形的四个点分别为 $(\\max(1,i-x),j)$、$(i,\\max(1,j-x))$、$(\\min(n,i+x),j)$ 和 $(i,\\min(m,j+x))$。 因为地图上的坐标是正数，所以我们要进行特判，即用 $\\max,\\min$ 进行修正： 1234for(int x=max(1,i-d);x&lt;=min(n,i+d);++x) for(int y=max(1,j-d);y&lt;=min(m,j+d);++y) if(abs(x-i)+abs(y-j)&lt;d) flag[x][y]=true; 不妨定义一个 $ans$ 的 $node$ 类型作为答案，使得： 12ans=(node){0,0,0x7fffff,0x7fffff,0x7fffff};// x 和 y 坐标均为 0，步数、隐身和瞬移总使用次数均为 0x7fffff（即 int_max） 如果能到达就进行替换。最后只需判断 $ans.x$ 是否为 $0$ 即可知道是否能到达终点。 在搜索的过程中，我们可将将四种拓展情况进行改动，即： 不妨定义一个四维 $visit$ 数组，第一、二下标代表坐标，第三、四坐标分别表示隐身和瞬移的次数。如果重复就不到这个位置——这样能节省时间。 更新答案： 123456bool check(node a,node b){ if(a.step!=b.step)return a.step&lt;b.step; if(a.hide+a.move!=b.hide+b.move)return a.hide+a.move&lt;b.hide+b.move; return a.hide&lt;b.hide;} 把细节注意好了之后（注意：队列数组要开到一千万以上）就能取得 95 分的好成绩（一个点 TLE）。 $100$ 分算法现在唯一能优化的地方就是士兵观测范围了。这里要用到差分，我们用差分可以有效地解决曼哈顿距离的相关问题。当然下列数组的操作都在新维护的数组 $dif$ 中实现。 如上图，我们可以在红色正方形内进行操作。曼哈顿距离必定小于 $x$，所以我们不妨进行一个 $i∈[0,x)$ 循环，进行下列操作： 上方 $i$ 格，左方 $k-i-1$ 格的位置数值加 $1$ 上方 $i$ 格，右方 $k-i$ 格的位置数值减 $1$ 下方 $i$ 格，左方 $k-i-1$ 格的位置数值加 $1$ 下方 $i$ 格，右方 $k-i$ 格的位置数值减 $1$ 这样就能够快速地对周围的格子进行墨水扩散式的遍历，对于每一行，我们不停地求和，然后对于这一行中的每一个元素，如果当前的和大于 $0$，则该格处于观测范围以内： 动画演示： 不难发现，可观测到的点恰位于正方形内（包括边）。 实现： 12345678910void find(int x,int y,int k){ for(int i=0;i&lt;k;++i) { ++dif[max(1,x-i)][max(1,y-k+i+1)]; --dif[max(1,x-i)][min(m,y+k-i-1)+1]; ++dif[min(n,x+i)][max(1,y-k+i+1)]; --dif[min(n,x+i)][min(m,y+k-i-1)+1]; }} 当然这个差分数组还需使用： 123456789for(int i=1;i&lt;=n;++i) // 对每一行进行操作{ int sum=0; // 初始化和 for(int j=1;j&lt;=m;++j) { sum+=dif[i][j]; // 累加 if(sum&gt;0)flag[i][j]=true; // 此时和若大于 0 则标记为真 }} 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,c1,c2,d,ex,ey,city[351][351],dif[351][351],dx[]={-1,0,0,1,-1,-1,1,1},dy[]={0,-1,1,0,-1,1,-1,1};bool flag[351][351],visit[351][351][16][16];// (ex,ey) 为结束点，city 保存士兵的范围（没有士兵则为 0），dif 为差分维护数组// flag 为士兵观测数组，visit 为访问数组struct node{ int x,y,step,hide,move;}q[12500001],ans=(node){0,0,0x7fffffff,0x7fffffff,0x7fffffff};// q 为队列，ans 为最终答案void find(int x,int y,int k) // 差分{ for(int i=0;i&lt;k;++i) { ++dif[max(1,x-i)][max(1,y-k+i+1)]; --dif[max(1,x-i)][min(m,y+k-i-1)+1]; ++dif[min(n,x+i)][max(1,y-k+i+1)]; --dif[min(n,x+i)][min(m,y+k-i-1)+1]; }}void input() // 输入{ cin&gt;&gt;n&gt;&gt;m&gt;&gt;c1&gt;&gt;c2&gt;&gt;d; for(int i=1;i&lt;=n;++i) { for(int j=1;j&lt;=m;++j) { string s; cin&gt;&gt;s; switch(s[0]) { case 'S': // 直接加入队首 { q[1].x=i; q[1].y=j; break; } case 'T': // 标记终点 { ex=i; ey=j; break; } case '.':break; // 初始化为 0，所以是点的话不需操作 default: { for(int pos=0;s[pos];pos++)city[i][j]=(city[i][j]&lt;&lt;3)+(city[i][j]&lt;&lt;1)+(s[pos]^'0'); find(i,j,city[i][j]); // 士兵操作：1、标记，2、差分 } } } }}bool check(node a,node b) // check 函数，判断当前答案是否优于 ans{ if(a.step!=b.step)return a.step&lt;b.step; if(a.hide+a.move!=b.hide+b.move)return a.hide+a.move&lt;b.hide+b.move; return a.hide&lt;b.hide;}void bfs(){ int front=1,rear=1; while(front&lt;=rear) { node nf=q[front]; if(nf.step&gt;ans.step) // 此步很重要！有剪枝的效果，可节约大量时间 { front++; continue; } for(int i=0;i&lt;8;++i) { int nx=nf.x+dx[i],ny=nf.y+dy[i]; if(nx&lt;1||ny&lt;1||nx&gt;n||ny&gt;m||city[nx][ny])continue; // 判断出边界或已访问 if(flag[nx][ny]) // 隐身 { if(nf.hide&gt;=c1||visit[nx][ny][nf.hide+1][nf.move])continue; visit[nx][ny][nf.hide+1][nf.move]=true; q[++rear]=(node){nx,ny,nf.step+1,nf.hide+1,nf.move}; // 入队 if(nx==ex&amp;&amp;ny==ey&amp;&amp;check(q[rear],ans))ans=q[rear]; // 替换答案 } else // 不用技能 { if(visit[nx][ny][nf.hide][nf.move])continue; visit[nx][ny][nf.hide][nf.move]=true; q[++rear]=(node){nx,ny,nf.step+1,nf.hide,nf.move}; if(nx==ex&amp;&amp;ny==ey&amp;&amp;check(q[rear],ans))ans=q[rear]; } } for(int i=0;i&lt;4;++i) { int nx=nf.x+dx[i]*d,ny=nf.y+dy[i]*d; if(nx&lt;1||ny&lt;1||nx&gt;n||ny&gt;m||city[nx][ny])continue; if(flag[nx][ny]) // 瞬移 + 隐身 { if(nf.hide&gt;=c1||nf.move&gt;=c2||visit[nx][ny][nf.hide+1][nf.move+1])continue; visit[nx][ny][nf.hide+1][nf.move+1]=true; q[++rear]=(node){nx,ny,nf.step+1,nf.hide+1,nf.move+1}; if(nx==ex&amp;&amp;ny==ey&amp;&amp;check(q[rear],ans))ans=q[rear]; } else // 瞬移 { if(nf.move&gt;=c2||visit[nx][ny][nf.hide][nf.move+1])continue; visit[nx][ny][nf.hide][nf.move+1]=true; q[++rear]=(node){nx,ny,nf.step+1,nf.hide,nf.move+1}; if(nx==ex&amp;&amp;ny==ey&amp;&amp;check(q[rear],ans))ans=q[rear]; } } front++; // 队首下标加1 }}int main(){ input(); for(int i=1;i&lt;=n;++i) // 差分 { int sum=0; for(int j=1;j&lt;=m;++j) { sum+=dif[i][j]; if(sum&gt;0)flag[i][j]=true; } } bfs(); // 搜索 if(!ans.x)puts(&quot;-1&quot;); // 没有答案就输出 -1 else printf(&quot;%d %d %d\\n&quot;,ans.step,ans.hide,ans.move); // 输出步数、隐身次数和瞬移次数 return 0;}","link":"/OI/P6474/"},{"title":"OI 2021","text":"暑假集训$\\text{2021.7.31} \\sim \\text{2021.8.5}$ 这 $6$ 天内完成了 $55$ 道题目，其中最常见的错误有： 审题不仔细导致程序写挂 数组开小导致运行错误 数组开大导致空间超限 $\\text{DP}$ 边界设置错误 将 $\\text{DP}$ 贪心化 不开 $\\texttt{long long}$ 二分答案边界设置过小 常数因子过大影响程序效率 常州集训 Week 1经过多方面的努力，我们学校的 OIer 获得了前往常州一中集训的宝贵机会。 $\\text{Day 1 2021.10.2}$ 第一次来常州一中，在无比激动的心情之下大致浏览了校园风貌，随即开始参加模拟赛。 今天的 T1 是一个简单的贪心签到题，T2 是一个稍需一点技巧的贪心，T3 和 T4 都打了暴力。期望得分 $250+$。 但出分之后发现 T2 全爆了，原来是在作乘法的时候没有加 $\\texttt{1LL*}$…… 下午听了讲评和数据结构专题。 $\\text{Day 2 2021.10.3}$一整天的讲座。由于实力太弱再加上主讲人平均五分钟口胡一道紫题难度以上的题目，因而跟不上节奏而且听不懂大部分内容。只能勉强接受稍简单的部分。晚上结合自身情况刷了一些题目。 $\\text{Day 3 2021.10.4}$相比于昨天一整天的讲座，今天是一整天的模拟赛。 上午的模拟赛：T1 是一个组合数学的签到题；T2 不会，直接骗分；T3 欲用 $\\texttt{map}$ 配合容斥维护，但没有调出来。最终得分 $100+10+0=110$。 下午的模拟赛：T1 是一个细节较多的贪心；T2 是一个简单的 $\\text{DP}$；T3 是一个较难的 $\\text{DP}$，考场上找了 $2 \\text h$ 的规律，但宣告失败。最终得分 $60+100+0=160$。T1 因为细节没注意到位而挂掉，T3 交了记搜，但炸了。 晚上把前一天的入门组题刷掉了，但有一道题还是调了十几分钟。看来真实水平暴露出来了啊。 从今天的表现可以看出最近状态不太好，排名都是 $16/36$，还需注意好细节。 $\\text{Day 4 2021.10.5}$上午进行模拟赛： T1 是一道贪心，但由于自己语文不好而没有拿到满分。 T2 是一道数学题，赛时没有想出来，只能打暴力。该题在洛谷上评到了紫题难度，但实际上经过推算也不难做。 T3 是一道随机化题，赛时打了一个用 $\\texttt{map}$ 维护的暴力，本来可拿 $50$ 分。但由于细节再次注意不到位而爆零。 T4 是一道难度中等的图论题，赛时由于 T2 考虑太久而没有写。 本来得分可以是 $100+30+50+0=180$ 的，但挂成了 $50+30+0+0=80$，排名降到了 $25/36$。 下午主讲人进行了以「OI 中的数学问题」为题的讲座，内容包括最简单的快速幂、线性筛和较难的组合数、欧拉函数、费马小定理等。个人认为这次的内容至少还能够接受，不像前几天那么难，收获还是不小的。 晚上按自己的思路把昨天上午的 T3 调过出去了，貌似方法和其他人都不大一样。具体是对每个字符串跑 $\\text{DFS}$ 记录贡献，最后容斥计算答案。 $\\text{Day 5 2021.10.6}$上午进行模拟赛： T1 可以反向求最短路，考虑到边权为 $1$ 可以直接 $\\text{BFS}$。考场上顺手打了 $\\mathcal O(n \\log n)$ 的 $\\text{Dijkstra}$。本来认为 $n \\le 10^7$ 可以通过，但程序常数较多，只拿了 $80$ 分。修改为 $\\text{BFS}$ 后才可以拿满分。 T2 一开始没看出解法，但到了考试最后半小时想出了贪心正解，即离散化后模拟取最大值。 T3 看出来是一个扫描线，但自己不会打所以只能暴力。 T4 没来得及做，实际上是一道「多合一」的题。 T1 的失败也警示自己不要拘泥于一些经常打的算法，更不要看到题目就想当然。这次挂了 $20$，下次说不定就是 $100$。 这次最终得分 $80+100+10+0=190$，排名 $12/38$。今天虽然排名有所上升，但依然有进步空间。 下午讲评后，由于第二天要参加月考，因此四点多就出发回家了。 临走前拍了校园内的一些照片和常州一中夜景： CSP2021 复赛$\\text{Day } -\\inf$国庆常州集训回来之后立刻月考，年级排名 $150+$ $\\text{Day -1 2021.10.21}$晚上在机房与老师一起观看领队会议。江苏新开发出了一个 JSOI Linux 收发系统。其优点是能在服务器上用最接近于评测的编译器进行编译运行，能有效避免 Windows 编译通过而实际 CE 的情况。缺点是评测较慢，但好在考试时可以不依赖它进行调试。 $\\text{Day 0 2021.10.22}$CSP 提高组考试前一天我居然才开始学习单调队列！！！ $\\text{Day 1 2021.10.23}$ $\\texttt{[7:25 - 11:00]}$ 学校周六正常上课，所以翘了课去机房刷题。先做了前几天洛谷比赛的一道橙题，然后又敲了一些板子来加深记忆。 $\\texttt{[11:00 - 14:00]}$ 出发前往南京航空航天大学将军路校区。在入场前膜拜了同校的大佬，希望可以增加一些 RP。 $\\texttt{[14:00 - 14:30]}$ 调试过程中先敲了快读。虽然前几次都没有考到，但我还是打算打一下线段树（事实证明这次确实考了），随后打了最短路、最小生成树之类的。同时熟悉一下新的收发系统。 $\\texttt{[14:30 - 14:35]}$ 大致浏览了一下题面。第一眼感觉 T1 像一个二分答案；T2 数据范围较小，但可能不太好做，貌似暴力好写一些；T3 爆搜实现不难，可先骗取一定分数；T4 细节多，估计暴力都难打。决定开题顺序为 $1 \\to 3 \\to 2 \\to 4$。 $\\texttt{[14:35 - 17:00] T1}$ $\\texttt{[14:35 - 15:00]}$ 开始考虑 T1 的做法。由于浏览题面时感觉可以用二分答案，因此这个实际上错误的思路束缚了我很久。后来发现有国内国际两种航班，虽然单独考虑存在单调性，但同时考虑则失去了二分所必需的性质，也证明了二分实际上不可行。 $\\texttt{[15:00 - 15:15]}$ 本来以为想到了正解但未遂，这在考场上对自己的心理影响无疑是巨大的。为了有效减小这种负面影响，我决定先打暴力。瞄了一眼题面，发现可以先离散化所有时刻，然后再按时刻从小到大排序所有航班信息。接着外层枚举国内/国际分配到的廊桥数量，内层扫一遍排序后的航班信息统计答案即可。若 $n,m_1,m_2$ 同阶，这样的复杂度是 $\\mathcal O(n^2)$，可以先保证把 $40$ 分拿在手里。调了一会儿之后便过了所有样例和大样例。 $\\texttt{[15:15 - 17:00]}$ 打完暴力之后设法考虑是否能优化。经过一个小时在草稿纸上的思考之后，发现无法找到更简单的方法。于是就把暴力代码打开，把中间计数器输出，猛然发现计数器大小是单调不递减的！因此想到了可以二分并线段树维护，可以将平方优化为 $\\log$。怒码 3KB 后过了样例、大样例。但提交了无暴力的程序，事后想想也是十分惊险。 $\\texttt{[17:00 - 17:15] T3}$ 对于暴力，可以用 $\\texttt{vector}$ 维护当前状态，然后 $\\text{DFS}$。但写完后过不了大样例，于是静态查错了半天，没有发现问题，因此决定先开 T2。 $\\texttt{[17:15 - 18:00] T2}$ 看起来可以搜索，但打到一半发现很难判断当前字符串是否合法。考虑了一会儿发现想不出合适之法，就打了一个乱搞。 $\\texttt{[18:00 - 18:15] T4}$ 发现可以状压，复杂度为 $\\mathcal O(2^{nm})$，可得 $10$ 分。但写完后又过不了大样例！！！ $\\texttt{[18:15 - 18:25] T3}$ 看能不能逆天改命，把 T3 调出来，最终失败了。 $\\texttt{[18:25 - 18:30]}$ 检查所有程序，防止出错。期望得分 $100+0+0+0=100$，同时幻想弱数据可以让自己多拿几分。 $\\texttt{[18:30 - 19:00]}$ 考试结束后认真聆听旁边的人的交谈，听到了网络流，看来自己会的真的太少了。 $\\texttt{[19:00 - 20:30]}$ 在车上与同校大佬交谈，发现他们 T1 也用的是线段树，但思路与我完全不一样。考虑到后面三题都可能爆掉，因此感觉自己可能没戏了，于是干脆闭目养神。 $\\texttt{[21:30 - 22:00]}$ 在洛谷和 InfOJ 等 OJ 估分，发现 T1 好像能 A，但其它三题一分都没有。 $\\text{Day 2 2021.10.24}$早上起床后觉得这次 T1 真的有惊无险，决定在洛谷上写个题解整理一下思路。下午看新闻发现南航发生了一起严重的爆炸事故。想起前一天刚在那里考试，不禁思绪万千。 $\\text{Day 8 2021.10.30}$在常州一中参加信息集训，晚上通知说 CSP 成绩出来了。查了一下发现真的只有 $100$。 $\\text{Day 14 2021.11.5}$认证名单出来了，分数线只有 $120$。其实只要再稍微努力一下就有国一。这次只能 2= 滚粗了。 CSP 总结从去年和今年的 CSP 来看，T1 的难度往往不是最简单的——事实证明去年 T2 和今年的 T3 都稍容易一些。因此在考场上要明确开题顺序，果断作出要考虑正解还是打暴力的选择。但最重要的还是要提升自身实力，多学习一些实用算法，避免在考前一天还在学习基础算法。 常州集训 Week 2这周继续前往常州一中集训。 $\\text{Day 1 2021.10.30}$上午进行模拟赛： T1 反向 $\\text{DFS}$，途中标记即可。 T2 打了暴力。 T3 貌似跟图论毫无关系，用二分答案过了。 T4 是一道差分约束题目，用暴力拿了 $10$ 分。 最终得分 $100+20+100+10=230$，排名 $15/27$。 下午讲评时，主讲人说 T3 本来是用 $\\text{SPFA}$ 过的，但实际上二分答案效率更高。讲评后主讲人进行了图论专场讲座，为我们普及图论相关知识。 晚上练习时自学了模拟赛 T2 的二分图和 T4 的差分约束。 $\\text{Day 2 2021.10.31}$上午进行模拟赛： T1 是一道数学题但没想到正解，暴力骗了 $60$。 T2 是一道组合数学，但依然没有看出来，只能打暴力。 T3 没来得及做，程序里只输出了一串 $-1$。 最终得分 $60+40+10=110$，排名 $14/26$，并不算很好。 下午讲评才发现 T1 如此简单。而 T3 题目名为 $\\texttt{kal}$，实际上考的是 $\\text{Kruskal}$，只要配合并查集即可轻松过题。讲评结束后就回家了。 拍照留念： $\\text{Day 3 2021.11.1}$在同校大佬的指点下，写了一个效率更高矩阵快速幂，甚至可以把数据范围从 $200000$ 开到 $10^{18}$ 以上。这也说明了 std 也不一定是最优解。 $\\text{Day 4 2021.11.2}$在离开常州后的几天之后，常州出现了确诊病例。幸亏没有受到影响。 常州集训 Week 3由于疫情，这几周都在学校通过线上形式集训，还邀请了扬州中学、华罗庚中学的同学参加。 $\\text{Day 1 2021.11.6}$上午进行模拟赛： T1 其实做法很显然，但赛时又没有想到。赛时对 $1 \\sim 5$ 和 $6 \\sim 7$ 测试点进行判断，实际上可得 $70$ 分。但由于数据较水，实际上拿了 $80$。 T2 是一道莫队，但赛时并不会，就用 $\\texttt{vector}$ 配合 $\\texttt{lower_bound}$ 进行暴力。但该题数据依然很水，拿了 $80$。 T3 打了 $60$ 的暴力。 T4 打的是 $30$ 的暴力，但挂成了 $10$ 分。 最终得分 $80+80+60+10=230$，排名 $10/45$。由于数据较水相对前几次还是不错的。 下午讲评后进行 $\\text{DP}$ 专题，包括对 $\\text{DP}$ 的若干优化。结束之后回家进行了一些练习，学习了莫队算法。 $\\text{Day 2 2021.11.7}$上午进行模拟赛： T1 是一道数学题，没能想出来。 T2 是一道单调队列，但调炸了。 T3 和 T4 直接上暴力了。 最终得分只有 $0+0+10+0=10$，排名 $33/44$。可以见得状态非常糟糕，一道简单的单调队列居然炸成 $0$ 分。 下午讲评了各题做法，实际上 T1 的做法用到了 NOIP T2 上。讲评之后没有进行讲座，留了时间自主练习。 常州集训 Week 4这周依然在学校进行。 $\\text{Day 1 2021.11.13}$上午进行模拟赛： T1 是一道二分答案，但赛时只打了 $50$ 的暴力。 T2 通过打表发现与斐波那契数列有关，但没有找到规律。因此只打了 $40$ 的暴力。 T3 没有理解题意，再加上时间紧张，没有拿到分。 T4 通过朴素暴力可得 $60$。 最终得分 $50+40+0+60=150$，排名 $12/42$。 下午讲评发现 T2 可以直接递归求解。之后进行「数论简谈」、「凸壳」、「线性数据结构基础」三个专题讲座。 $\\text{Day 2 2021.11.14}$上午进行模拟赛： T1 是一道 $\\mathcal O(nk)$ 的 $\\text{DP}$。 T2 看起来就是背包，但居然没有调出来。 T3 和 T4 都打了暴力。 最终得分 $100+30+70+20=220$，排名 $20/41$。 下午没有进行讲评和讲座，于是把 T2 和 T3 正解调过去了。 NOIP 2021$\\text{Day } -\\inf$这段时间继续参加模拟赛。考前新学了莫队、$\\text{Tarjan}$ 算法，复习了拓扑排序、线段树、$\\text{Dijkstra}$ 等。 $\\text{Day -16 2021.11.3}$收到通知，获得参加 NOIP 的资格，那就赶快准备起来。 $\\text{Day 0 2021.11.19}$比赛地点在金陵中学河西分校。由于早上比赛，因此入住酒店。与 CSP 相似，这天晚上受教，打了 $\\text{KMP}$ 的板子，但实际上并没有理解，很快就忘记了。所以干脆去打其它的。 $\\text{Day 1 2021.11.20}$ $\\texttt{[7:00 - 7:45]}$ 在考场建筑「创想空间」外排队，想起了 NOIP 是最关键的一战，心里无比紧张，但还是尽全力尝试平复心情。 $\\texttt{[7:50 - 8:30]}$ 敲了一些可能用到的板子。 $\\texttt{[8:30 - 8:35]}$ 浏览题面。发现 T1 是一个纯询问且每次询问只有一个的题，又因为数据范围不小，感觉需要一定的预处理。T2 和 T3 一看像数学题，可能存在一些有用的结论。T4 跟 CSP T4 的题面都很长，估计短时间无法突破。确定开题顺序为 $1 \\to 2 \\to 3 \\to 4$。 $\\texttt{[8:35 - 10:30] T1}$ $\\texttt{[8:35 - 9:00]}$ 先打了最原始的 $\\mathcal O(N^2 \\lg N)$ 预处理暴力，可以通过小一些的样例。 $\\texttt{[9:00 - 10:30]}$ 进行一系列的优化。先是发现了不符合的整数没必要继续跑循环，优化后大样例跑了大约 $4$ 秒，还需进一步修改。随后发现只要被标记了就无需继续覆盖，因为后面的肯定已经覆盖完了，这样之后大样例所需时间为 $1.004$ 秒。于是考虑卡常，把快读全部换成 $\\texttt{fread}$ 读入，时间降到 $0.6$ 秒。加了快写之后优化到 $0.4$ 秒。虽然复杂度不好证明，但优化后感觉应该不会有什么问题，就先交到收发系统里去了。 $\\texttt{[10:30 - 11:00] T2}$ 先打暴力 $\\text{DFS}$，能过测试点 $1 \\sim 4$，$20$ 到手。后来想搜索有很多重复状态，联想到了 $11$ 月 $7$ 日模拟赛的 T1，通过数学手段进行了一定的优化。测试点 $14 \\sim 15$ 的规模大约跑了 $2$ 秒左右，运气好是可以通过的。 $\\texttt{[11:00 - 11:30] T3}$ 先写了一个 $\\mathcal O(1)$ 求方差和修改方差值的函数备用。接着写了 $\\text{DFS}$，用 $\\texttt{map}$ 和 $\\texttt{vector}$ 维护当前序列是否已经访问过，然后直接爆搜。想了一下之后发现测试点 $1 \\sim 3$ 能过，至少有 $15$。 $\\texttt{[11:30 - 12:30] T4}$ 暴力调了一个小时过不了任何样例，决定不管了。 $\\texttt{[12:30 - 12:50] T3}$ 发现 $n \\gt 4$ 的情况运行时间都很长，于是干脆对 $n \\gt 4$ 的情况乱搞。具体就是对于每次拓展选择修改后方差值最小的继续拓展，有点贪心的特点，但错误性也是显然的——过不了下发的样例。但与其等着暴力代码超时，还不如对拿不了的分的部分打一个乱搞，同时幻想能多骗一些分。 $\\texttt{[12:50 - 13:00]}$ 检查所有程序，防止出错。期望得分 $100+[20,30]+[12,?]+0=[132,?]$。 $\\texttt{[13:00 - 15:40]}$ 回到酒店吃饭，然后上车返程。期间与同校大佬讨论了 T1 的做法，发现就是类埃氏筛。而 T2 可以打 $60$ 的状压而自己没有看出来！！！ $\\texttt{[15:40 - 16:30]}$ 回到学校之后周六课程还未结束，在备用教室中等待。测了一下洛谷民间数据，T1、T2 得分分别为 $100,30$，符合预期。 $\\texttt{[18:00 - 20:00]}$ 到各个 OJ 测民间数据，其中大部分是 $100+30+28+0=158$，但甚至有一个高达 $100+30+52+0=182$。貌似 T3 乱搞居然能拿分？！ $\\text{Day 2 2021.11.21}$发现 T1 做法不严谨，直接取所有询问的最大值加了 $1000$ 作为类埃氏筛的最大值，但实际上可以轻松被 $2 \\times 10^5$ 个询问值为 $7 \\times 10^6-2$ 的数据卡掉。虽然好几处 OJ 都没有出现这种数据，但最坏可以直接 $100 \\to 50$。 莫名联想到： 2018 年 7 月 19 日，某位同学在 NOI Day 1 T1 归程 一题里非常熟练地使用了一个广为人知的算法求最短路。然后呢？$100 \\rightarrow 60$；$\\text{Ag} \\rightarrow \\text{Cu}$；最终，他因此没能与理想的大学达成契约。小 F 衷心祝愿大家不再重蹈覆辙。 虽然这并不是 NOI 这么重要的赛事，被卡的概率也不是很大，但一旦分数降到 $50$，后果也是很严重的。这也提醒自己无论是否在 OI 中，都要注意细节。 $\\text{Day 10 2021.11.29}$期中考试成绩出来了，成绩甚至比月考还要不堪入目 看来竞赛真的会让文化课成绩上下波动，搞竞赛的风险也很大，但为了 OI 还是值得的。 晚上回家后发现官方成绩也出来了： 看来运气真的不错——T1 没有被卡，T3 的乱搞还有这么多分。 $\\text{Day 14 2021.12.3}$获奖名单出炉。基准线是 $140$，江苏国一分数线是 $150$，这次终于拿到了国一。这也应该算是自己 AFO 的标志了。下面一定要好好忙文化课，把前面落下的尽快补上去。 竞赛生涯总结这几个月的信息竞赛虽然给我的学业带来了巨大的压力，但实际上也让我收获了很多。 虽说在五大学科竞赛中，信息可能算得上是与高考关系最小的一门，但它实际上教给了我很多可以适用于平时学习中的经验。从这次竞赛来看，往往题目都很难彻底解决，但有部分分可以获得。与其绞尽脑汁思考一道题目的正解，不如想办法多拿一些分数或者利用剩余时间去检查错误。再者，信息竞赛让我深刻地认识到了细节决定成败的道理。理科试卷中在细节上犯错往往会错掉整个大题；而信息竞赛中一旦出错，可能会白白失去几十分甚至一题从 $100$ 分掉到 $0$ 分。 参加信息竞赛源于我个人的兴趣。我从小学开始接触 JavaScript，学会了如何制作最简单的动画程序。虽然这在现在看来简直微不足道，但实际上培养了我对编程的兴趣。进入初中，我在初一和初二甚至连普及组复赛都没有资格参加。在面临选择是否继续的关头，我还是决定坚持下来。到了初三，我利用几乎整个国庆的时间着手准备初赛，最终才得以进入复赛。复赛中我如愿以偿，获得了普及组一等奖和提高组二等奖。 到了高中阶段，学业更为紧张，竞赛的功利性也更强。从暑假开始，马老师就带领我们大量做题。高中的竞赛相比于之前的一大区别是有了与高手交流的机会。有一个优秀的交流伙伴，既能分享心得体会、交流解题方法，又能相互竞争、共同进步。在这样的环境之下，我成功地进入了 CSP 提高组的复赛，获得了后续的参赛资格。CSP 的复赛我只拿到了二等奖。虽然 CSP 成绩并没有 NOIP 联赛含金量高，但每个机会都要尽可能把握住。 信息竞赛知识的积累可以视为制作珍珠项链的过程——通过做题探索并学习新的算法，从而不断完善知识体系。在准备联赛的过程中，马老师多次带我们去常州一中集训，也不辞劳苦地陪伴我们在学校机房做模拟题。集训和平时模拟中难免会有题目考查自己掌握不牢或完全生疏的内容，而这些题目不仅有助于引出新的知识和算法，而且比单纯学习给人带来的印象更为深刻。同时，集训过程中的交流机会也变得更多。我与同校高手进行交流之后深深感受到了巨大的差距。在认识他人和认识自己的过程中，我更加明确了自己的不足。 在这样的自我提升之下，我怀着紧张的心情，踏入了 NOIP 联赛的考场。这次相比于 CSP 复赛的 $4$ 个小时，多了 $30$ 分钟的考试时间。我决定先利用前一个小时的时间把第一题做完。第一题难度不是很大，于是在思路明朗之后就进入了下一题。第二题自己没想出正解，但进行了合理的“骗分”。值得一提的是，这道题的思想在联赛前一个月的模拟赛中曾经出现过。当时那题自己没有做对，从而导致印象深刻。以至于到了赛时，那道题立马从我的脑海中浮现出来了，让我从原来的 $20$ 分提高到了 $30$。第三题仍然采取写“暴力”程序“骗分”的做法，期望得分是 $12$ 。第四题本来可以通过“暴力”拿到 $24$ 分，但没能成功。这时我作出放弃第四题而完善第三题的决定，通过随机的手段多拿了一些分数。最终得分是第一题 $100$ 分，第二题 $30$ 分，第三题 $40$ 分，第四题 $0$ 分，共 $170$ 分，超过了国一线。拿到国一这个奖项，其实并不完全在于自己对知识和算法精通的掌握。考试技巧的合理运用也尤为关键。正如马老师所说，只要把会做的题目做对，再“骗取”一些分数，就离国一不远了。当然，客观来说，这样的策略是有很大的运气成分的。真正想有稳定的成绩，还要增强自身实力。但是在思路实在无法打开的情况下，进行一些合理的尝试也是可取的。就像前面所说，这一点在很多其它场景中也是适用的。 一等奖对于很多竞赛生来说绝对算不上是终点——他们有着冲省队、争金夺银的宏大理想。拿到一等奖也绝不等同于已经在这一方面有了很深的理解和认识。考虑到自身实力的不足和高中学业的紧张，大概我的信息竞赛生涯就要到此结束了。这段时间里，我想感谢始终鼓励自己的父母、辛勤付出的马老师和学校的大力支持。一起参与竞赛的校友也一直陪伴着我。他们既是我的知心朋友，又是我的潜在竞争者。没有了他们的帮助，我绝对不可能把这一兴趣坚持到现在。 希望自己能把耽误的功课尽快补上去，在后续的高中生活中取得更大的进步。同时衷心祝愿一中的各科竞赛在未来取得更为丰硕的成果。","link":"/OI/OI2021/"},{"title":"P6851 onu 题解","text":"这是一道贪心题，但细节较多，需要一一考虑。 题目要求的就是获得糖果数量的最大值，因而我们就必须要分析糖果从何而来。 如果小 D 不弃权，不妨设其出的牌点数为 $x$。那么在本题中，糖果的获取 / 失去方式有： 初始糖果数量为 $v$ 小 D 与小 C 拼点后获胜，每次可以获得 $c+x$ 颗 小 D 与小 C 拼点后失败，每次可以获得 $x-c$ 颗（即失去 $c+x$ 颗） 小 D 选择弃权，每次可以获得 $-c$ 颗（即失去 $c$ 颗） 本题中，小 C 在拼点上有主动性。即若小 C 发起拼点，则小 D 必须回应。 举个极端的例子：如果小 D 有 $10^5$ 张同种花色的牌，而小 C 却在该花色下没有牌，那么即使小 D 有再多的这种牌，也无济于事。反之，如果小 C 有 $10^5$ 张同种花色的牌，而小 D 却在该花色下没有牌，那么他只能选择弃权（从而失去 $10^5c$ 颗糖果）。 因而，我们必须要利用好小 D 的牌来应对小 C。 在贪心的过程中，我们实际上只需要考虑情况 $2,3,4$。 对于小 D 来说，他只在卡牌的选择上有主动性。正是因为有了这个主动性，才有了本题。 从整体来看，小 D 应当尽量保证自己赢的次数更多，从而能够赚得更多的糖果（如果赢的次数少，那么输的糖果就多），即多执行情况 $2$。 而情况 $2$ 该以什么样的顺序执行也是一个问题。为了获得更多的糖果，就要让小 D 尽可能打大的牌（这样赢的糖多）。而大牌所选择的拼点对象也得考虑。例如，我们应当避免用小 D 的 $10^5$ 点和小 C 的 $1$ 点进行拼点，否则就失去了一个能够赢过小 C 更大点数牌的机会，也就失去了赢的机会。 因此，我们应当从大到小枚举小 D 牌的点数，然后从大到小寻找小 C 的牌，使得在小 D 能够获胜的情况下，小 C 的牌要尽可能大。 接下里考虑剩余的情况，也就是情况 $2$ 处理完之后还没有打出的牌。 在能赢都赢的情况下，对于小 C 的一张牌，如果我们选择弃权，就失去了糖果，而不弃权的话则还能获得一部分糖果。因此，在小 D 的牌的数量足够的情况下，应当尽量不选择弃权。而如果小 D 剩余的牌大于小 C 的，那么显然应当从大到小进行排序，这样获得的价值就最大。 分析完了之后，我们应当考虑如何编写出这道题的程序来。不妨默认所有的牌都弃权，那么小 D 初始糖果数量就等于 $v-c \\times m$。同时建立输出结果的数组，将其全部初始化为 $-1$。这样有便于后续的处理。 对于每一种花色，我们建立一个线性表来分别存储小 D 和小 C 的牌型信息。然后按刚才的思路和顺序进行模拟即可。 C++ 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;10,stdin),p1==p2)?EOF:*p1++)using namespace std;int n,m,c,res[100001];//res 保存输出结果long long v;//v 表示最多能获得糖果的数量（需要开 long long，否则只有 40 分）char buf[1&lt;&lt;10],*p1=buf,*p2=buf;struct node//建立结构体来存储每张牌的点数和 id 编号（即输入的顺序）{ int val,id; bool operator&lt;(const node &amp;a)const//按照点数大小从大到小排序 { return val&gt;a.val; }};vector&lt;node&gt;a[100001],b[100001];//可以用 vector 形式的线性表来存储两个人手牌的信息bitset&lt;100001&gt;use;//标记小 D 的牌是否被打出template&lt;typename t&gt;void read(t &amp;x){ char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48); ch=getchar(); }}int read(){ int x=0; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') { x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); } return x;}int main(){ memset(res,-1,sizeof(res)); read(n),read(m),read(c),read(v); v-=1LL*c*m;//直接默认全弃权，减去 c*m for(int i=1;i&lt;=n;i++)a[read()].push_back((node){read(),i});//在对应的花色容器中插入对应的牌型信息（点数和编号） for(int i=1;i&lt;=m;i++)b[read()].push_back((node){read(),i}); for(int k=1,ld,lc,lv;k&lt;=1e5;k++)//在点数最小值和最大值之间枚举 { vector&lt;node&gt;D=a[k],C=b[k]; ld=D.size(),lc=C.size(); if(!lc||!ld)continue; /* 如果有一个序列为空就不再操作： 1. 小 C 序列为空：小 D 无法选择拼点 2. 小 D 序列为空：程序开头已经默认全部弃权 */ sort(D.begin(),D.end()); sort(C.begin(),C.end()); //将两个序列排序 vector&lt;int&gt;vacant;//用来保存在卡牌的 vector 中，未被使用的卡牌编号 use.reset();//bitset 重置 for(int i=0,j=0;i&lt;lc&amp;&amp;j&lt;ld;i++) { if(D[j].val&gt;=C[i].val)//判断小 D 是否能获胜 { res[C[i].id]=D[j].id; v+=D[j].val+(c&lt;&lt;1);//前面默认弃权，所以还要多加一个 c use[j++]=true;//标记使用 } } for(int i=0;i&lt;ld;i++)if(!use[i])vacant.push_back(i);//将没有使用的插入 vector 中 lv=vacant.size(); for(int i=0,j=0;i&lt;lc&amp;&amp;j&lt;lv;i++) { if(res[C[i].id]==-1) { res[C[i].id]=D[vacant[j]].id; v+=D[vacant[j]].val; j++; //小 C 打出的牌之前弃权的话，可以在此处相应，选择拼点 } } } printf(&quot;%lld\\n&quot;,v); for(int i=1;i&lt;=m;i++)printf(&quot;%d\\n&quot;,res[i]); return 0;}","link":"/OI/P6851/"},{"title":"P7806 「DCOI2021」A 冰魄吐息 题解","text":"题目中出现了至多和最小等字眼，因此很有可能需要使用二分答案。 怎么进行二分呢？我们对 $d$ 进行二分并检验当前 $d$ 值是否符合题意。不难发现，如果一个点到原点的距离不超过 $d$，那么这个点一定符合（所有正比例函数都经过原点）。因此我们只需考虑 $x^2+y^2 \\gt d^2$ 的点。 由于到一个点距离不超过 $d$ 的集合就是以该点为圆心，$d$ 为半径的圆内，因此我们只需要求出该圆过原点的两条切线的斜率即可。显然在这两条直线 $y=Lx$ 和 $y=Rx$ 之间（不一定是斜率之间）的所有直线都是符合题意的： 我们只需要找到这 $n$ 个点对应的 $L,R$ 值，将这些点的 $[L,R]$ 抽象成 $n$ 条线段，就可以把问题转化成用最少的点覆盖所有线段的经典贪心问题，并以最少的点数是否小于等于 $k$ 作为二分答案的判断条件。 那么最关键的就是如何求解每个点的 $L,R$。这里有三种方法： Solution 1 二分套二分为什么题目要提供点和直线的距离公式呢？实际上，根据之前插图的演示，不难发现直线与点的距离满足一定的单调性。我们可以利用这个性质再一次二分，得到 $L,R$ 的值。 对于斜率等于 $+\\infty$ 的情形，我们可以直接在二分前进行处理，例如将其修改成一个足够大的数。 该做法的时间复杂度为 $\\mathcal O(n \\log x \\log x+n \\log n \\log x)$（$x$ 为二分区间大小）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;int n,k;long double l,r=100000,ans; // 将二分区间右端点 r 调成一个较大的值struct point{ long double x,y;}p[25001];struct interval{ long double L,R; bool operator&lt;(const interval &amp;x)const { return R&lt;x.R; }}a[25001];bool check_dis(int x,int y,long double k,long double d){ long double dis=fabs(y-k*x)/sqrt(k*k+1); return dis&lt;=d;}interval get(point p,long double d){ if(!p.x)return (interval){-p.y/d,p.y/d}; // 特判 x 为 0 的特例 interval ans; long double l=0,r=p.y/p.x; // 第一条切线一定在点 P 的下方 while(l&lt;=r) { long double mid=(l+r)*0.5; if(check_dis(p.x,p.y,mid,d)) { r=mid-0.00000001; // 第二个二分需要很高的精度，否则无法通过 ans.L=mid; } else l=mid+0.00000001; } l=p.y/p.x,r=100000; // 第二条切线一定在点 P 的上方 while(l&lt;=r) { long double mid=(l+r)*0.5; if(check_dis(p.x,p.y,mid,d)) { l=mid+0.00000001; ans.R=mid; } else r=mid-0.00000001; } return ans;}bool check(long double d){ int cnt=0; for(int i=1;i&lt;=n;++i) { if(sqrt(p[i].x*p[i].x+p[i].y*p[i].y)&lt;=d)continue; // 不需要考虑到原点距离已经不超过 d 的点 a[++cnt]=get(p[i],d); // 二分得到斜率区间 } sort(a+1,a+cnt+1); // 排序并用贪心求解 int tot=0; long double tmp=0; for(int i=1;i&lt;=cnt;++i) { if(tmp&lt;=a[i].L) { tmp=a[i].R; if(++tot&gt;k)return false; // 一旦需要的直线数量超过 k 就说明不可行 } } return true;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;++i)scanf(&quot;%Lf%Lf&quot;,&amp;p[i].x,&amp;p[i].y); while(l&lt;=r) { long double mid=(l+r)*0.5; if(check(mid)) { r=mid-0.0001; // 由于只需要保留两位小数，因此精度可以稍低 ans=mid; } else l=mid+0.0001; } printf(&quot;%.2Lf&quot;,ans); return 0;} Solution 2 二分+导角我们可以通过角和斜率之间的转化求解。 考虑下图的情形（两条直线斜率都非负）： 我们可以用反正切函数求出 $PO$ 与 $x$ 轴正方向的夹角 $\\alpha$，用反正弦函数求出 $\\beta=\\angle TOP$。由于两条切线与 $OP$ 之间的夹角相等，因此两条切线与 $x$ 轴正半轴的夹角为 $\\alpha ± \\beta$。 我们还需考虑下面两种情形： 这种情形下切线斜率一正一负，而这此时直接把负的当左端点、正的当右端点显然是错误的（有一个跨 $0$ 的过程）。又因为题中没有负坐标，因此只需要保留正斜率。那么： 在第一种情形中，符合题意的所有斜率的最小值为其中的正斜率，最大值为 $+\\infty$。 在第二种情形中，最小值为 $0$，最大值为其中的正斜率。 考虑当前的点属于哪一种情形： 当切点位于第二象限时（此时 $\\alpha+\\beta \\gt 90^\\circ$），属于第一种。 当切点位于第四象限时（此时 $\\alpha+\\beta \\lt 90^\\circ$），属于第二种。 那么，为什么二分套二分的方法不需要对此进行考虑呢？这是因为，我们可以在求解 $L,R$ 时将二分下界设为 $0$，这样就避免了需要讨论负斜率的情况。 该做法的时间复杂度为 $\\mathcal O(n \\log x+n \\log n)$： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;const double rt=acos(-1)*0.5; // 预处理 90° 弧度制下的值，即 0.5πint n,k;long double l,r=100000,ans;struct point{ long double x,y;}p[25001];struct interval{ long double L,R; bool operator&lt;(const interval &amp;x)const { return R&lt;x.R; }}a[25001];bool check(long double d){ int cnt=0; for(int i=1;i&lt;=n;++i) { long double x=p[i].x,y=p[i].y; if(x*x+y*y&lt;=d*d)continue; ++cnt; long double alpha,beta; alpha=atan(y/x); // 求出 OP 与 x 轴的夹角 if(!x)alpha=rt; // 如果 x=0 则与 x 轴的夹角为 90° beta=asin(d/sqrt(x*x+y*y)); // 求出切线与 OP 连线的夹角 a[cnt].L=tan(alpha-beta),a[cnt].R=tan(alpha+beta); if(a[cnt].L&gt;a[cnt].R)swap(a[cnt].L,a[cnt].R); if(a[cnt].L&lt;0) { if(alpha+beta&gt;rt) { a[cnt].L=a[cnt].R; a[cnt].R=1e18; } else a[cnt].L=0; } } sort(a+1,a+cnt+1); int tot=0; long double tmp=0; for(int i=1;i&lt;=cnt;++i) { if(tmp&lt;=a[i].L) { tmp=a[i].R; if(++tot&gt;k)return false; } } return true;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;++i)scanf(&quot;%Lf%Lf&quot;,&amp;p[i].x,&amp;p[i].y); while(l&lt;=r) { long double mid=(l+r)*0.5; if(check(mid)) { r=mid-0.0001; ans=mid; } else l=mid+0.0001; } printf(&quot;%.2Lf&quot;,ans); return 0;} Solution 3 二分+导边借助之前的示意图： 不妨设 $T$ 的坐标为 $(a,b)$，则 $OT$ 的斜率为 $\\dfrac{b}{a}$，$TP$ 的斜率为 $-\\dfrac{a}{b}$。把 $P(x,y)$ 和 $T(a,b)$ 代入得 $\\dfrac{b-y}{a-x}=-\\dfrac{a}{b}$。化简得 $a^2+b^2=ax+by$。 又因为 $TP=d$，因此有 $(x-a)^2+(y-b)^2=d^2$。化简得 $a^2+b^2-2ax-2by=d^2-x^2-y^2$。 由于 $x,y,d$ 为常数，因此可设 $c=d^2-x^2-y^2$。 因此 $$\\begin{cases}a^2+b^2=ax+by &amp; (1) \\cra^2+b^2-2ax-2by=c &amp; (2) \\cr\\end{cases}$$ 把 $(1)$ 代入 $(2)$ 得 $$ax+by=-c$$ 因此我们可以将 $b$ 用 $a$ 进行表示（仅在 $y \\neq 0$ 时成立）： $$b=\\dfrac{-c-ax}{y}$$ 再代回 $(1)$ 得： $$a^2+\\dfrac{(c+ax)^2}{y^2}=-c$$ $$a^2y^2+c^2+2acx+a^2x^2+cy^2=0$$ $$(x^2+y^2)a^2+2cxa+c^2+cy^2=0$$ $$a_{1,2}=\\dfrac{-2cx±\\sqrt{4c^2x^2-4(x^2+y^2)(c^2+cy^2)}}{2(x^2+y^2)}$$ $$=\\dfrac{-cx±\\sqrt{c^2x^2-(x^2+y^2)(c^2+cy^2)}}{x^2+y^2}$$ $$=\\dfrac{-cx±\\sqrt{-cx^2y^2-y^2c^2-cy^4}}{x^2+y^2}$$ $$=\\dfrac{-cx±y\\sqrt{-c(x^2+y^2+c)}}{x^2+y^2}$$ 最后求出 $b_{1,2}$ 即可得到两条直线的斜率。 特判 $y=0$ 的情形： 此时 $OP=x$，$TP=d$，$OT=\\sqrt{x^2-d^2}$。 作 $TH \\perp OP$ 于 $H$，则 $\\sin \\angle TOH=\\dfrac{TP}{OP}=\\dfrac{TH}{OT}$。因此 $\\dfrac{d}{x}=\\dfrac{TH}{\\sqrt{x^2-d^2}}$，即 $TH=\\dfrac{d\\sqrt{x^2-d^2}}{x}$。然后再在 $\\triangle OTH$ 中用一次勾股定理即可求出 $OH$。最后斜率即为 $\\dfrac{TH}{OH}$。 由于 $y=0$，因此较下方的切线的斜率必然为负。之前提到了本题无需考虑负斜率，因此取斜率的最小值为 $0$，最大值为 $\\dfrac{TH}{OH}$ 即可。 $x=0$ 的情形不需单独考虑，因为其斜率的范围显然为 $[-\\dfrac{y}{d},\\dfrac{y}{d}]$，适用于一般情况。 与导角的方法类似，我们仍需考虑这两种情形： 考虑每个点属于哪一种情形： 当负斜率的切点位于 $y$ 轴上方时，第一种情形成立。 当负斜率的切点位于 $y$ 轴下方时，第二种情形成立。 相比于导角的做法，该做法时间复杂度仍为 $\\mathcal O(n \\log x+n \\log n)$，但不涉及反三角函数的使用，因此常数较小： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;int n,k;long double l,r=100000,ans;struct point{ long double x,y;}p[25001];struct interval{ long double L,R; bool operator&lt;(const interval &amp;x)const { return R&lt;x.R; }}a[25001];bool check(long double d){ int cnt=0; for(int i=1;i&lt;=n;++i) { long double x=p[i].x,y=p[i].y; if(x*x+y*y&lt;=d*d)continue; ++cnt; if(!y) // 考虑 y=0 的情况 { a[cnt].L=0; long double b1=d*sqrt(x*x-d*d)/x; long double a1=sqrt(x*x-d*d-b1*b1); a[cnt].R=b1/a1; } else { long double c=d*d-x*x-y*y,delta=-c*(x*x+y*y+c); long double a1=(-c*x+y*sqrt(delta))/(x*x+y*y); long double a2=(-c*x-y*sqrt(delta))/(x*x+y*y); long double b1=(-c-a1*x)/y,b2=(-c-a2*x)/y; a[cnt].L=b1/a1,a[cnt].R=b2/a2; if(a[cnt].L&gt;a[cnt].R) { swap(a[cnt].L,a[cnt].R); swap(a1,a2); swap(b1,b2); // 一定要注意连同 a1,a2,b1,b2 同时 swap，否则会影响下面对答案的修正 } if(a[cnt].L&lt;0) // 一正一负的情形下，负的必然存储在 L 中 { if(b1&gt;0) { a[cnt].L=a[cnt].R; a[cnt].R=1e18; // 将右端点赋为极大值 } else a[cnt].L=0; // 否则将左端点由负改为 0 即可 } } } sort(a+1,a+cnt+1); int tot=0; long double tmp=0; for(int i=1;i&lt;=cnt;++i) { if(tmp&lt;=a[i].L) { tmp=a[i].R; if(++tot&gt;k)return false; } } return true;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;++i)scanf(&quot;%Lf%Lf&quot;,&amp;p[i].x,&amp;p[i].y); while(l&lt;=r) { long double mid=(l+r)*0.5; if(check(mid)) { r=mid-0.0001; ans=mid; } else l=mid+0.0001; } printf(&quot;%.2Lf&quot;,ans); return 0;}","link":"/OI/P7806/"},{"title":"P7960 [NOIP2021] 报数 题解","text":"仔细看一眼题目，发现每次询问都只给出一个数，因此可以想到需要预处理。那么怎么进行预处理呢？ 一开始可能会想到这样一种算法：把 $[1,\\max{x}]$ 中每一个含有 $7$ 的整数存入队列中，在数的前面、后面补上任意数位，具体实现可以使用搜索。但仔细一想，发现这样重复的状态多、效率极低，同时写起来也比较麻烦，不可行。 既然枚举出所有不能报出的整数不行，那我们能不能从所有的整数中找到不能报出的整数呢？ 要想找到这样的整数，我们可以在一个足够大的整数范围之内进行判断。具体地，对于每个待判断的整数，先看是否含有数位 $7$。若含有，则对该整数在区间范围内的所有整数倍进行覆盖。因此可以写出这样的初步代码： 123456789101112131415bool check(int x){ while(x) { if(x%10==7)return true; x/=10; } return false;}void init(int N) // N 表示枚举整数的上限{ for(int i=2;i&lt;=N;++i) for(int j=1;i*j&lt;=N;++j) // 覆盖该整数的所有正整数倍 flag[i*j]=true; // flag[i] 为真表示该数不能被报出} 这样我们便可以在 $\\mathcal O(N^2 \\lg N)$ 的复杂度内找出所有不能被报出的数。 对于询问，我们可以 $\\mathcal O(N)$ 预处理比每个能被报出的整数大的第一个不能被报出的整数，再单次 $\\mathcal O(1)$ 询问。当然，也可以将预处理之后的数据直接进行存储，然后在询问时临时进行二分，单次询问复杂度为 $\\mathcal O(\\log_2{\\text{len}})$（$\\text{len}$ 表示区间范围内能报出的整数的数量）。 但是，询问整数最大值在 $10^7$ 数量级下，肯定会超时。不难发现，每次覆盖的复杂度为 $\\mathcal O(N)$。但如果当前枚举到的整数已经被覆盖到，那么它的倍数也一定已经被覆盖过了。因此对于已经覆盖到的整数，不再进行覆盖： 12345678void init(int N){ for(int i=2;i&lt;=N;++i) { if(flag[i]||!check(i))continue; for(int j=1;i*j&lt;=N;++j)flag[i*j]=true; }} 接着我们需要考虑 $N$ 的取值大小。由于 $10^7$ 本身可以被报出的，因此需要找到大于该数且不能被报出的最小整数。经过试验可知为 $10^7+1$。因此取 $N=10^7+1$ 即可。 该部分的代码乍一看像埃氏筛，但实际上与埃氏筛的复杂度并不相同，而且比较难证。不过，我们可以通过一个更为直观的方法证明该算法不会超时： 当 $N$ 取 $10^7+1$ 时，经过试验可知，筛选过程中不需要继续向后覆盖的整数个数为 $923655$。 也就是说对于其中 $923655$ 个整数，只需进行一次覆盖操作；而剩余的无需覆盖。 单次覆盖操作的复杂度取决于 $N$ 和当前整数的大小。设当前整数为 $i$，则单次覆盖的期望复杂度为 $\\mathcal O(\\dfrac{N}{i})$。 那么总覆盖的复杂度的常数在最坏情况下等于 $\\sum_{i=1}^{923655} \\dfrac{10^7+1}{i} \\approx 143133115 \\approx 1.4 \\times 10^8$，可以保证不超时。实际上，需要被覆盖的不可能只集中在前面。由于最坏情况的效率都可以保证，因此这样的做法显然是可以通过的。 因此我们可以得到采用这种方法的两种代码： 单次 $\\mathcal O(1)$ 询问： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;int T,a[10000101];bool flag[10000101];bool check(int x){ while(x) { if(x%10==7)return true; x/=10; } return false;}void init(int N){ for(int i=2;i&lt;=N;++i) { if(flag[i]||!check(i))continue; for(int j=1;i*j&lt;=N;++j)flag[i*j]=true; } for(int i=1,t=1;i&lt;=N;++i) { if(!flag[i]) { a[t]=i; t=i; } }}int main(){ init(10000001); read(T); for(int i=1,x;i&lt;=T;++i) { read(x); if(flag[x]) { pc('-'); pc('1'); } else write(a[x]); pc('\\n'); } fwrite(obuf,p3-obuf,1,stdout); return 0;} 每次在 $\\mathcal O(\\log_2{\\text{len}})$ 的复杂度内通过二分进行询问： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int T,len,a[800001];bool flag[10001001];bool check(int x){ while(x) { if(x%10==7)return true; x/=10; } return false;}void init(int N){ for(int i=2;i&lt;=N;++i) { if(flag[i]||!check(i))continue; for(int j=1;i*j&lt;=N;++j)flag[i*j]=true; } for(int i=1;i&lt;=N;++i) { if(flag[i])continue; a[++len]=i; }}int binary(int l,int r,int x){ while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(a[mid]&gt;x)r=mid-1; else l=mid+1; } return a[l];}int main(){ init(10000001); read(T); for(int i=1,x;i&lt;=T;++i) { read(x); if(flag[x]) { pc('-'); pc('1'); } else write(binary(1,len,x)); pc('\\n'); } fwrite(obuf,p3-obuf,1,stdout); return 0;}","link":"/OI/P7960/"},{"title":"【欧拉计划】10. Summation of primes","text":"（本题取 $n=2000000$） 【思路】$\\mathcal O(n)$ 欧拉筛： 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;const int maxn=2000000;int prime[maxn];bool vis[maxn];long long ans;void euler(){ for(int i=2;i&lt;=maxn;++i) { if(!vis[i]) { prime[++prime[0]]=i; ans+=i; } for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } }}int main(){ euler(); printf(&quot;%lld\\n&quot;,ans); return 0;}","link":"/projecteuler/10/"},{"title":"【欧拉计划】1. Multiples of 3 and 5","text":"（本题取 $n=1000$） 【思路】$\\mathcal O(n)$ 枚举所有能被 $3$ 和被 $5$ 整除的数，最后把能被 $15$ 整除的数减掉： 12345678910#include&lt;stdio.h&gt;int ans;int main(){ for(int i=3;i&lt;1000;i+=3)ans+=i; for(int i=5;i&lt;1000;i+=5)ans+=i; for(int i=15;i&lt;1000;i+=15)ans-=i; printf(&quot;%d&quot;,ans); return 0;} 【优化】利用等差数列求和公式 $\\mathcal O(1)$ 求解： 12345678#include&lt;stdio.h&gt;int ans;int main(){ ans=((3+999)*333&gt;&gt;1)+((5+995)*199&gt;&gt;1)-((15+990)*66&gt;&gt;1); printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/1/"},{"title":"P1928 外星密码 题解","text":"本题有两种方法，一种是纯模拟的思想，一种是递归思想。 $\\color{green}{方法}$ $\\color{green}{1：字符串处理}$我们需要操作的对象是方括号内的部分，对于方括号外面的内容，我们不需要进行任何的操作，因此我们要找到最内层的括号，并进行处理。处理完了之后，我们把原来的进行替换。这样一直重复，直到没有括号为止，我们就得到了最终的答案。 例如下面这个数据： 1AC[3[3AK]] 上述数据中，最内层的括号组为 [3AK]，而我们可以发现，最内层的左括号是整个字符串最右边的左括号，右括号则是整个字符串最左边的右括号。因此我们只需要写一个循环，找到这两个字符即可。 我们先查找左括号： 12345678910int l=-1; // l 保存左括号的位置for(int i=str.size()-1;i&gt;=0;--i){ if(str[i]=='[') { l=i; break; }}if(l==-1)break; // 如果找不到，就说明没有括号，即处理完毕 而与之相匹配的右括号必定在左括号的右边，所以搜索范围从 $[0,|str|)$ 变为 $[l,str)$，即： 12345678910int r=-1; // r 保存右括号的位置for(int i=l;str[i];i++) // 搜索区间：从左括号的位置开始到字符串结束{ if(str[i]==']') { r=i; break; }}// 这里不需要特判没有右括号，因为前面在寻找左括号的时候已经特判过了 假如有括号存在，那么被处理的部分则是 $(l,r)$，即两个括号之间（不含括号）的部分。取其子串： 123string ns=&quot;&quot;; // 初始赋值为空for(int i=l+1;i&lt;r;i++)ns+=str[i]; // 搜索区间为两括号之间（不含括号），把这一部分内容全部放入 ns 中str=str.replace(l,r-l+1,rep(ns)); string.replace(start,len,str) 用法：从 start 这个位置开始，取长度为 len 的字符串，将其替换为 str。 在这个时候，因为区间为 $(l,r)$，即 $[l+1,r-1]$，所以长度为 $r-l+1$。而替换的是这一段处理之后的内容，用一个名为 rep 的函数实现。 接下来我们要完成 rep 函数的实现： $\\color{red}{\\text{Step}}$ $\\color{red}{0:}$ $\\color{red}{初始化}$ 将 s 设为函数参数（字符串类型），t 为分离的数字，x 为分离出来的字符串。 $\\color{red}{\\text{Step}}$ $\\color{red}{1:}$ $\\color{red}{分离数字}$ 我们在整个字符串 s 中处理即可，即区间为 $[0,|s|)$。思路如下： 代码： 12345for(int i=0;s[i];i++){ if(isdigit(s[i]))t=(t&lt;&lt;3)+(t&lt;&lt;1)+(s[i]^48); // t 进行累加 else break; // 不是数字就跳出循环} $\\color{red}{\\text{Step}}$ $\\color{red}{2:} $\\color{red}{分离字符串}$ 类比分离数字的方法，我们可以用相似的方式处理： 代码： 123456for(int i=s.size()-1;i&gt;=0;i--){ if(isalpha(s[i]))x+=s[i]; // 字符串加入新字符 else break; // 退出循环}reverse(x.begin(),x.end()); // 注意！我们是倒着进行保存的，所以需要反转 $\\color{red}{\\text{Step}}$ $\\color{red}{3: 拼接}$ 新建一个字符串 y，保存拼接的内容，总共包含 t 个 x 字符串。进行拼接： 12while(t--)y+=x; // 往 y 中加入 t 个 xreturn y; // 返回 y 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;string str;string rep(string s){ int t=0; for(int i=0;s[i];i++) { if(isdigit(s[i]))t=(t&lt;&lt;3)+(t&lt;&lt;1)+(s[i]^48); else break; } string x=&quot;&quot;,y=&quot;&quot;; for(int i=s.size()-1;i&gt;=0;i--) { if(isalpha(s[i]))x+=s[i]; else break; } reverse(x.begin(),x.end()); while(t--)y+=x; return y;}int main(){ cin&gt;&gt;str; while(true) { int l=-1,r=-1; for(int i=str.size()-1;i&gt;=0;i--) { if(str[i]=='[') { l=i; break; } } if(l==-1)break; for(int i=l;str[i];i++) { if(str[i]==']') { r=i; break; } } string ns=&quot;&quot;; for(int i=l+1;i&lt;r;i++)ns+=str[i]; str=str.replace(l,r-l+1,rep(ns)); } cout&lt;&lt;str; return 0;} $\\color{green}{方法}$ $\\color{green}{2：递归}$本题同样可以使用递归的算法： 主函数只需调用递归函数即可，因为递归函数既实现输入，又实现了字符串的处理。 完整代码： 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;string f(){ string s1=&quot;&quot;,s2; char ch; while(cin&gt;&gt;ch) { if(ch=='\\n')break; if(ch=='[') { int t; scanf(&quot;%d&quot;,&amp;t); s2=f(); while(t--)s1+=s2; } else if(ch==']')return s1; else s1+=ch; }}int main(){ cout&lt;&lt;f(); return 0;}","link":"/OI/P1928/"},{"title":"P7913 [CSP-S 2021] 廊桥分配 题解","text":"首先我们需要对原来形象的实际问题进行抽象化。 以样例 1 的国内航班抵达、离开时刻信息为例，我们可以通过区间来表示每架飞机位于机场的时间： 不妨先假设廊桥数量没有限制，那么当一个新的飞机抵达时，显然需要使用一个空闲的廊桥。当飞机离开时，就可以释放出一个空闲的廊桥。因此，我们可以记下所需廊桥的数量。当一架飞机抵达时计数器 $+1$，离开时 $-1$： 具体流程如下： 时刻 航班序号 抵达/离开 当前正在使用的廊桥数量（计数器） $1$ $1$ 抵达 $0+1=1$ $3$ $2$ 抵达 $1+1=2$ $5$ $1$ 离开 $2-1=1$ $6$ $3$ 抵达 $1+1=2$ $8$ $2$ 离开 $2-1=1$ $9$ $4$ 抵达 $1+1=2$ $10$ $3$ 离开 $2-1=1$ $13$ $5$ 抵达 $1+1=2$ $14$ $4$ 离开 $2-1=1$ $18$ $5$ 离开 $1-1=0$ 显然，所需的廊桥数量为计数器在所有时刻内的最大值，在本例中为 $2$。 接下来考虑增加廊桥限制时的操作方法： 在进行计数器 $+1$ 操作时，如果计数器在操作之后超过廊桥限制数量，那么就让该飞机不进入廊桥，同时进行标记以防后面操作时对该航班进行 $-1$ 操作。 如果廊桥数量限制为 $1$，那么示意图将会变成这样（灰色表示无法进入廊桥）： 具体实现方法是先把读入的航班信息按照抵达时刻从小到大进行排序并对时刻进行离散化。然后在 $[0,n]$ 内枚举廊桥数量限制，并在限制条件下对每个离散化后的时刻进行 $+1/-1$ 处理，依次得到最大航班数量。最后进行统计即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;int n,m_1,m_2,ld,li,ans,td[200005],ti[200005],posd[200005][2],posi[200005][2];bool vis[100005];struct flight{ int a,b; bool operator&lt;(const flight &amp;x)const { return a&lt;x.a; }}dom[100005],inter[100005]; // domestic: 国内，international: 国际int solve(int a[][2],int len,int x){ int cnt=0,ans=0; // cnt 为廊桥数量计数器，ans 记录能够进入廊桥的航班数量 memset(vis,false,sizeof(vis)); // vis 数组存储每个航班是否能够进入廊桥 for(int i=1;i&lt;=len;++i) { if(a[i][1]) // 判断是否为抵达 { if(cnt&lt;x) // 判断是否还可进入廊桥 { ++cnt; // 当前廊桥数量 +1 ++ans; // 可进入廊桥的航班数 +1 vis[a[i][0]]=true; // 标记该航班能进入廊桥 } } else if(vis[a[i][0]])--cnt; // 如果当前时刻有飞机离开且该飞机原来在廊桥中，则当前廊桥数量 -1 } return ans;}template&lt;typename T&gt;void read(T &amp;x){ char ch=getchar(); while(!isdigit(ch))ch=getchar(); while(isdigit(ch)) { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48); ch=getchar(); }}int main(){ read(n),read(m_1),read(m_2); for(int i=1;i&lt;=m_1;++i) { read(dom[i].a),read(dom[i].b); td[++ld]=dom[i].a; td[++ld]=dom[i].b; // 将时刻存入待离散化的数组中（国内、国际分开存储） } for(int i=1;i&lt;=m_2;++i) { read(inter[i].a),read(inter[i].b); ti[++li]=inter[i].a; ti[++li]=inter[i].b; } sort(td+1,td+ld+1); sort(ti+1,ti+li+1); // 由于没有重复时刻，因此只需排序、无需去重 sort(dom+1,dom+m_1+1); sort(inter+1,inter+m_2+1); // 按照抵达时刻从小到大进行排序（国内、国际分开） for(int i=1;i&lt;=m_1;++i) { dom[i].a=lower_bound(td+1,td+ld+1,dom[i].a)-td; dom[i].b=lower_bound(td+1,td+ld+1,dom[i].b)-td; // 将航班的时刻修改为离散化后的数值，方便操作 posd[dom[i].a][0]=posd[dom[i].b][0]=i; posd[dom[i].a][1]=1; // 第二维 0 下标存储航班序号、1 下标存储该时刻是否是飞机抵达 } for(int i=1;i&lt;=m_2;++i) { inter[i].a=lower_bound(ti+1,ti+li+1,inter[i].a)-ti; inter[i].b=lower_bound(ti+1,ti+li+1,inter[i].b)-ti; posi[inter[i].a][0]=posi[inter[i].b][0]=i; posi[inter[i].a][1]=1; } for(int i=0;i&lt;=n;++i)ans=max(ans,solve(posd,ld,i)+solve(posi,li,n-i)); // [0,n] 枚举廊桥数量限制 printf(&quot;%d&quot;,ans); return 0;} 这样，我们便得到了一个 $\\mathcal O(n(m_1+m_2)+m_1 \\log m_1+m_2 \\log m_2) \\approx \\mathcal O(n^2)$ 的做法，可以获得 $40$ 分的好成绩。 接着考虑如何对 $O(n^2)$ 做法进行优化。 原来的暴力程序采用先枚举限制再遍历时刻的方法。由于遍历时刻的操作不可优化，因此我们可以考虑先遍历时刻再枚举限制。 不妨用数组 ${\\text{sum}_i}$ 来记录限制数量为 $i$ 时当前所需廊桥的数量，用数组 ${\\text{ans}_i}$ 来记录限制数量为 $i$ 时当前可进入廊桥的航班数量。不难发现，这两个数组一定单调不递减。 在遍历时刻的过程中，对于每一个时刻，我们可以分两种情况讨论： 该时刻有飞机抵达。此时我们可以在 ${\\text{sum}_i}$ 中进行二分，找到一个最大的 $p$，使得 $\\text{sum}_p \\lt p$（即飞机还可进入廊桥）。紧接着，我们把 $[p,n]$ 内的 $\\text{sum}$ 值和 $\\text{ans}$ 值全部加上 $1$。和暴力程序类似，我们在该航班的对应位置标记 $p$，方便后续操作。如果所有的 $\\text{sum}$ 值都不小于 $p$，那么就标记 $-1$。 该时刻有飞机离开。由于该飞机的离开时刻一定晚于抵达时刻，因此我们可以查看之前所做的标记。如果标记 $\\text{pos}$ 不为 $-1$，那么就把 $[\\text{pos},n]$ 内的 $\\text{sum}$ 全部减 $1$，完成还原操作。 如果每次进行暴力 $+1$ / $-1$，那么时间复杂度仍为 $\\mathcal O(n^2)$。但考虑到修改都是区间性的，因此可以通过线段树、区修单查的树状数组或分块实现。 常数较大的 $\\mathcal O(n \\log^2n)$ 线段树代码：（最大时限 $\\approx 200$ $\\text{ms}$） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;bits/stdc++.h&gt;using namespace std;int n,m_1,m_2,ld,li,cn,ANS,td[200005],ti[200005],posd[200005][2],posi[200005][2],pos[100005],ansd[100005],ansi[100005];struct flight{ int a,b; bool operator&lt;(const flight &amp;x)const { return a&lt;x.a; }}dom[100005],inter[100005];struct node{ int l,r,ls,rs,sum,tag;};struct segtree{ node t[200005]; // 这种线段树写法只需开 2 倍空间 void build(int p,int l,int r) // 线段树建树的复杂度为 O(n) { t[p].l=l,t[p].r=r; if(l==r)return; int mid=(t[p].l+t[p].r)&gt;&gt;1; build(t[p].ls=++cn,l,mid); build(t[p].rs=++cn,mid+1,r); } void init() { cn=1; build(1,1,n); } void reset() { for(int i=1;i&lt;=n&lt;&lt;1;++i) { t[i].sum=0; t[i].tag=0; } } void push_up(int p) { if(!t[p].tag)return; int l=t[p].ls,r=t[p].rs; t[l].sum+=(t[l].r-t[l].l+1)*t[p].tag; t[r].sum+=(t[r].r-t[r].l+1)*t[p].tag; t[l].tag+=t[p].tag; t[r].tag+=t[p].tag; t[p].tag=0; } void update(int p,int l,int r,int k) // 线段树区间修改的复杂度为 O(log n) { if(l&lt;=t[p].l&amp;&amp;t[p].r&lt;=r) { t[p].sum+=(t[p].r-t[p].l+1)*k; t[p].tag+=k; return; } push_up(p); int mid=(t[p].l+t[p].r)&gt;&gt;1; if(l&lt;=mid)update(t[p].ls,l,r,k); if(r&gt;mid)update(t[p].rs,l,r,k); t[p].sum=t[t[p].ls].sum+t[t[p].rs].sum; } int query(int p,int l,int r) // 线段树单点 / 区间查询的复杂度均为 O(log n) { if(l&lt;=t[p].l&amp;&amp;t[p].r&lt;=r)return t[p].sum; push_up(p); int mid=(t[p].l+t[p].r)&gt;&gt;1; if(l&gt;mid)return query(t[p].rs,l,r); if(r&lt;=mid)return query(t[p].ls,l,r); return query(t[p].ls,l,r)+query(t[p].rs,l,r); }}sum,ans;void solve(int a[][2],int len,bool flag){ memset(pos,0,sizeof(pos)); if(flag)sum.reset(),ans.reset(); else sum.init(),ans.init(); // flag 表示是否为第一次进行 solve 操作；如果为 false 就进行建树，否则重新赋值 for(int i=1;i&lt;=len;++i) { if(a[i][1]) { int l=1,r=n,p=-1; while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(sum.query(1,mid,mid)&lt;mid) { r=mid-1; p=mid; } else l=mid+1; } // 二分查找最大的 p，使得 sum[p]&lt;p pos[a[i][0]]=p; if(~p) { sum.update(1,p,n,1); ans.update(1,p,n,1); // +1 操作 } } else if(~pos[a[i][0]])sum.update(1,pos[a[i][0]],n,-1); // -1 还原性操作 } for(int i=1;i&lt;=n;++i) { if(flag)ansi[i]=ans.query(1,i,i); else ansd[i]=ans.query(1,i,i); // 将答案存入对应数组中，方便后面进行 O(n) 统计 }}template&lt;typename T&gt;void read(T &amp;x){ char ch=getchar(); while(!isdigit(ch))ch=getchar(); while(isdigit(ch)) { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48); ch=getchar(); }}int main(){ read(n),read(m_1),read(m_2); for(int i=1;i&lt;=m_1;++i) { read(dom[i].a),read(dom[i].b); td[++ld]=dom[i].a; td[++ld]=dom[i].b; } for(int i=1;i&lt;=m_2;++i) { read(inter[i].a),read(inter[i].b); ti[++li]=inter[i].a; ti[++li]=inter[i].b; } sort(td+1,td+ld+1); sort(ti+1,ti+li+1); sort(dom+1,dom+m_1+1); sort(inter+1,inter+m_2+1); for(int i=1;i&lt;=m_1;++i) { dom[i].a=lower_bound(td+1,td+ld+1,dom[i].a)-td; dom[i].b=lower_bound(td+1,td+ld+1,dom[i].b)-td; posd[dom[i].a][0]=posd[dom[i].b][0]=i; posd[dom[i].a][1]=1; } for(int i=1;i&lt;=m_2;++i) { inter[i].a=lower_bound(ti+1,ti+li+1,inter[i].a)-ti; inter[i].b=lower_bound(ti+1,ti+li+1,inter[i].b)-ti; posi[inter[i].a][0]=posi[inter[i].b][0]=i; posi[inter[i].a][1]=1; } solve(posd,ld,false); solve(posi,li,true); for(int i=0;i&lt;=n;++i)ANS=max(ANS,ansd[i]+ansi[n-i]); printf(&quot;%d&quot;,ANS); return 0;} $\\mathcal O(n \\log n + n \\sqrt n)$ 的分块代码：（最大时限 $\\approx 100$ $\\text{ms}$） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;bits/stdc++.h&gt;using namespace std;int n,m_1,m_2,ld,li,len,ANS,td[200005],ti[200005],posd[200005][2],posi[200005][2],pos[100005],id[100005],ansd[100005],ansi[100005];struct flight{ int a,b; bool operator&lt;(const flight &amp;x)const { return a&lt;x.a; }}dom[100005],inter[100005];struct block{ int a[100005],b[325],block[325]; void reset() { memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(block,0,sizeof(block)); } void update(int l,int r,int k) // 分块区间修改的复杂度为 O(sqrt(n)) { int x=id[l],y=id[r]; if(x==y) { for(int i=l;i&lt;=r;++i) { a[i]+=k; block[x]+=k; } return; } for(int i=l;i&lt;=len*x;++i) { a[i]+=k; block[x]+=k; } for(int i=x+1;i&lt;y;++i) { b[i]+=k; block[i]+=len*k; } for(int i=len*(y-1)+1;i&lt;=r;++i) { a[i]+=k; block[y]+=k; } }}sum,ans;void solve(int a[][2],int len,bool flag){ if(flag) { memset(pos,0,sizeof(pos)); sum.reset(),ans.reset(); } for(int i=1;i&lt;=len;++i) { if(a[i][1]) { int l=1,r=n,p=-1; while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(sum.a[mid]+sum.b[id[mid]]&lt;mid) { r=mid-1; p=mid; } else l=mid+1; // 分块单点查询的复杂度为 O(1) } pos[a[i][0]]=p; if(~p) { sum.update(p,n,1); ans.update(p,n,1); } } else if(~pos[a[i][0]])sum.update(pos[a[i][0]],n,-1); } for(int i=1;i&lt;=n;++i) { if(flag)ansi[i]=ans.a[i]+ans.b[id[i]]; else ansd[i]=ans.a[i]+ans.b[id[i]]; }}template&lt;typename T&gt;void read(T &amp;x){ char ch=getchar(); while(!isdigit(ch))ch=getchar(); while(isdigit(ch)) { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48); ch=getchar(); }}int main(){ read(n),read(m_1),read(m_2); for(int i=1;i&lt;=m_1;++i) { read(dom[i].a),read(dom[i].b); td[++ld]=dom[i].a; td[++ld]=dom[i].b; } for(int i=1;i&lt;=m_2;++i) { read(inter[i].a),read(inter[i].b); ti[++li]=inter[i].a; ti[++li]=inter[i].b; } sort(td+1,td+ld+1); sort(ti+1,ti+li+1); sort(dom+1,dom+m_1+1); sort(inter+1,inter+m_2+1); for(int i=1;i&lt;=m_1;++i) { dom[i].a=lower_bound(td+1,td+ld+1,dom[i].a)-td; dom[i].b=lower_bound(td+1,td+ld+1,dom[i].b)-td; posd[dom[i].a][0]=posd[dom[i].b][0]=i; posd[dom[i].a][1]=1; } for(int i=1;i&lt;=m_2;++i) { inter[i].a=lower_bound(ti+1,ti+li+1,inter[i].a)-ti; inter[i].b=lower_bound(ti+1,ti+li+1,inter[i].b)-ti; posi[inter[i].a][0]=posi[inter[i].b][0]=i; posi[inter[i].a][1]=1; } len=sqrt(n); for(int i=1;i&lt;=n;++i)id[i]=(i-1)/len+1; solve(posd,ld,false); solve(posi,li,true); for(int i=0;i&lt;=n;++i)ANS=max(ANS,ansd[i]+ansi[n-i]); printf(&quot;%d&quot;,ANS); return 0;} 常数较小的 $\\mathcal O(n \\log^2 n)$ 树状数组代码：（最大时限 $\\approx 50$ $\\text{ms}$） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;using namespace std;int n,m_1,m_2,ld,li,ANS,td[200005],ti[200005],posd[200005][2],posi[200005][2],pos[100005],ansd[100005],ansi[100005];struct flight{ int a,b; bool operator&lt;(const flight &amp;x)const { return a&lt;x.a; }}dom[100005],inter[100005];struct BIT{ int t[100005]; void update(int x,int k) { while(x&lt;=n) { t[x]+=k; x+=x&amp;-x; } } int query(int x) { int s=0; while(x) { s+=t[x]; x-=x&amp;-x; } return s; } // 这种树状数组的修改和查询复杂度均为 O(log n)}sum,ans;void solve(int a[][2],int len,bool flag){ if(flag) { memset(pos,0,sizeof(pos)); memset(sum.t,0,sizeof(sum.t)); memset(ans.t,0,sizeof(ans.t)); } for(int i=1;i&lt;=len;++i) { if(a[i][1]) { int l=1,r=n,p=-1; while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(sum.query(mid)&lt;mid) { r=mid-1; p=mid; } else l=mid+1; } pos[a[i][0]]=p; if(~p) { sum.update(p,1); ans.update(p,1); } } else if(~pos[a[i][0]])sum.update(pos[a[i][0]],-1); } for(int i=1;i&lt;=n;++i) { if(flag)ansi[i]=ans.query(i); else ansd[i]=ans.query(i); }}template&lt;typename T&gt;void read(T &amp;x){ char ch=getchar(); while(!isdigit(ch))ch=getchar(); while(isdigit(ch)) { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48); ch=getchar(); }}int main(){ read(n),read(m_1),read(m_2); for(int i=1;i&lt;=m_1;++i) { read(dom[i].a),read(dom[i].b); td[++ld]=dom[i].a; td[++ld]=dom[i].b; } for(int i=1;i&lt;=m_2;++i) { read(inter[i].a),read(inter[i].b); ti[++li]=inter[i].a; ti[++li]=inter[i].b; } sort(td+1,td+ld+1); sort(ti+1,ti+li+1); sort(dom+1,dom+m_1+1); sort(inter+1,inter+m_2+1); for(int i=1;i&lt;=m_1;++i) { dom[i].a=lower_bound(td+1,td+ld+1,dom[i].a)-td; dom[i].b=lower_bound(td+1,td+ld+1,dom[i].b)-td; posd[dom[i].a][0]=posd[dom[i].b][0]=i; posd[dom[i].a][1]=1; } for(int i=1;i&lt;=m_2;++i) { inter[i].a=lower_bound(ti+1,ti+li+1,inter[i].a)-ti; inter[i].b=lower_bound(ti+1,ti+li+1,inter[i].b)-ti; posi[inter[i].a][0]=posi[inter[i].b][0]=i; posi[inter[i].a][1]=1; } solve(posd,ld,false); solve(posi,li,true); for(int i=0;i&lt;=n;++i)ANS=max(ANS,ansd[i]+ansi[n-i]); printf(&quot;%d&quot;,ANS); return 0;}","link":"/OI/P7913/"},{"title":"【欧拉计划】13. Large sum","text":"【思路】C/C++ 应用高精度，但 Python 可直接计算。同时还可以利用整型和字符串之间的转换和子串功能求解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107a = [ 37107287533902102798797998220837590246510135740250, 46376937677490009712648124896970078050417018260538, 74324986199524741059474233309513058123726617309629, 91942213363574161572522430563301811072406154908250, 23067588207539346171171980310421047513778063246676, 89261670696623633820136378418383684178734361726757, 28112879812849979408065481931592621691275889832738, 44274228917432520321923589422876796487670272189318, 47451445736001306439091167216856844588711603153276, 70386486105843025439939619828917593665686757934951, 62176457141856560629502157223196586755079324193331, 64906352462741904929101432445813822663347944758178, 92575867718337217661963751590579239728245598838407, 58203565325359399008402633568948830189458628227828, 80181199384826282014278194139940567587151170094390, 35398664372827112653829987240784473053190104293586, 86515506006295864861532075273371959191420517255829, 71693888707715466499115593487603532921714970056938, 54370070576826684624621495650076471787294438377604, 53282654108756828443191190634694037855217779295145, 36123272525000296071075082563815656710885258350721, 45876576172410976447339110607218265236877223636045, 17423706905851860660448207621209813287860733969412, 81142660418086830619328460811191061556940512689692, 51934325451728388641918047049293215058642563049483, 62467221648435076201727918039944693004732956340691, 15732444386908125794514089057706229429197107928209, 55037687525678773091862540744969844508330393682126, 18336384825330154686196124348767681297534375946515, 80386287592878490201521685554828717201219257766954, 78182833757993103614740356856449095527097864797581, 16726320100436897842553539920931837441497806860984, 48403098129077791799088218795327364475675590848030, 87086987551392711854517078544161852424320693150332, 59959406895756536782107074926966537676326235447210, 69793950679652694742597709739166693763042633987085, 41052684708299085211399427365734116182760315001271, 65378607361501080857009149939512557028198746004375, 35829035317434717326932123578154982629742552737307, 94953759765105305946966067683156574377167401875275, 88902802571733229619176668713819931811048770190271, 25267680276078003013678680992525463401061632866526, 36270218540497705585629946580636237993140746255962, 24074486908231174977792365466257246923322810917141, 91430288197103288597806669760892938638285025333403, 34413065578016127815921815005561868836468420090470, 23053081172816430487623791969842487255036638784583, 11487696932154902810424020138335124462181441773470, 63783299490636259666498587618221225225512486764533, 67720186971698544312419572409913959008952310058822, 95548255300263520781532296796249481641953868218774, 76085327132285723110424803456124867697064507995236, 37774242535411291684276865538926205024910326572967, 23701913275725675285653248258265463092207058596522, 29798860272258331913126375147341994889534765745501, 18495701454879288984856827726077713721403798879715, 38298203783031473527721580348144513491373226651381, 34829543829199918180278916522431027392251122869539, 40957953066405232632538044100059654939159879593635, 29746152185502371307642255121183693803580388584903, 41698116222072977186158236678424689157993532961922, 62467957194401269043877107275048102390895523597457, 23189706772547915061505504953922979530901129967519, 86188088225875314529584099251203829009407770775672, 11306739708304724483816533873502340845647058077308, 82959174767140363198008187129011875491310547126581, 97623331044818386269515456334926366572897563400500, 42846280183517070527831839425882145521227251250327, 55121603546981200581762165212827652751691296897789, 32238195734329339946437501907836945765883352399886, 75506164965184775180738168837861091527357929701337, 62177842752192623401942399639168044983993173312731, 32924185707147349566916674687634660915035914677504, 99518671430235219628894890102423325116913619626622, 73267460800591547471830798392868535206946944540724, 76841822524674417161514036427982273348055556214818, 97142617910342598647204516893989422179826088076852, 87783646182799346313767754307809363333018982642090, 10848802521674670883215120185883543223812876952786, 71329612474782464538636993009049310363619763878039, 62184073572399794223406235393808339651327408011116, 66627891981488087797941876876144230030984490851411, 60661826293682836764744779239180335110989069790714, 85786944089552990653640447425576083659976645795096, 66024396409905389607120198219976047599490197230297, 64913982680032973156037120041377903785566085089252, 16730939319872750275468906903707539413042652315011, 94809377245048795150954100921645863754710598436791, 78639167021187492431995700641917969777599028300699, 15368713711936614952811305876380278410754449733078, 40789923115535562561142322423255033685442488917353, 44889911501440648020369068063960672322193204149535, 41503128880339536053299340368006977710650566631954, 81234880673210146739058568557934581403627822703280, 82616570773948327592232845941706525094512325230608, 22918802058777319719839450180888072429661980811197, 77158542502016545090413245809786882778948721859617, 72107838435069186155435662884062257473692284509516, 20849603980134001723930671666823555245252804609722, 53503534226472524250874054075591789781264330331690]s = 0for i in range(100): s += a[i]ans = str(s)[0: 10]print(ans)","link":"/projecteuler/13/"},{"title":"【欧拉计划】11. Largest product in a grid","text":"（本题取 $n=20$，$m=4$，$d=8$） 【思路】先 $O(n^2)$ 枚举起始数字，然后 $\\mathcal O(md)$ 枚举所有方向的所有数字。时间复杂度为 $\\mathcal O(n^2md)$： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;const int dx[]={-1,-1,-1,0,0,1,1,1},dy[]={-1,0,1,-1,1,-1,0,1};int ans;const int matrix[20][20]={ {8,02,22,97,38,15,00,40,00,75,04,05,07,78,52,12,50,77,91,8}, {49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48,04,56,62,00}, {81,49,31,73,55,79,14,29,93,71,40,67,53,88,30,03,49,13,36,65}, {52,70,95,23,04,60,11,42,69,24,68,56,01,32,56,71,37,02,36,91}, {22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80}, {24,47,32,60,99,03,45,02,44,75,33,53,78,36,84,20,35,17,12,50}, {32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70}, {67,26,20,68,02,62,12,20,95,63,94,39,63,8,40,91,66,49,94,21}, {24,55,58,05,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72}, {21,36,23,9,75,00,76,44,20,45,35,14,00,61,33,97,34,31,33,95}, {78,17,53,28,22,75,31,67,15,94,03,80,04,62,16,14,9,53,56,92}, {16,39,05,42,96,35,31,47,55,58,88,24,00,17,54,24,36,29,85,57}, {86,56,00,48,35,71,89,07,05,44,44,37,44,60,21,58,51,54,17,58}, {19,80,81,68,05,94,47,69,28,73,92,13,86,52,17,77,04,89,55,40}, {04,52,8,83,97,35,99,16,07,97,57,32,16,26,26,79,33,27,98,66}, {88,36,68,87,57,62,20,72,03,46,33,67,46,55,12,32,63,93,53,69}, {04,42,16,73,38,25,39,11,24,94,72,18,8,46,29,32,40,62,76,36}, {20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74,04,36,16}, {20,73,35,29,78,31,90,01,74,31,49,71,48,86,81,16,23,57,05,54}, {01,70,54,71,83,51,54,69,16,92,33,48,61,43,52,01,89,19,67,48}};int main(){ for(int i=0;i&lt;20;++i) { for(int j=0;j&lt;20;++j) { for(int k=0;k&lt;8;++k) { int mx=i+dx[k]*3,my=j+dy[k]*3,fac=matrix[i][j]; if(mx&lt;0||my&lt;0||mx&gt;=20||my&gt;=20)continue; for(int l=0,lx=i,ly=j;l&lt;3;++l) { int nx=lx+dx[k],ny=ly+dy[k]; fac*=matrix[nx][ny]; lx=nx,ly=ny; } if(fac&gt;ans)ans=fac; } } } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/11/"},{"title":"【欧拉计划】12. Highly divisible triangular number","text":"（本题取 $n$ 为第一个因数个数大于 $500$ 的三角形数 $76576500$） 【思路】依次枚举三角形数，每次 $\\mathcal O(n)$ 求所有因数，因数个数大于 $500$ 就中断。时间复杂度为 $\\mathcal O(n^2)$。 【优化】如果整数 $x$ 有因数 $i$，那么 $\\dfrac{x}{i}$ 必然也是它的因数。因此可以把统计因数个数的时间复杂度降到 $\\mathcal O(\\sqrt n)$，总体优化到 $\\mathcal O(n \\sqrt n)$： 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int fac(int x){ if(x==1)return 1; int s=2; for(int i=2;i*i&lt;=x;++i) { if(x%i==0) { ++s; if(i*i!=x)++s; } } return s;}int main(){ for(int i=1,x=1;;++i,x+=i) { if(fac(x)&gt;500) { printf(&quot;%d&quot;,x); return 0; } } return 0;}","link":"/projecteuler/12/"},{"title":"【欧拉计划】14. Longest Collatz sequence","text":"（本题取 $n=1000000$，规定 $\\text{col}_n$ 为 $n$ 的序列长度） 【思路】直接 $\\mathcal O(n \\max {\\text{col}_i})$ 求解： 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int ans,maxn;int main(){ for(int i=1;i&lt;=1000000;++i) { int x=1; long long t=i; while(t!=1) { if(t&amp;1)t=t*3+1; else t&gt;&gt;=1; ++x; } if(x&gt;maxn) { ans=i; maxn=x; } } printf(&quot;%d&quot;,ans); return 0;} 【优化】采用记忆化减小常数： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;int ans,f[1000001];int main(){ for(int i=1;i&lt;=1000000;++i) { if(!f[i]) { f[i]=1; long long t=i; int a[1001]={}; while(t!=1) { if(t&amp;1)t=t*3+1; else t&gt;&gt;=1; ++f[i]; if(t&lt;=1000000) { a[f[i]]=t; if(f[t]) { f[i]+=f[t]-1; break; } } } for(int j=2;j&lt;=f[i];++j) { if(a[j]) { f[a[j]]=f[i]-j+1; } } } if(f[i]&gt;f[ans])ans=i; } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/14/"},{"title":"【欧拉计划】16. Power digit sum","text":"【思路】Python 可简单模拟，但在 C/C++ 中需用高精度： 12345s = str(1 &lt;&lt; 1000)ans = 0for i in s: ans += int(i)print(ans)","link":"/projecteuler/16/"},{"title":"【欧拉计划】19. Counting Sundays","text":"【思路】按照题意模拟即可： 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;const int days[]={0,31,28,31,30,31,30,31,31,30,31,30,31};int ans,d=1;int main(){ for(int m=1;m&lt;=12;++m)d=(d+days[m])%7; for(int y=1901;y&lt;=2000;++y) { for(int m=1;m&lt;=12;++m) { if(!d)++ans; d=(d+days[m]+(m==2&amp;&amp;((bool)(y&amp;3)^true)))%7; } } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/19/"},{"title":"【欧拉计划】17. Number letter counts","text":"（本题取 $n=1000$） 【思路】本题细节较多，可先预处理一些数的字母个数，这样后面的数就可以由前面递推而来。时间复杂度为 $\\mathcal O(n)$。 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int ans,a[1001]={0,3,3,5,4,4,3,5,5,4,3,6,6,8,8,7,7,9,8,8};void init(){ a[20]=a[30]=6; a[40]=a[50]=a[60]=5; a[70]=7; a[80]=a[90]=6; a[1000]=11; for(int i=20;i&lt;100;++i) { if(i%10==0)continue; a[i]=a[i/10*10]+a[i%10]; }}int main(){ init(); for(int i=1;i&lt;=1000;++i) { if(a[i])ans+=a[i]; else if(i%100)ans+=a[i/100]+10+a[i%100]; else ans+=a[i/100]+7; } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/17/"},{"title":"【欧拉计划】15. Lattice paths","text":"（本题取 $n=20$） 【思路】$\\mathcal O(n^2)$ DP 即可： 123456789101112131415#include&lt;stdio.h&gt;long long f[21][21];int main(){ for(int i=0;i&lt;=20;++i)f[0][i]=f[i][0]=1; for(int i=1;i&lt;=20;++i) { for(int j=1;j&lt;=20;++j) { f[i][j]=f[i][j-1]+f[i-1][j]; } } printf(&quot;%lld&quot;,f[20][20]); return 0;}","link":"/projecteuler/15/"},{"title":"【欧拉计划】18. Maximum path sum I","text":"（本题取 $n=16$） 【思路】暴力 DFS，时间复杂度为 $\\mathcal O(2^n)$。 【优化】采用 $\\mathcal O(n^2)$ 的 DP： 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;int dp[16][16],ans;int max(int a,int b){return a&gt;b?a:b;}const int matrix[16][16]={ {0}, {0,75}, {0,95,64}, {0,17,47,82}, {0,18,35,87,10}, {0,20,04,82,47,65}, {0,19,01,23,75,03,34}, {0,88,02,77,73,07,63,67}, {0,99,65,04,28,06,16,70,92}, {0,41,41,26,56,83,40,80,70,33}, {0,41,48,72,33,47,32,37,16,94,29}, {0,53,71,44,65,25,43,91,52,97,51,14}, {0,70,11,33,28,77,73,17,78,39,68,17,57}, {0,91,71,52,38,17,14,91,43,58,50,27,29,48}, {0,63,66,04,68,89,53,67,30,73,16,69,87,40,31}, {0,04,62,98,27,23,9,70,98,73,93,38,53,60,04,23}};int main(){ for(int i=1;i&lt;=15;++i) { for(int j=1;j&lt;=i;++j) { dp[i][j]=max(dp[i-1][j-1],dp[i-1][j])+matrix[i][j]; } } for(int i=1;i&lt;=15;++i)ans=max(ans,dp[15][i]); printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/18/"},{"title":"【欧拉计划】21. Amicable numbers","text":"（本题取 $n=10000$） 【思路】先 $\\mathcal O(n)$ 预处理 $1 \\sim 10000$ 因数个数，然后 $\\mathcal O(n)$ 枚举，总体时间复杂度仍为 $\\mathcal O(n)$： 123456789101112131415161718192021#include&lt;stdio.h&gt;int ans,d[10001];int main(){ for(int i=1;i&lt;=10000;++i) { for(int j=i&lt;&lt;1;j&lt;=10000;j+=i) { d[j]+=i; } } for(int i=1;i&lt;=10000;++i) { if(d[i]&lt;=10000&amp;&amp;d[d[i]]==i&amp;&amp;d[i]!=i) { ans+=i; } } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/21/"},{"title":"【欧拉计划】2. Even Fibonacci numbers","text":"（本题取 $n=\\lfloor \\text{fib}^{-1}(4000000) \\rfloor=33$） 【思路】运用斐波那契数列递推公式 $a_i=a_{i-1}+a_{i-2}$ 进行递推，超过 $4000000$ 就中断。最后统计其中偶数的和即可。时空复杂度均为 $\\mathcal O(n)$。 【优化 $1$】采用滚动变量，将空间复杂度优化到 $\\mathcal O(1)$： 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int last,now,ans;int main(){ last=now=1; while(true) { int t=last; last=now; now+=t; if(now&gt;4000000)break; if(now%2==0)ans+=now; } printf(&quot;%d&quot;,ans); return 0;} 【优化 $2$】采用矩阵乘法，构造初始矩阵为： $$\\begin{bmatrix}1 &amp; 1 \\cr0 &amp; 0 \\cr\\end{bmatrix}$$ 每次需要乘上的矩阵为： $$\\begin{bmatrix}1 &amp; 1 \\cr1 &amp; 0 \\cr\\end{bmatrix}$$ 这样不停地累乘，只要矩阵第 $1$ 行第 $1$ 列的元素（即数列的值）超过 $4000000$，就直接中断： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;int ans;struct matrix{ long long a[3][3]; matrix operator*(const matrix &amp;x)const { matrix res; memset(res.a,0,sizeof(res.a)); for(int k=1;k&lt;=2;++k) { for(int i=1;i&lt;=2;++i) { for(int j=1;j&lt;=2;++j) { res.a[i][j]+=a[i][k]*x.a[k][j]; } } } return res; }}m,base;int main(){ m.a[1][1]=m.a[1][2]=1; base.a[1][1]=base.a[1][2]=base.a[2][1]=1; while(m.a[1][1]&lt;=4000000) { if(m.a[1][1]%2==0)ans+=m.a[1][1]; m=m*base; } printf(&quot;%d&quot;,ans); return 0;} 做一次矩阵乘法的时间复杂度为 $\\mathcal O(1)$，需要做 $n$ 次，因此时间复杂度仍为 $\\mathcal O(n)$。矩阵的大小为常数，因此空间复杂度为 $\\mathcal O(1)$。 由于没有要求具体求出数列中一个元素的值，因此矩阵并没有真正起到优化作用。","link":"/projecteuler/2/"},{"title":"【欧拉计划】20. Factorial digit sum","text":"【思路】Python 模拟 / C/C++ 高精度： 123456import maths = str(math.factorial(100))ans = 0for i in s: ans += int(i)print(ans)","link":"/projecteuler/20/"},{"title":"【欧拉计划】22. Names scores","text":"【思路】从文件读入所有名字，然后模拟。难点在于读入的方法。当然也可以另编写一个程序，将所有名字每几个就换一次行，然后把表存在最终程序里（详见 Problem 42）： 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;string s[6001],t;int n,ans;bool read(string &amp;s){ char ch=getchar(); if(ch==EOF)return false; while(ch&lt;'A'||ch&gt;'Z') { ch=getchar(); if(ch==EOF)return false; } s=ch; while(true) { ch=getchar(); if(ch&lt;'A'||ch&gt;'Z')break; s+=ch; } return true;}int main(){ freopen(&quot;p022_names.txt&quot;,&quot;r&quot;,stdin); while(read(t))s[++n]=t; sort(s+1,s+n+1); for(int i=1;i&lt;=n;++i) { int x=0; for(int j=0;s[i][j];++j)x+=s[i][j]-'A'+1; ans+=x*i; } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/22/"},{"title":"【欧拉计划】24. Lexicographic permutations","text":"（本题取 $n=10$） 【思路】$\\mathcal O(n!)$ 枚举所有排列情况，可用 DFS 实现或直接调用函数 next_permutation： 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;int a[10],cnt;bool b[10];void dfs(int k){ if(k&gt;9) { if(++cnt==1000000) { for(int i=0;i&lt;10;++i)printf(&quot;%d&quot;,a[i]); exit(0); } return; } for(int i=0;i&lt;10;++i) { if(b[i])continue; a[k]=i; b[i]=true; dfs(k+1); b[i]=false; }}int main(){ dfs(0); return 0;} 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int cnt,a[10];int main(){ for(int i=0;i&lt;=9;++i)a[i]=i; while(next_permutation(a,a+10)&amp;&amp;++cnt&lt;999999); for(int i=0;i&lt;=9;++i)printf(&quot;%d&quot;,a[i]); return 0;}","link":"/projecteuler/24/"},{"title":"【欧拉计划】23. Non-abundant sums","text":"（本题取 $n=28123$） 【思路】$\\mathcal O(n \\sqrt n)$ 预处理因数个数（用 Problem 21 的思路可优化至 $\\mathcal O(n)$），然后 $\\mathcal O(n^2)$ 模拟。最终的时间复杂度都为 $\\mathcal O(n^2)$： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int ans;bool a[30001];int fac(int x){ if(x==1)return 1; int s=1; for(int i=2;i*i&lt;=x;++i) { if(x%i==0) { s+=i; if(i*i!=x)s+=x/i; } } return s;}int main(){ for(int i=1;i&lt;=28123;++i)a[i]=fac(i)&gt;i; for(int i=1;i&lt;=28123;++i) { bool flag=false; for(int j=1;j&lt;=i&gt;&gt;1;++j) { if(a[j]&amp;a[i-j]) { flag=true; break; } } if(!flag)ans+=i; } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/23/"},{"title":"【欧拉计划】25. 1000-digit Fibonacci number","text":"【思路】采用 Problem 2 中滚动数组的方法，再使用 Python 模拟 / C/C++ 高精度： 123456789import sysa = b = 1ans = 2while True: a, b = b, a + b ans += 1 if len(str(b)) == 1000: print(ans) sys.exit()","link":"/projecteuler/25/"},{"title":"【欧拉计划】26. Reciprocal cycles","text":"【思路】这题的关键就是如何得到循环节。试想，当我们把一个单位分数扩大 $10$ 的若干次幂之后，得到的数的整数部分会出现循环。 因此，我们可以重复地将一个初始值为 $1$ 的数对单位分数的分母取模，然后乘上 $10$。 每操作一次，就检查这个数是否已经出现过。如果出现过，就说明已经找到循环节；否则标记并继续操作： 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;int ans,maxn;bool vis[10001];int main(){ for(int i=3;i&lt;1000;i+=2) { int r=1,cur=0; memset(vis,false,sizeof(vis)); while(!vis[r]) { vis[r]=true; r=r%i*10; ++cur; } if(cur&gt;maxn) { ans=i; maxn=cur; } } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/26/"},{"title":"【欧拉计划】28. Number spiral diagonals","text":"（本题取 $n=1000$） 【思路】首先可以发现 $1$ 位于矩阵正中央，即 $(501,501)$ 处。 通过找规律可以发现，每走一步需要顺时针变换一次方向，但是如果已经走过或越界则需再次变换。这样，我们就可以遍历整个矩阵，从而在 $\\mathcal O(n^2)$ 的效率下求出对角线的元素之和： 123456789101112131415161718192021#include&lt;stdio.h&gt;int x=501,y=501,cnt,d=-1,ans,a[1005][1005];const int dx[]={0,1,0,-1},dy[]={1,0,-1,0};int main(){ while(cnt&lt;=1002001) { a[x][y]=++cnt; d=(d+1)%4; int nx=x+dx[d],ny=y+dy[d]; if(nx&lt;1||ny&lt;1||nx&gt;1001||ny&gt;1001||a[nx][ny]) { d=(d+3)%4; x+=dx[d],y+=dy[d]; } else x=nx,y=ny; } for(int i=1;i&lt;=1001;++i)ans+=a[i][i]+a[i][1002-i]; printf(&quot;%d&quot;,ans-1); return 0;}","link":"/projecteuler/28/"},{"title":"【欧拉计划】27. Quadratic primes","text":"（本题取 $n=1000$） 【思路】由于范围不大，因而可以直接 $\\mathcal O(n^2)$ 枚举，然后套上质数的判断即可。由于待判断的数大小不确定，因而用质数判断函数来代替欧拉筛： 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int maxn,ans;bool prime(int x){ if(x&lt;2)return false; if(x==2||x==3||x==5)return true; if(x%2==0||x%3==0||x%5==0)return false; for(int a=7,b=11;a*a&lt;=x;a+=6,b+=6)if(x%a==0||x%b==0)return false; return true;}int main(){ for(int a=-999;a&lt;=999;++a) { for(int b=-1000;b&lt;=1000;++b) { int n=0; while(prime(n*n+a*n+b))++n; if(n&gt;maxn) { maxn=n; ans=a*b; } } } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/27/"},{"title":"【欧拉计划】29. Distinct powers","text":"（本题取 $n=100$） 【思路】考虑构造一个元素不可重的集合，通过 $\\mathcal O(n^2)$ 的二维循环枚举所有乘方的结果，最后统计集合内元素个数： 12345a = []for i in range(2, 101): for j in range(2, 101): a.append(i ** j)print(len(list(set(a))))","link":"/projecteuler/29/"},{"title":"【欧拉计划】3. Largest prime factor","text":"（本题取 $n=600851475143$） 【思路】在区间 $[2,n]$ 内倒序枚举 $n$ 的所有质因数，输出第一个遍历到的。时空复杂度分别为 $\\mathcal O(n \\sqrt n)$，$\\mathcal O(1)$。 【优化 $1$】在原思路的基础上使用埃氏筛，时间复杂度优化为 $\\mathcal O(n \\ln \\ln n+n)$；使用欧拉筛可优化为 $\\mathcal O(n)$。 【优化 $2$】在原思路的基础上将区间缩小为 $[2,\\sqrt n]$，时间复杂度优化为 $\\mathcal O(n)$。 【优化 $3$】结合优化 $1,2$，时间复杂度可进一步优化至 $\\mathcal O(\\sqrt n)$（后面研究质数时不再提及质数判断法或埃氏筛，一律只保留欧拉筛）。 【优化 $4$】在【优化 $3$】的基础上，将循环改为正序。这样能减小时间复杂度的常数，同时将空间复杂度降为 $\\mathcal O(1)$： 12345678910111213141516171819#include&lt;stdio.h&gt;long long n=600851475143;int main(){ for(long long i=3;i*i&lt;=n;i+=2) { while(n%i==0) { n/=i; if(n==1) { printf(&quot;%lld&quot;,i); return 0; } } } printf(&quot;%lld&quot;,n); return 0;}","link":"/projecteuler/3/"},{"title":"【欧拉计划】30. Digit fifth powers","text":"【思路】从二位数开始枚举，直到到达一个较大的预先设置好的上界，在枚举时暴力判断是否符合题意即可： 123456789101112131415161718#include&lt;stdio.h&gt;int ans;int pow5(int x){return x*x*x*x*x;}int main(){ for(int i=11;i&lt;=500000;++i) { int j=i,t=0; while(j) { t+=pow5(j%10); j/=10; } if(i==t)ans+=i; } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/30/"},{"title":"【欧拉计划】31. Coin sums","text":"（本题取 $n=200$，$m=8$） 【思路】通过观察不难发现本题考察的是 DP。 如果我们用 $dp_{i,j}$ 表示使用 $j$ 种不同面额凑出 $i$ 分钱的方案个数，那么显然有初始状态： $$dp_{0,1}=1$$ 由于本题数据范围不大，我们可以暴力递推，从而覆盖所有情况。用 $val_i$ 表示第 $i$ 种货币的面额，则有： $$dp_{i,j}=\\sum_{i=1}^n \\sum_{j=1}^m \\sum_{k=1}^j dp_{i-val_j,k}$$ 这样我们便得到了一个 $\\mathcal O(nm^2)$ 的做法： 1234567891011121314151617181920#include&lt;stdio.h&gt;const int value[]={0,1,2,5,10,20,50,100,200};int dp[201][10],ans;int main(){ dp[0][1]=1; for(int i=1;i&lt;=200;++i) { for(int j=1;value[j]&lt;=i;++j) { for(int k=1;k&lt;=j;++k) { dp[i][j]+=dp[i-value[j]][k]; } } } for(int i=1;i&lt;10;++i)ans+=dp[200][i]; printf(&quot;%d&quot;,ans); return 0;} 【优化】我们可以采用完全背包进行优化。 不妨用 $dp_j$ 表示能够凑出 $j$ 分钱的方案总数，则初始状态为： $$dp_0=1$$ 接着我们使用完全背包的递推方式： $$dp_j=\\sum_{i=1}^m \\sum_{j=val_i}^n dp_{j-val_i}$$ 这样我们可以将时间复杂度优化到 $\\mathcal O(nm)$，空间复杂度优化到 $\\mathcal O(n)$： 12345678910111213141516#include&lt;stdio.h&gt;const int value[]={0,1,2,5,10,20,50,100,200};int dp[201],ans;int main(){ dp[0]=1; for(int i=1;i&lt;=8;++i) { for(int j=value[i];j&lt;=200;++j) { dp[j]+=dp[j-value[i]]; } } printf(&quot;%d&quot;,dp[200]); return 0;}","link":"/projecteuler/31/"},{"title":"【欧拉计划】32. Pandigital products","text":"（本题取 $n=9$） 【思路】我们可以 $\\mathcal O(n!)$ 获得 $1 \\sim 9$ 的排列，然后在排列组成的九位数中插两个空——其中一个位于两个乘数之间（相当于乘号），另一个位于左式和右式之间（相当于等号）。最后我们检查一下等式是否正确，正确就累加进入答案： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int ans,a[10];bool vis[10],flag[10000];void dfs(int k){ if(k&gt;9) { for(int i=1;i&lt;=2;++i) { int m1=0; for(int j=1;j&lt;=i;++j)m1=m1*10+a[j]; for(int j=i;j&lt;=5-i;++j) { int m2=0,p=0; for(int k=i+1;k&lt;=i+j;++k)m2=m2*10+a[k]; for(int k=i+j+1;k&lt;=9;++k)p=p*10+a[k]; if(m1*m2==p&amp;&amp;!flag[p]) { flag[p]=true; ans+=p; } } } return; } for(int i=1;i&lt;=9;++i) { if(vis[i])continue; a[k]=i; vis[i]=true; dfs(k+1); vis[i]=false; }}int main(){ dfs(1); printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/32/"},{"title":"【欧拉计划】33. Digit cancelling fractions","text":"（本题取 $n=9$） 【思路】题目描述得有些模糊，要求我们找到两个十位数 $a,b$（$a \\lt b$），使得 $a$ 的十位数和 $b$ 的个位数相等，同时使得 $\\dfrac{a}{b}$ 与 $a,b$ 分别删去相同位数之后的商相等。 由于有两个数位相等，因此我们只需要枚举三个数位，这样就可以在 $\\mathcal O(n^3)$ 枚举出所有的情况。约分需要用到 $\\gcd$，因此最终时间复杂度为 $\\mathcal O(n^3 \\log n)$： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;struct fraction{ int n,d;}ans;int gcd(int a,int b){ while(b) { int t=b; b=a%b; a=t; } return a;}int main(){ ans.n=ans.d=1; for(int i=1;i&lt;=9;++i) { for(int j=i+1;j&lt;=9;++j) { for(int k=i+1;k&lt;=9;++k) { int n=i*10+j,d=j*10+k; if(n*k==d*i) { ans.n*=n; ans.d*=d; } } } } printf(&quot;%d&quot;,ans.d/gcd(ans.n,ans.d)); return 0;}","link":"/projecteuler/33/"},{"title":"【欧拉计划】34. Digit factorials","text":"（本题取 $n=9$） 【思路】我们可以储存 $0 \\sim 9$ 的所有阶乘的值，然后在 $[10,9!]$ 内枚举所有的数并检验即可。枚举的时间复杂度为 $\\mathcal O(n!)$： 123456789101112131415161718#include&lt;stdio.h&gt;const int fac[]={1,1,2,6,24,120,720,5040,40320,362880};int ans;int main(){ for(int i=10;i&lt;=362880;++i) { int j=i,s=0; while(j) { s+=fac[j%10]; j/=10; } if(s==i)ans+=i; } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/34/"},{"title":"【欧拉计划】35. Circular primes","text":"（本题取 $n=1000000$） 【思路】先 $\\mathcal O(n)$ 欧拉筛，然后暴力枚举所有在范围内的质数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;stdbool.h&gt;const int maxn=1000000;int ans,a[7],prime[maxn];bool vis[maxn];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } }}int main(){ euler(); for(int i=1;i&lt;=prime[0];++i) { int x=prime[i],y=x,n=log10(x)+1; bool f=true; for(int j=1;j&lt;=n;++j) { a[n-j+1]=y%10; y/=10; } for(int j=2;j&lt;=n;++j) { int z=0; for(int k=1;k&lt;=n;++k) { int pos=j+k-1; if(pos&gt;n)pos-=n; z=z*10+a[pos]; } if(vis[z]) { f=false; break; } } ans+=f; } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/35/"},{"title":"【欧拉计划】39. Integer right triangles","text":"（本题取 $n=1000$） 【思路】最外层枚举 $p$ 的值，里面两层枚举 $a,b$，从而计算得到是否有符合的 $c$。时间复杂度为 $\\mathcal O(n^3)$： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int maxp,maxn;int main(){ for(int p=12;p&lt;=1000;++p) { int s=0; for(int a=3;a&lt;=p/3;++a) { for(int b=a+1;b&lt;=p;++b) { int c=p-a-b; if(a*a+b*b==c*c&amp;&amp;c&gt;b)++s; } } if(s&gt;maxn) { maxn=s; maxp=p; } } printf(&quot;%d&quot;,maxp); return 0;}","link":"/projecteuler/39/"},{"title":"【欧拉计划】36. Double-base palindromes","text":"（本题取 $n=1000000$） 【思路】我们可以 $\\mathcal O(n)$ 枚举所有在范围的整数，然后每次 $\\mathcal O(\\log n)$ 进行数位的处理和检查。总体时间复杂度为 $\\mathcal O(n \\log n)$： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int ans,d[7],b[21];int main(){ for(int i=1;i&lt;1000000;++i) { int j=i,cd=0,cb=0; bool flag=true; while(j) { d[++cd]=j%10; j/=10; } for(int k=1;k&lt;=cd&gt;&gt;1;++k) { if(d[k]!=d[cd-k+1]) { flag=false; break; } } if(!flag)continue; j=i; while(j) { b[++cb]=j&amp;1; j&gt;&gt;=1; } for(int k=1;k&lt;=cb&gt;&gt;1;++k) { if(b[k]!=b[cb-k+1]) { flag=false; break; } } if(flag)ans+=i; } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/36/"},{"title":"【欧拉计划】37. Truncatable primes","text":"（本题取 $n=1000000$） 【思路】$\\mathcal O(n)$ 欧拉筛，然后枚举所有在范围内质数并检查是否符合题意。程序的时间复杂度为 $\\mathcal O(n \\log_{10} n)$： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;math.h&gt;const int maxn=1000000;const int pow10[]={1,10,100,1000,10000,100000,1000000};int ans,prime[maxn];bool vis[maxn];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } }}int main(){ euler(); for(int i=5;i&lt;=prime[0];++i) { int x=prime[i],y=x; if(vis[x])continue; bool flag=true; while(true) { y/=10; if(!y)break; if(vis[y]) { flag=false; break; } } y=x; while(y) { if(y&lt;10)break; y%=pow10[int(log10(y))]; if(vis[y]) { flag=false; break; } } if(flag)ans+=x; } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/37/"},{"title":"【欧拉计划】4. Largest palindrome product","text":"（本题取 $d=10$，$n=1000-100=900$） 【思路】显然满足要求的最大回文数一定为六位数。因此我们只需要三重循环枚举前三位，然后通过回文数性质得到后三位，从而得到一个六位数。最后枚举是否能表示成两个三位数乘积即可。时间复杂度为 $\\mathcal O(d^3n)$： 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int main(){ for(int i=9;i;--i) { for(int j=9;j&gt;=0;--j) { for(int k=9;k&gt;=0;--k) { int x=i*100000+j*10000+k*1000+k*100+j*10+i; for(int p=100;p&lt;=999;++p) { if(x%p)continue; int q=x/p; if(q&gt;=100&amp;&amp;q&lt;1000) { printf(&quot;%d&quot;,x); return 0; } } } } } return 0;}","link":"/projecteuler/4/"},{"title":"【欧拉计划】40. Champernowne&#39;s constant","text":"【思路】由于一个整数 $x$ 的数位个数等于 $\\log_{10} x+1$，因而我们可以不停累加，到了所需的值就进行计算： 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;math.h&gt;const int a[]={1,10,100,1000,10000,100000,1000000};int cnt,ans=1;int main(){ for(int i=1,x=0;x&lt;=1000000;++i) { int len=log10(i)+1,j=i; x+=len; if(x&gt;=a[cnt]) { for(int k=0;k&lt;x-a[cnt];++k)j/=10; ans*=j%10; ++cnt; } } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/40/"},{"title":"【欧拉计划】38. Pandigital multiples","text":"【思路】暴力倒序枚举 $10000$ 以内的整数并检查： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int main(){ for(int i=9999;i;--i) { for(int j=2;;++j) { int a[10]={},b[10]={}; for(int k=1;k&lt;=j;++k) { int x=i*k; b[k]=x; while(x) { ++a[x%10]; x/=10; } } bool flag=true; int cnt=a[0]; for(int k=1;k&lt;10;++k) { cnt+=a[k]; if(a[k]!=1)flag=false; } if(cnt&gt;9)break; if(flag) { for(int k=1;k&lt;=j;++k)printf(&quot;%d&quot;,b[k]); return 0; } } } return 0;}","link":"/projecteuler/38/"},{"title":"【欧拉计划】42. Coded triangle numbers","text":"（取 $n$ 为单词数量，$m$ 为所有单词对应数值的最大值） 【思路】我们在 Problem 22 中使用了文件输入索引，同时对其进行操作。这次我们直接将索引每十个元素空一行，并存放于数组中。 接着我们只需要枚举每个单词并判断它所对应的数值是否为三角形数即可。 判断是否为三角形数可以采用二分法，单次时间复杂度为 $\\mathcal O(\\log \\sqrt m)$ 总体时间复杂度为 $\\mathcal O(n \\log \\sqrt m)$： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int ans;const char *s[]={ &quot;A&quot;,&quot;ABILITY&quot;,&quot;ABLE&quot;,&quot;ABOUT&quot;,&quot;ABOVE&quot;,&quot;ABSENCE&quot;,&quot;ABSOLUTELY&quot;,&quot;ACADEMIC&quot;,&quot;ACCEPT&quot;,&quot;ACCESS&quot;, &quot;ACCIDENT&quot;,&quot;ACCOMPANY&quot;,&quot;ACCORDING&quot;,&quot;ACCOUNT&quot;,&quot;ACHIEVE&quot;,&quot;ACHIEVEMENT&quot;,&quot;ACID&quot;,&quot;ACQUIRE&quot;,&quot;ACROSS&quot;,&quot;ACT&quot;, &quot;ACTION&quot;,&quot;ACTIVE&quot;,&quot;ACTIVITY&quot;,&quot;ACTUAL&quot;,&quot;ACTUALLY&quot;,&quot;ADD&quot;,&quot;ADDITION&quot;,&quot;ADDITIONAL&quot;,&quot;ADDRESS&quot;,&quot;ADMINISTRATION&quot;, &quot;ADMIT&quot;,&quot;ADOPT&quot;,&quot;ADULT&quot;,&quot;ADVANCE&quot;,&quot;ADVANTAGE&quot;,&quot;ADVICE&quot;,&quot;ADVISE&quot;,&quot;AFFAIR&quot;,&quot;AFFECT&quot;,&quot;AFFORD&quot;, &quot;AFRAID&quot;,&quot;AFTER&quot;,&quot;AFTERNOON&quot;,&quot;AFTERWARDS&quot;,&quot;AGAIN&quot;,&quot;AGAINST&quot;,&quot;AGE&quot;,&quot;AGENCY&quot;,&quot;AGENT&quot;,&quot;AGO&quot;, &quot;AGREE&quot;,&quot;AGREEMENT&quot;,&quot;AHEAD&quot;,&quot;AID&quot;,&quot;AIM&quot;,&quot;AIR&quot;,&quot;AIRCRAFT&quot;,&quot;ALL&quot;,&quot;ALLOW&quot;,&quot;ALMOST&quot;, &quot;ALONE&quot;,&quot;ALONG&quot;,&quot;ALREADY&quot;,&quot;ALRIGHT&quot;,&quot;ALSO&quot;,&quot;ALTERNATIVE&quot;,&quot;ALTHOUGH&quot;,&quot;ALWAYS&quot;,&quot;AMONG&quot;,&quot;AMONGST&quot;, &quot;AMOUNT&quot;,&quot;AN&quot;,&quot;ANALYSIS&quot;,&quot;ANCIENT&quot;,&quot;AND&quot;,&quot;ANIMAL&quot;,&quot;ANNOUNCE&quot;,&quot;ANNUAL&quot;,&quot;ANOTHER&quot;,&quot;ANSWER&quot;, &quot;ANY&quot;,&quot;ANYBODY&quot;,&quot;ANYONE&quot;,&quot;ANYTHING&quot;,&quot;ANYWAY&quot;,&quot;APART&quot;,&quot;APPARENT&quot;,&quot;APPARENTLY&quot;,&quot;APPEAL&quot;,&quot;APPEAR&quot;, &quot;APPEARANCE&quot;,&quot;APPLICATION&quot;,&quot;APPLY&quot;,&quot;APPOINT&quot;,&quot;APPOINTMENT&quot;,&quot;APPROACH&quot;,&quot;APPROPRIATE&quot;,&quot;APPROVE&quot;,&quot;AREA&quot;,&quot;ARGUE&quot;, &quot;ARGUMENT&quot;,&quot;ARISE&quot;,&quot;ARM&quot;,&quot;ARMY&quot;,&quot;AROUND&quot;,&quot;ARRANGE&quot;,&quot;ARRANGEMENT&quot;,&quot;ARRIVE&quot;,&quot;ART&quot;,&quot;ARTICLE&quot;, &quot;ARTIST&quot;,&quot;AS&quot;,&quot;ASK&quot;,&quot;ASPECT&quot;,&quot;ASSEMBLY&quot;,&quot;ASSESS&quot;,&quot;ASSESSMENT&quot;,&quot;ASSET&quot;,&quot;ASSOCIATE&quot;,&quot;ASSOCIATION&quot;, &quot;ASSUME&quot;,&quot;ASSUMPTION&quot;,&quot;AT&quot;,&quot;ATMOSPHERE&quot;,&quot;ATTACH&quot;,&quot;ATTACK&quot;,&quot;ATTEMPT&quot;,&quot;ATTEND&quot;,&quot;ATTENTION&quot;,&quot;ATTITUDE&quot;, &quot;ATTRACT&quot;,&quot;ATTRACTIVE&quot;,&quot;AUDIENCE&quot;,&quot;AUTHOR&quot;,&quot;AUTHORITY&quot;,&quot;AVAILABLE&quot;,&quot;AVERAGE&quot;,&quot;AVOID&quot;,&quot;AWARD&quot;,&quot;AWARE&quot;, &quot;AWAY&quot;,&quot;AYE&quot;,&quot;BABY&quot;,&quot;BACK&quot;,&quot;BACKGROUND&quot;,&quot;BAD&quot;,&quot;BAG&quot;,&quot;BALANCE&quot;,&quot;BALL&quot;,&quot;BAND&quot;, &quot;BANK&quot;,&quot;BAR&quot;,&quot;BASE&quot;,&quot;BASIC&quot;,&quot;BASIS&quot;,&quot;BATTLE&quot;,&quot;BE&quot;,&quot;BEAR&quot;,&quot;BEAT&quot;,&quot;BEAUTIFUL&quot;, &quot;BECAUSE&quot;,&quot;BECOME&quot;,&quot;BED&quot;,&quot;BEDROOM&quot;,&quot;BEFORE&quot;,&quot;BEGIN&quot;,&quot;BEGINNING&quot;,&quot;BEHAVIOUR&quot;,&quot;BEHIND&quot;,&quot;BELIEF&quot;, &quot;BELIEVE&quot;,&quot;BELONG&quot;,&quot;BELOW&quot;,&quot;BENEATH&quot;,&quot;BENEFIT&quot;,&quot;BESIDE&quot;,&quot;BEST&quot;,&quot;BETTER&quot;,&quot;BETWEEN&quot;,&quot;BEYOND&quot;, &quot;BIG&quot;,&quot;BILL&quot;,&quot;BIND&quot;,&quot;BIRD&quot;,&quot;BIRTH&quot;,&quot;BIT&quot;,&quot;BLACK&quot;,&quot;BLOCK&quot;,&quot;BLOOD&quot;,&quot;BLOODY&quot;, &quot;BLOW&quot;,&quot;BLUE&quot;,&quot;BOARD&quot;,&quot;BOAT&quot;,&quot;BODY&quot;,&quot;BONE&quot;,&quot;BOOK&quot;,&quot;BORDER&quot;,&quot;BOTH&quot;,&quot;BOTTLE&quot;, &quot;BOTTOM&quot;,&quot;BOX&quot;,&quot;BOY&quot;,&quot;BRAIN&quot;,&quot;BRANCH&quot;,&quot;BREAK&quot;,&quot;BREATH&quot;,&quot;BRIDGE&quot;,&quot;BRIEF&quot;,&quot;BRIGHT&quot;, &quot;BRING&quot;,&quot;BROAD&quot;,&quot;BROTHER&quot;,&quot;BUDGET&quot;,&quot;BUILD&quot;,&quot;BUILDING&quot;,&quot;BURN&quot;,&quot;BUS&quot;,&quot;BUSINESS&quot;,&quot;BUSY&quot;, &quot;BUT&quot;,&quot;BUY&quot;,&quot;BY&quot;,&quot;CABINET&quot;,&quot;CALL&quot;,&quot;CAMPAIGN&quot;,&quot;CAN&quot;,&quot;CANDIDATE&quot;,&quot;CAPABLE&quot;,&quot;CAPACITY&quot;, &quot;CAPITAL&quot;,&quot;CAR&quot;,&quot;CARD&quot;,&quot;CARE&quot;,&quot;CAREER&quot;,&quot;CAREFUL&quot;,&quot;CAREFULLY&quot;,&quot;CARRY&quot;,&quot;CASE&quot;,&quot;CASH&quot;, &quot;CAT&quot;,&quot;CATCH&quot;,&quot;CATEGORY&quot;,&quot;CAUSE&quot;,&quot;CELL&quot;,&quot;CENTRAL&quot;,&quot;CENTRE&quot;,&quot;CENTURY&quot;,&quot;CERTAIN&quot;,&quot;CERTAINLY&quot;, &quot;CHAIN&quot;,&quot;CHAIR&quot;,&quot;CHAIRMAN&quot;,&quot;CHALLENGE&quot;,&quot;CHANCE&quot;,&quot;CHANGE&quot;,&quot;CHANNEL&quot;,&quot;CHAPTER&quot;,&quot;CHARACTER&quot;,&quot;CHARACTERISTIC&quot;, &quot;CHARGE&quot;,&quot;CHEAP&quot;,&quot;CHECK&quot;,&quot;CHEMICAL&quot;,&quot;CHIEF&quot;,&quot;CHILD&quot;,&quot;CHOICE&quot;,&quot;CHOOSE&quot;,&quot;CHURCH&quot;,&quot;CIRCLE&quot;, &quot;CIRCUMSTANCE&quot;,&quot;CITIZEN&quot;,&quot;CITY&quot;,&quot;CIVIL&quot;,&quot;CLAIM&quot;,&quot;CLASS&quot;,&quot;CLEAN&quot;,&quot;CLEAR&quot;,&quot;CLEARLY&quot;,&quot;CLIENT&quot;, &quot;CLIMB&quot;,&quot;CLOSE&quot;,&quot;CLOSELY&quot;,&quot;CLOTHES&quot;,&quot;CLUB&quot;,&quot;COAL&quot;,&quot;CODE&quot;,&quot;COFFEE&quot;,&quot;COLD&quot;,&quot;COLLEAGUE&quot;, &quot;COLLECT&quot;,&quot;COLLECTION&quot;,&quot;COLLEGE&quot;,&quot;COLOUR&quot;,&quot;COMBINATION&quot;,&quot;COMBINE&quot;,&quot;COME&quot;,&quot;COMMENT&quot;,&quot;COMMERCIAL&quot;,&quot;COMMISSION&quot;, &quot;COMMIT&quot;,&quot;COMMITMENT&quot;,&quot;COMMITTEE&quot;,&quot;COMMON&quot;,&quot;COMMUNICATION&quot;,&quot;COMMUNITY&quot;,&quot;COMPANY&quot;,&quot;COMPARE&quot;,&quot;COMPARISON&quot;,&quot;COMPETITION&quot;, &quot;COMPLETE&quot;,&quot;COMPLETELY&quot;,&quot;COMPLEX&quot;,&quot;COMPONENT&quot;,&quot;COMPUTER&quot;,&quot;CONCENTRATE&quot;,&quot;CONCENTRATION&quot;,&quot;CONCEPT&quot;,&quot;CONCERN&quot;,&quot;CONCERNED&quot;, &quot;CONCLUDE&quot;,&quot;CONCLUSION&quot;,&quot;CONDITION&quot;,&quot;CONDUCT&quot;,&quot;CONFERENCE&quot;,&quot;CONFIDENCE&quot;,&quot;CONFIRM&quot;,&quot;CONFLICT&quot;,&quot;CONGRESS&quot;,&quot;CONNECT&quot;, &quot;CONNECTION&quot;,&quot;CONSEQUENCE&quot;,&quot;CONSERVATIVE&quot;,&quot;CONSIDER&quot;,&quot;CONSIDERABLE&quot;,&quot;CONSIDERATION&quot;,&quot;CONSIST&quot;,&quot;CONSTANT&quot;,&quot;CONSTRUCTION&quot;,&quot;CONSUMER&quot;, &quot;CONTACT&quot;,&quot;CONTAIN&quot;,&quot;CONTENT&quot;,&quot;CONTEXT&quot;,&quot;CONTINUE&quot;,&quot;CONTRACT&quot;,&quot;CONTRAST&quot;,&quot;CONTRIBUTE&quot;,&quot;CONTRIBUTION&quot;,&quot;CONTROL&quot;, &quot;CONVENTION&quot;,&quot;CONVERSATION&quot;,&quot;COPY&quot;,&quot;CORNER&quot;,&quot;CORPORATE&quot;,&quot;CORRECT&quot;,&quot;COS&quot;,&quot;COST&quot;,&quot;COULD&quot;,&quot;COUNCIL&quot;, &quot;COUNT&quot;,&quot;COUNTRY&quot;,&quot;COUNTY&quot;,&quot;COUPLE&quot;,&quot;COURSE&quot;,&quot;COURT&quot;,&quot;COVER&quot;,&quot;CREATE&quot;,&quot;CREATION&quot;,&quot;CREDIT&quot;, &quot;CRIME&quot;,&quot;CRIMINAL&quot;,&quot;CRISIS&quot;,&quot;CRITERION&quot;,&quot;CRITICAL&quot;,&quot;CRITICISM&quot;,&quot;CROSS&quot;,&quot;CROWD&quot;,&quot;CRY&quot;,&quot;CULTURAL&quot;, &quot;CULTURE&quot;,&quot;CUP&quot;,&quot;CURRENT&quot;,&quot;CURRENTLY&quot;,&quot;CURRICULUM&quot;,&quot;CUSTOMER&quot;,&quot;CUT&quot;,&quot;DAMAGE&quot;,&quot;DANGER&quot;,&quot;DANGEROUS&quot;, &quot;DARK&quot;,&quot;DATA&quot;,&quot;DATE&quot;,&quot;DAUGHTER&quot;,&quot;DAY&quot;,&quot;DEAD&quot;,&quot;DEAL&quot;,&quot;DEATH&quot;,&quot;DEBATE&quot;,&quot;DEBT&quot;, &quot;DECADE&quot;,&quot;DECIDE&quot;,&quot;DECISION&quot;,&quot;DECLARE&quot;,&quot;DEEP&quot;,&quot;DEFENCE&quot;,&quot;DEFENDANT&quot;,&quot;DEFINE&quot;,&quot;DEFINITION&quot;,&quot;DEGREE&quot;, &quot;DELIVER&quot;,&quot;DEMAND&quot;,&quot;DEMOCRATIC&quot;,&quot;DEMONSTRATE&quot;,&quot;DENY&quot;,&quot;DEPARTMENT&quot;,&quot;DEPEND&quot;,&quot;DEPUTY&quot;,&quot;DERIVE&quot;,&quot;DESCRIBE&quot;, &quot;DESCRIPTION&quot;,&quot;DESIGN&quot;,&quot;DESIRE&quot;,&quot;DESK&quot;,&quot;DESPITE&quot;,&quot;DESTROY&quot;,&quot;DETAIL&quot;,&quot;DETAILED&quot;,&quot;DETERMINE&quot;,&quot;DEVELOP&quot;, &quot;DEVELOPMENT&quot;,&quot;DEVICE&quot;,&quot;DIE&quot;,&quot;DIFFERENCE&quot;,&quot;DIFFERENT&quot;,&quot;DIFFICULT&quot;,&quot;DIFFICULTY&quot;,&quot;DINNER&quot;,&quot;DIRECT&quot;,&quot;DIRECTION&quot;, &quot;DIRECTLY&quot;,&quot;DIRECTOR&quot;,&quot;DISAPPEAR&quot;,&quot;DISCIPLINE&quot;,&quot;DISCOVER&quot;,&quot;DISCUSS&quot;,&quot;DISCUSSION&quot;,&quot;DISEASE&quot;,&quot;DISPLAY&quot;,&quot;DISTANCE&quot;, &quot;DISTINCTION&quot;,&quot;DISTRIBUTION&quot;,&quot;DISTRICT&quot;,&quot;DIVIDE&quot;,&quot;DIVISION&quot;,&quot;DO&quot;,&quot;DOCTOR&quot;,&quot;DOCUMENT&quot;,&quot;DOG&quot;,&quot;DOMESTIC&quot;, &quot;DOOR&quot;,&quot;DOUBLE&quot;,&quot;DOUBT&quot;,&quot;DOWN&quot;,&quot;DRAW&quot;,&quot;DRAWING&quot;,&quot;DREAM&quot;,&quot;DRESS&quot;,&quot;DRINK&quot;,&quot;DRIVE&quot;, &quot;DRIVER&quot;,&quot;DROP&quot;,&quot;DRUG&quot;,&quot;DRY&quot;,&quot;DUE&quot;,&quot;DURING&quot;,&quot;DUTY&quot;,&quot;EACH&quot;,&quot;EAR&quot;,&quot;EARLY&quot;, &quot;EARN&quot;,&quot;EARTH&quot;,&quot;EASILY&quot;,&quot;EAST&quot;,&quot;EASY&quot;,&quot;EAT&quot;,&quot;ECONOMIC&quot;,&quot;ECONOMY&quot;,&quot;EDGE&quot;,&quot;EDITOR&quot;, &quot;EDUCATION&quot;,&quot;EDUCATIONAL&quot;,&quot;EFFECT&quot;,&quot;EFFECTIVE&quot;,&quot;EFFECTIVELY&quot;,&quot;EFFORT&quot;,&quot;EGG&quot;,&quot;EITHER&quot;,&quot;ELDERLY&quot;,&quot;ELECTION&quot;, &quot;ELEMENT&quot;,&quot;ELSE&quot;,&quot;ELSEWHERE&quot;,&quot;EMERGE&quot;,&quot;EMPHASIS&quot;,&quot;EMPLOY&quot;,&quot;EMPLOYEE&quot;,&quot;EMPLOYER&quot;,&quot;EMPLOYMENT&quot;,&quot;EMPTY&quot;, &quot;ENABLE&quot;,&quot;ENCOURAGE&quot;,&quot;END&quot;,&quot;ENEMY&quot;,&quot;ENERGY&quot;,&quot;ENGINE&quot;,&quot;ENGINEERING&quot;,&quot;ENJOY&quot;,&quot;ENOUGH&quot;,&quot;ENSURE&quot;, &quot;ENTER&quot;,&quot;ENTERPRISE&quot;,&quot;ENTIRE&quot;,&quot;ENTIRELY&quot;,&quot;ENTITLE&quot;,&quot;ENTRY&quot;,&quot;ENVIRONMENT&quot;,&quot;ENVIRONMENTAL&quot;,&quot;EQUAL&quot;,&quot;EQUALLY&quot;, &quot;EQUIPMENT&quot;,&quot;ERROR&quot;,&quot;ESCAPE&quot;,&quot;ESPECIALLY&quot;,&quot;ESSENTIAL&quot;,&quot;ESTABLISH&quot;,&quot;ESTABLISHMENT&quot;,&quot;ESTATE&quot;,&quot;ESTIMATE&quot;,&quot;EVEN&quot;, &quot;EVENING&quot;,&quot;EVENT&quot;,&quot;EVENTUALLY&quot;,&quot;EVER&quot;,&quot;EVERY&quot;,&quot;EVERYBODY&quot;,&quot;EVERYONE&quot;,&quot;EVERYTHING&quot;,&quot;EVIDENCE&quot;,&quot;EXACTLY&quot;, &quot;EXAMINATION&quot;,&quot;EXAMINE&quot;,&quot;EXAMPLE&quot;,&quot;EXCELLENT&quot;,&quot;EXCEPT&quot;,&quot;EXCHANGE&quot;,&quot;EXECUTIVE&quot;,&quot;EXERCISE&quot;,&quot;EXHIBITION&quot;,&quot;EXIST&quot;, &quot;EXISTENCE&quot;,&quot;EXISTING&quot;,&quot;EXPECT&quot;,&quot;EXPECTATION&quot;,&quot;EXPENDITURE&quot;,&quot;EXPENSE&quot;,&quot;EXPENSIVE&quot;,&quot;EXPERIENCE&quot;,&quot;EXPERIMENT&quot;,&quot;EXPERT&quot;, &quot;EXPLAIN&quot;,&quot;EXPLANATION&quot;,&quot;EXPLORE&quot;,&quot;EXPRESS&quot;,&quot;EXPRESSION&quot;,&quot;EXTEND&quot;,&quot;EXTENT&quot;,&quot;EXTERNAL&quot;,&quot;EXTRA&quot;,&quot;EXTREMELY&quot;, &quot;EYE&quot;,&quot;FACE&quot;,&quot;FACILITY&quot;,&quot;FACT&quot;,&quot;FACTOR&quot;,&quot;FACTORY&quot;,&quot;FAIL&quot;,&quot;FAILURE&quot;,&quot;FAIR&quot;,&quot;FAIRLY&quot;, &quot;FAITH&quot;,&quot;FALL&quot;,&quot;FAMILIAR&quot;,&quot;FAMILY&quot;,&quot;FAMOUS&quot;,&quot;FAR&quot;,&quot;FARM&quot;,&quot;FARMER&quot;,&quot;FASHION&quot;,&quot;FAST&quot;, &quot;FATHER&quot;,&quot;FAVOUR&quot;,&quot;FEAR&quot;,&quot;FEATURE&quot;,&quot;FEE&quot;,&quot;FEEL&quot;,&quot;FEELING&quot;,&quot;FEMALE&quot;,&quot;FEW&quot;,&quot;FIELD&quot;, &quot;FIGHT&quot;,&quot;FIGURE&quot;,&quot;FILE&quot;,&quot;FILL&quot;,&quot;FILM&quot;,&quot;FINAL&quot;,&quot;FINALLY&quot;,&quot;FINANCE&quot;,&quot;FINANCIAL&quot;,&quot;FIND&quot;, &quot;FINDING&quot;,&quot;FINE&quot;,&quot;FINGER&quot;,&quot;FINISH&quot;,&quot;FIRE&quot;,&quot;FIRM&quot;,&quot;FIRST&quot;,&quot;FISH&quot;,&quot;FIT&quot;,&quot;FIX&quot;, &quot;FLAT&quot;,&quot;FLIGHT&quot;,&quot;FLOOR&quot;,&quot;FLOW&quot;,&quot;FLOWER&quot;,&quot;FLY&quot;,&quot;FOCUS&quot;,&quot;FOLLOW&quot;,&quot;FOLLOWING&quot;,&quot;FOOD&quot;, &quot;FOOT&quot;,&quot;FOOTBALL&quot;,&quot;FOR&quot;,&quot;FORCE&quot;,&quot;FOREIGN&quot;,&quot;FOREST&quot;,&quot;FORGET&quot;,&quot;FORM&quot;,&quot;FORMAL&quot;,&quot;FORMER&quot;, &quot;FORWARD&quot;,&quot;FOUNDATION&quot;,&quot;FREE&quot;,&quot;FREEDOM&quot;,&quot;FREQUENTLY&quot;,&quot;FRESH&quot;,&quot;FRIEND&quot;,&quot;FROM&quot;,&quot;FRONT&quot;,&quot;FRUIT&quot;, &quot;FUEL&quot;,&quot;FULL&quot;,&quot;FULLY&quot;,&quot;FUNCTION&quot;,&quot;FUND&quot;,&quot;FUNNY&quot;,&quot;FURTHER&quot;,&quot;FUTURE&quot;,&quot;GAIN&quot;,&quot;GAME&quot;, &quot;GARDEN&quot;,&quot;GAS&quot;,&quot;GATE&quot;,&quot;GATHER&quot;,&quot;GENERAL&quot;,&quot;GENERALLY&quot;,&quot;GENERATE&quot;,&quot;GENERATION&quot;,&quot;GENTLEMAN&quot;,&quot;GET&quot;, &quot;GIRL&quot;,&quot;GIVE&quot;,&quot;GLASS&quot;,&quot;GO&quot;,&quot;GOAL&quot;,&quot;GOD&quot;,&quot;GOLD&quot;,&quot;GOOD&quot;,&quot;GOVERNMENT&quot;,&quot;GRANT&quot;, &quot;GREAT&quot;,&quot;GREEN&quot;,&quot;GREY&quot;,&quot;GROUND&quot;,&quot;GROUP&quot;,&quot;GROW&quot;,&quot;GROWING&quot;,&quot;GROWTH&quot;,&quot;GUEST&quot;,&quot;GUIDE&quot;, &quot;GUN&quot;,&quot;HAIR&quot;,&quot;HALF&quot;,&quot;HALL&quot;,&quot;HAND&quot;,&quot;HANDLE&quot;,&quot;HANG&quot;,&quot;HAPPEN&quot;,&quot;HAPPY&quot;,&quot;HARD&quot;, &quot;HARDLY&quot;,&quot;HATE&quot;,&quot;HAVE&quot;,&quot;HE&quot;,&quot;HEAD&quot;,&quot;HEALTH&quot;,&quot;HEAR&quot;,&quot;HEART&quot;,&quot;HEAT&quot;,&quot;HEAVY&quot;, &quot;HELL&quot;,&quot;HELP&quot;,&quot;HENCE&quot;,&quot;HER&quot;,&quot;HERE&quot;,&quot;HERSELF&quot;,&quot;HIDE&quot;,&quot;HIGH&quot;,&quot;HIGHLY&quot;,&quot;HILL&quot;, &quot;HIM&quot;,&quot;HIMSELF&quot;,&quot;HIS&quot;,&quot;HISTORICAL&quot;,&quot;HISTORY&quot;,&quot;HIT&quot;,&quot;HOLD&quot;,&quot;HOLE&quot;,&quot;HOLIDAY&quot;,&quot;HOME&quot;, &quot;HOPE&quot;,&quot;HORSE&quot;,&quot;HOSPITAL&quot;,&quot;HOT&quot;,&quot;HOTEL&quot;,&quot;HOUR&quot;,&quot;HOUSE&quot;,&quot;HOUSEHOLD&quot;,&quot;HOUSING&quot;,&quot;HOW&quot;, &quot;HOWEVER&quot;,&quot;HUGE&quot;,&quot;HUMAN&quot;,&quot;HURT&quot;,&quot;HUSBAND&quot;,&quot;I&quot;,&quot;IDEA&quot;,&quot;IDENTIFY&quot;,&quot;IF&quot;,&quot;IGNORE&quot;, &quot;ILLUSTRATE&quot;,&quot;IMAGE&quot;,&quot;IMAGINE&quot;,&quot;IMMEDIATE&quot;,&quot;IMMEDIATELY&quot;,&quot;IMPACT&quot;,&quot;IMPLICATION&quot;,&quot;IMPLY&quot;,&quot;IMPORTANCE&quot;,&quot;IMPORTANT&quot;, &quot;IMPOSE&quot;,&quot;IMPOSSIBLE&quot;,&quot;IMPRESSION&quot;,&quot;IMPROVE&quot;,&quot;IMPROVEMENT&quot;,&quot;IN&quot;,&quot;INCIDENT&quot;,&quot;INCLUDE&quot;,&quot;INCLUDING&quot;,&quot;INCOME&quot;, &quot;INCREASE&quot;,&quot;INCREASED&quot;,&quot;INCREASINGLY&quot;,&quot;INDEED&quot;,&quot;INDEPENDENT&quot;,&quot;INDEX&quot;,&quot;INDICATE&quot;,&quot;INDIVIDUAL&quot;,&quot;INDUSTRIAL&quot;,&quot;INDUSTRY&quot;, &quot;INFLUENCE&quot;,&quot;INFORM&quot;,&quot;INFORMATION&quot;,&quot;INITIAL&quot;,&quot;INITIATIVE&quot;,&quot;INJURY&quot;,&quot;INSIDE&quot;,&quot;INSIST&quot;,&quot;INSTANCE&quot;,&quot;INSTEAD&quot;, &quot;INSTITUTE&quot;,&quot;INSTITUTION&quot;,&quot;INSTRUCTION&quot;,&quot;INSTRUMENT&quot;,&quot;INSURANCE&quot;,&quot;INTEND&quot;,&quot;INTENTION&quot;,&quot;INTEREST&quot;,&quot;INTERESTED&quot;,&quot;INTERESTING&quot;, &quot;INTERNAL&quot;,&quot;INTERNATIONAL&quot;,&quot;INTERPRETATION&quot;,&quot;INTERVIEW&quot;,&quot;INTO&quot;,&quot;INTRODUCE&quot;,&quot;INTRODUCTION&quot;,&quot;INVESTIGATE&quot;,&quot;INVESTIGATION&quot;,&quot;INVESTMENT&quot;, &quot;INVITE&quot;,&quot;INVOLVE&quot;,&quot;IRON&quot;,&quot;IS&quot;,&quot;ISLAND&quot;,&quot;ISSUE&quot;,&quot;IT&quot;,&quot;ITEM&quot;,&quot;ITS&quot;,&quot;ITSELF&quot;, &quot;JOB&quot;,&quot;JOIN&quot;,&quot;JOINT&quot;,&quot;JOURNEY&quot;,&quot;JUDGE&quot;,&quot;JUMP&quot;,&quot;JUST&quot;,&quot;JUSTICE&quot;,&quot;KEEP&quot;,&quot;KEY&quot;, &quot;KID&quot;,&quot;KILL&quot;,&quot;KIND&quot;,&quot;KING&quot;,&quot;KITCHEN&quot;,&quot;KNEE&quot;,&quot;KNOW&quot;,&quot;KNOWLEDGE&quot;,&quot;LABOUR&quot;,&quot;LACK&quot;, &quot;LADY&quot;,&quot;LAND&quot;,&quot;LANGUAGE&quot;,&quot;LARGE&quot;,&quot;LARGELY&quot;,&quot;LAST&quot;,&quot;LATE&quot;,&quot;LATER&quot;,&quot;LATTER&quot;,&quot;LAUGH&quot;, &quot;LAUNCH&quot;,&quot;LAW&quot;,&quot;LAWYER&quot;,&quot;LAY&quot;,&quot;LEAD&quot;,&quot;LEADER&quot;,&quot;LEADERSHIP&quot;,&quot;LEADING&quot;,&quot;LEAF&quot;,&quot;LEAGUE&quot;, &quot;LEAN&quot;,&quot;LEARN&quot;,&quot;LEAST&quot;,&quot;LEAVE&quot;,&quot;LEFT&quot;,&quot;LEG&quot;,&quot;LEGAL&quot;,&quot;LEGISLATION&quot;,&quot;LENGTH&quot;,&quot;LESS&quot;, &quot;LET&quot;,&quot;LETTER&quot;,&quot;LEVEL&quot;,&quot;LIABILITY&quot;,&quot;LIBERAL&quot;,&quot;LIBRARY&quot;,&quot;LIE&quot;,&quot;LIFE&quot;,&quot;LIFT&quot;,&quot;LIGHT&quot;, &quot;LIKE&quot;,&quot;LIKELY&quot;,&quot;LIMIT&quot;,&quot;LIMITED&quot;,&quot;LINE&quot;,&quot;LINK&quot;,&quot;LIP&quot;,&quot;LIST&quot;,&quot;LISTEN&quot;,&quot;LITERATURE&quot;, &quot;LITTLE&quot;,&quot;LIVE&quot;,&quot;LIVING&quot;,&quot;LOAN&quot;,&quot;LOCAL&quot;,&quot;LOCATION&quot;,&quot;LONG&quot;,&quot;LOOK&quot;,&quot;LORD&quot;,&quot;LOSE&quot;, &quot;LOSS&quot;,&quot;LOT&quot;,&quot;LOVE&quot;,&quot;LOVELY&quot;,&quot;LOW&quot;,&quot;LUNCH&quot;,&quot;MACHINE&quot;,&quot;MAGAZINE&quot;,&quot;MAIN&quot;,&quot;MAINLY&quot;, &quot;MAINTAIN&quot;,&quot;MAJOR&quot;,&quot;MAJORITY&quot;,&quot;MAKE&quot;,&quot;MALE&quot;,&quot;MAN&quot;,&quot;MANAGE&quot;,&quot;MANAGEMENT&quot;,&quot;MANAGER&quot;,&quot;MANNER&quot;, &quot;MANY&quot;,&quot;MAP&quot;,&quot;MARK&quot;,&quot;MARKET&quot;,&quot;MARRIAGE&quot;,&quot;MARRIED&quot;,&quot;MARRY&quot;,&quot;MASS&quot;,&quot;MASTER&quot;,&quot;MATCH&quot;, &quot;MATERIAL&quot;,&quot;MATTER&quot;,&quot;MAY&quot;,&quot;MAYBE&quot;,&quot;ME&quot;,&quot;MEAL&quot;,&quot;MEAN&quot;,&quot;MEANING&quot;,&quot;MEANS&quot;,&quot;MEANWHILE&quot;, &quot;MEASURE&quot;,&quot;MECHANISM&quot;,&quot;MEDIA&quot;,&quot;MEDICAL&quot;,&quot;MEET&quot;,&quot;MEETING&quot;,&quot;MEMBER&quot;,&quot;MEMBERSHIP&quot;,&quot;MEMORY&quot;,&quot;MENTAL&quot;, &quot;MENTION&quot;,&quot;MERELY&quot;,&quot;MESSAGE&quot;,&quot;METAL&quot;,&quot;METHOD&quot;,&quot;MIDDLE&quot;,&quot;MIGHT&quot;,&quot;MILE&quot;,&quot;MILITARY&quot;,&quot;MILK&quot;, &quot;MIND&quot;,&quot;MINE&quot;,&quot;MINISTER&quot;,&quot;MINISTRY&quot;,&quot;MINUTE&quot;,&quot;MISS&quot;,&quot;MISTAKE&quot;,&quot;MODEL&quot;,&quot;MODERN&quot;,&quot;MODULE&quot;, &quot;MOMENT&quot;,&quot;MONEY&quot;,&quot;MONTH&quot;,&quot;MORE&quot;,&quot;MORNING&quot;,&quot;MOST&quot;,&quot;MOTHER&quot;,&quot;MOTION&quot;,&quot;MOTOR&quot;,&quot;MOUNTAIN&quot;, &quot;MOUTH&quot;,&quot;MOVE&quot;,&quot;MOVEMENT&quot;,&quot;MUCH&quot;,&quot;MURDER&quot;,&quot;MUSEUM&quot;,&quot;MUSIC&quot;,&quot;MUST&quot;,&quot;MY&quot;,&quot;MYSELF&quot;, &quot;NAME&quot;,&quot;NARROW&quot;,&quot;NATION&quot;,&quot;NATIONAL&quot;,&quot;NATURAL&quot;,&quot;NATURE&quot;,&quot;NEAR&quot;,&quot;NEARLY&quot;,&quot;NECESSARILY&quot;,&quot;NECESSARY&quot;, &quot;NECK&quot;,&quot;NEED&quot;,&quot;NEGOTIATION&quot;,&quot;NEIGHBOUR&quot;,&quot;NEITHER&quot;,&quot;NETWORK&quot;,&quot;NEVER&quot;,&quot;NEVERTHELESS&quot;,&quot;NEW&quot;,&quot;NEWS&quot;, &quot;NEWSPAPER&quot;,&quot;NEXT&quot;,&quot;NICE&quot;,&quot;NIGHT&quot;,&quot;NO&quot;,&quot;NOBODY&quot;,&quot;NOD&quot;,&quot;NOISE&quot;,&quot;NONE&quot;,&quot;NOR&quot;, &quot;NORMAL&quot;,&quot;NORMALLY&quot;,&quot;NORTH&quot;,&quot;NORTHERN&quot;,&quot;NOSE&quot;,&quot;NOT&quot;,&quot;NOTE&quot;,&quot;NOTHING&quot;,&quot;NOTICE&quot;,&quot;NOTION&quot;, &quot;NOW&quot;,&quot;NUCLEAR&quot;,&quot;NUMBER&quot;,&quot;NURSE&quot;,&quot;OBJECT&quot;,&quot;OBJECTIVE&quot;,&quot;OBSERVATION&quot;,&quot;OBSERVE&quot;,&quot;OBTAIN&quot;,&quot;OBVIOUS&quot;, &quot;OBVIOUSLY&quot;,&quot;OCCASION&quot;,&quot;OCCUR&quot;,&quot;ODD&quot;,&quot;OF&quot;,&quot;OFF&quot;,&quot;OFFENCE&quot;,&quot;OFFER&quot;,&quot;OFFICE&quot;,&quot;OFFICER&quot;, &quot;OFFICIAL&quot;,&quot;OFTEN&quot;,&quot;OIL&quot;,&quot;OKAY&quot;,&quot;OLD&quot;,&quot;ON&quot;,&quot;ONCE&quot;,&quot;ONE&quot;,&quot;ONLY&quot;,&quot;ONTO&quot;, &quot;OPEN&quot;,&quot;OPERATE&quot;,&quot;OPERATION&quot;,&quot;OPINION&quot;,&quot;OPPORTUNITY&quot;,&quot;OPPOSITION&quot;,&quot;OPTION&quot;,&quot;OR&quot;,&quot;ORDER&quot;,&quot;ORDINARY&quot;, &quot;ORGANISATION&quot;,&quot;ORGANISE&quot;,&quot;ORGANIZATION&quot;,&quot;ORIGIN&quot;,&quot;ORIGINAL&quot;,&quot;OTHER&quot;,&quot;OTHERWISE&quot;,&quot;OUGHT&quot;,&quot;OUR&quot;,&quot;OURSELVES&quot;, &quot;OUT&quot;,&quot;OUTCOME&quot;,&quot;OUTPUT&quot;,&quot;OUTSIDE&quot;,&quot;OVER&quot;,&quot;OVERALL&quot;,&quot;OWN&quot;,&quot;OWNER&quot;,&quot;PACKAGE&quot;,&quot;PAGE&quot;, &quot;PAIN&quot;,&quot;PAINT&quot;,&quot;PAINTING&quot;,&quot;PAIR&quot;,&quot;PANEL&quot;,&quot;PAPER&quot;,&quot;PARENT&quot;,&quot;PARK&quot;,&quot;PARLIAMENT&quot;,&quot;PART&quot;, &quot;PARTICULAR&quot;,&quot;PARTICULARLY&quot;,&quot;PARTLY&quot;,&quot;PARTNER&quot;,&quot;PARTY&quot;,&quot;PASS&quot;,&quot;PASSAGE&quot;,&quot;PAST&quot;,&quot;PATH&quot;,&quot;PATIENT&quot;, &quot;PATTERN&quot;,&quot;PAY&quot;,&quot;PAYMENT&quot;,&quot;PEACE&quot;,&quot;PENSION&quot;,&quot;PEOPLE&quot;,&quot;PER&quot;,&quot;PERCENT&quot;,&quot;PERFECT&quot;,&quot;PERFORM&quot;, &quot;PERFORMANCE&quot;,&quot;PERHAPS&quot;,&quot;PERIOD&quot;,&quot;PERMANENT&quot;,&quot;PERSON&quot;,&quot;PERSONAL&quot;,&quot;PERSUADE&quot;,&quot;PHASE&quot;,&quot;PHONE&quot;,&quot;PHOTOGRAPH&quot;, &quot;PHYSICAL&quot;,&quot;PICK&quot;,&quot;PICTURE&quot;,&quot;PIECE&quot;,&quot;PLACE&quot;,&quot;PLAN&quot;,&quot;PLANNING&quot;,&quot;PLANT&quot;,&quot;PLASTIC&quot;,&quot;PLATE&quot;, &quot;PLAY&quot;,&quot;PLAYER&quot;,&quot;PLEASE&quot;,&quot;PLEASURE&quot;,&quot;PLENTY&quot;,&quot;PLUS&quot;,&quot;POCKET&quot;,&quot;POINT&quot;,&quot;POLICE&quot;,&quot;POLICY&quot;, &quot;POLITICAL&quot;,&quot;POLITICS&quot;,&quot;POOL&quot;,&quot;POOR&quot;,&quot;POPULAR&quot;,&quot;POPULATION&quot;,&quot;POSITION&quot;,&quot;POSITIVE&quot;,&quot;POSSIBILITY&quot;,&quot;POSSIBLE&quot;, &quot;POSSIBLY&quot;,&quot;POST&quot;,&quot;POTENTIAL&quot;,&quot;POUND&quot;,&quot;POWER&quot;,&quot;POWERFUL&quot;,&quot;PRACTICAL&quot;,&quot;PRACTICE&quot;,&quot;PREFER&quot;,&quot;PREPARE&quot;, &quot;PRESENCE&quot;,&quot;PRESENT&quot;,&quot;PRESIDENT&quot;,&quot;PRESS&quot;,&quot;PRESSURE&quot;,&quot;PRETTY&quot;,&quot;PREVENT&quot;,&quot;PREVIOUS&quot;,&quot;PREVIOUSLY&quot;,&quot;PRICE&quot;, &quot;PRIMARY&quot;,&quot;PRIME&quot;,&quot;PRINCIPLE&quot;,&quot;PRIORITY&quot;,&quot;PRISON&quot;,&quot;PRISONER&quot;,&quot;PRIVATE&quot;,&quot;PROBABLY&quot;,&quot;PROBLEM&quot;,&quot;PROCEDURE&quot;, &quot;PROCESS&quot;,&quot;PRODUCE&quot;,&quot;PRODUCT&quot;,&quot;PRODUCTION&quot;,&quot;PROFESSIONAL&quot;,&quot;PROFIT&quot;,&quot;PROGRAM&quot;,&quot;PROGRAMME&quot;,&quot;PROGRESS&quot;,&quot;PROJECT&quot;, &quot;PROMISE&quot;,&quot;PROMOTE&quot;,&quot;PROPER&quot;,&quot;PROPERLY&quot;,&quot;PROPERTY&quot;,&quot;PROPORTION&quot;,&quot;PROPOSE&quot;,&quot;PROPOSAL&quot;,&quot;PROSPECT&quot;,&quot;PROTECT&quot;, &quot;PROTECTION&quot;,&quot;PROVE&quot;,&quot;PROVIDE&quot;,&quot;PROVIDED&quot;,&quot;PROVISION&quot;,&quot;PUB&quot;,&quot;PUBLIC&quot;,&quot;PUBLICATION&quot;,&quot;PUBLISH&quot;,&quot;PULL&quot;, &quot;PUPIL&quot;,&quot;PURPOSE&quot;,&quot;PUSH&quot;,&quot;PUT&quot;,&quot;QUALITY&quot;,&quot;QUARTER&quot;,&quot;QUESTION&quot;,&quot;QUICK&quot;,&quot;QUICKLY&quot;,&quot;QUIET&quot;, &quot;QUITE&quot;,&quot;RACE&quot;,&quot;RADIO&quot;,&quot;RAILWAY&quot;,&quot;RAIN&quot;,&quot;RAISE&quot;,&quot;RANGE&quot;,&quot;RAPIDLY&quot;,&quot;RARE&quot;,&quot;RATE&quot;, &quot;RATHER&quot;,&quot;REACH&quot;,&quot;REACTION&quot;,&quot;READ&quot;,&quot;READER&quot;,&quot;READING&quot;,&quot;READY&quot;,&quot;REAL&quot;,&quot;REALISE&quot;,&quot;REALITY&quot;, &quot;REALIZE&quot;,&quot;REALLY&quot;,&quot;REASON&quot;,&quot;REASONABLE&quot;,&quot;RECALL&quot;,&quot;RECEIVE&quot;,&quot;RECENT&quot;,&quot;RECENTLY&quot;,&quot;RECOGNISE&quot;,&quot;RECOGNITION&quot;, &quot;RECOGNIZE&quot;,&quot;RECOMMEND&quot;,&quot;RECORD&quot;,&quot;RECOVER&quot;,&quot;RED&quot;,&quot;REDUCE&quot;,&quot;REDUCTION&quot;,&quot;REFER&quot;,&quot;REFERENCE&quot;,&quot;REFLECT&quot;, &quot;REFORM&quot;,&quot;REFUSE&quot;,&quot;REGARD&quot;,&quot;REGION&quot;,&quot;REGIONAL&quot;,&quot;REGULAR&quot;,&quot;REGULATION&quot;,&quot;REJECT&quot;,&quot;RELATE&quot;,&quot;RELATION&quot;, &quot;RELATIONSHIP&quot;,&quot;RELATIVE&quot;,&quot;RELATIVELY&quot;,&quot;RELEASE&quot;,&quot;RELEVANT&quot;,&quot;RELIEF&quot;,&quot;RELIGION&quot;,&quot;RELIGIOUS&quot;,&quot;RELY&quot;,&quot;REMAIN&quot;, &quot;REMEMBER&quot;,&quot;REMIND&quot;,&quot;REMOVE&quot;,&quot;REPEAT&quot;,&quot;REPLACE&quot;,&quot;REPLY&quot;,&quot;REPORT&quot;,&quot;REPRESENT&quot;,&quot;REPRESENTATION&quot;,&quot;REPRESENTATIVE&quot;, &quot;REQUEST&quot;,&quot;REQUIRE&quot;,&quot;REQUIREMENT&quot;,&quot;RESEARCH&quot;,&quot;RESOURCE&quot;,&quot;RESPECT&quot;,&quot;RESPOND&quot;,&quot;RESPONSE&quot;,&quot;RESPONSIBILITY&quot;,&quot;RESPONSIBLE&quot;, &quot;REST&quot;,&quot;RESTAURANT&quot;,&quot;RESULT&quot;,&quot;RETAIN&quot;,&quot;RETURN&quot;,&quot;REVEAL&quot;,&quot;REVENUE&quot;,&quot;REVIEW&quot;,&quot;REVOLUTION&quot;,&quot;RICH&quot;, &quot;RIDE&quot;,&quot;RIGHT&quot;,&quot;RING&quot;,&quot;RISE&quot;,&quot;RISK&quot;,&quot;RIVER&quot;,&quot;ROAD&quot;,&quot;ROCK&quot;,&quot;ROLE&quot;,&quot;ROLL&quot;, &quot;ROOF&quot;,&quot;ROOM&quot;,&quot;ROUND&quot;,&quot;ROUTE&quot;,&quot;ROW&quot;,&quot;ROYAL&quot;,&quot;RULE&quot;,&quot;RUN&quot;,&quot;RURAL&quot;,&quot;SAFE&quot;, &quot;SAFETY&quot;,&quot;SALE&quot;,&quot;SAME&quot;,&quot;SAMPLE&quot;,&quot;SATISFY&quot;,&quot;SAVE&quot;,&quot;SAY&quot;,&quot;SCALE&quot;,&quot;SCENE&quot;,&quot;SCHEME&quot;, &quot;SCHOOL&quot;,&quot;SCIENCE&quot;,&quot;SCIENTIFIC&quot;,&quot;SCIENTIST&quot;,&quot;SCORE&quot;,&quot;SCREEN&quot;,&quot;SEA&quot;,&quot;SEARCH&quot;,&quot;SEASON&quot;,&quot;SEAT&quot;, &quot;SECOND&quot;,&quot;SECONDARY&quot;,&quot;SECRETARY&quot;,&quot;SECTION&quot;,&quot;SECTOR&quot;,&quot;SECURE&quot;,&quot;SECURITY&quot;,&quot;SEE&quot;,&quot;SEEK&quot;,&quot;SEEM&quot;, &quot;SELECT&quot;,&quot;SELECTION&quot;,&quot;SELL&quot;,&quot;SEND&quot;,&quot;SENIOR&quot;,&quot;SENSE&quot;,&quot;SENTENCE&quot;,&quot;SEPARATE&quot;,&quot;SEQUENCE&quot;,&quot;SERIES&quot;, &quot;SERIOUS&quot;,&quot;SERIOUSLY&quot;,&quot;SERVANT&quot;,&quot;SERVE&quot;,&quot;SERVICE&quot;,&quot;SESSION&quot;,&quot;SET&quot;,&quot;SETTLE&quot;,&quot;SETTLEMENT&quot;,&quot;SEVERAL&quot;, &quot;SEVERE&quot;,&quot;SEX&quot;,&quot;SEXUAL&quot;,&quot;SHAKE&quot;,&quot;SHALL&quot;,&quot;SHAPE&quot;,&quot;SHARE&quot;,&quot;SHE&quot;,&quot;SHEET&quot;,&quot;SHIP&quot;, &quot;SHOE&quot;,&quot;SHOOT&quot;,&quot;SHOP&quot;,&quot;SHORT&quot;,&quot;SHOT&quot;,&quot;SHOULD&quot;,&quot;SHOULDER&quot;,&quot;SHOUT&quot;,&quot;SHOW&quot;,&quot;SHUT&quot;, &quot;SIDE&quot;,&quot;SIGHT&quot;,&quot;SIGN&quot;,&quot;SIGNAL&quot;,&quot;SIGNIFICANCE&quot;,&quot;SIGNIFICANT&quot;,&quot;SILENCE&quot;,&quot;SIMILAR&quot;,&quot;SIMPLE&quot;,&quot;SIMPLY&quot;, &quot;SINCE&quot;,&quot;SING&quot;,&quot;SINGLE&quot;,&quot;SIR&quot;,&quot;SISTER&quot;,&quot;SIT&quot;,&quot;SITE&quot;,&quot;SITUATION&quot;,&quot;SIZE&quot;,&quot;SKILL&quot;, &quot;SKIN&quot;,&quot;SKY&quot;,&quot;SLEEP&quot;,&quot;SLIGHTLY&quot;,&quot;SLIP&quot;,&quot;SLOW&quot;,&quot;SLOWLY&quot;,&quot;SMALL&quot;,&quot;SMILE&quot;,&quot;SO&quot;, &quot;SOCIAL&quot;,&quot;SOCIETY&quot;,&quot;SOFT&quot;,&quot;SOFTWARE&quot;,&quot;SOIL&quot;,&quot;SOLDIER&quot;,&quot;SOLICITOR&quot;,&quot;SOLUTION&quot;,&quot;SOME&quot;,&quot;SOMEBODY&quot;, &quot;SOMEONE&quot;,&quot;SOMETHING&quot;,&quot;SOMETIMES&quot;,&quot;SOMEWHAT&quot;,&quot;SOMEWHERE&quot;,&quot;SON&quot;,&quot;SONG&quot;,&quot;SOON&quot;,&quot;SORRY&quot;,&quot;SORT&quot;, &quot;SOUND&quot;,&quot;SOURCE&quot;,&quot;SOUTH&quot;,&quot;SOUTHERN&quot;,&quot;SPACE&quot;,&quot;SPEAK&quot;,&quot;SPEAKER&quot;,&quot;SPECIAL&quot;,&quot;SPECIES&quot;,&quot;SPECIFIC&quot;, &quot;SPEECH&quot;,&quot;SPEED&quot;,&quot;SPEND&quot;,&quot;SPIRIT&quot;,&quot;SPORT&quot;,&quot;SPOT&quot;,&quot;SPREAD&quot;,&quot;SPRING&quot;,&quot;STAFF&quot;,&quot;STAGE&quot;, &quot;STAND&quot;,&quot;STANDARD&quot;,&quot;STAR&quot;,&quot;START&quot;,&quot;STATE&quot;,&quot;STATEMENT&quot;,&quot;STATION&quot;,&quot;STATUS&quot;,&quot;STAY&quot;,&quot;STEAL&quot;, &quot;STEP&quot;,&quot;STICK&quot;,&quot;STILL&quot;,&quot;STOCK&quot;,&quot;STONE&quot;,&quot;STOP&quot;,&quot;STORE&quot;,&quot;STORY&quot;,&quot;STRAIGHT&quot;,&quot;STRANGE&quot;, &quot;STRATEGY&quot;,&quot;STREET&quot;,&quot;STRENGTH&quot;,&quot;STRIKE&quot;,&quot;STRONG&quot;,&quot;STRONGLY&quot;,&quot;STRUCTURE&quot;,&quot;STUDENT&quot;,&quot;STUDIO&quot;,&quot;STUDY&quot;, &quot;STUFF&quot;,&quot;STYLE&quot;,&quot;SUBJECT&quot;,&quot;SUBSTANTIAL&quot;,&quot;SUCCEED&quot;,&quot;SUCCESS&quot;,&quot;SUCCESSFUL&quot;,&quot;SUCH&quot;,&quot;SUDDENLY&quot;,&quot;SUFFER&quot;, &quot;SUFFICIENT&quot;,&quot;SUGGEST&quot;,&quot;SUGGESTION&quot;,&quot;SUITABLE&quot;,&quot;SUM&quot;,&quot;SUMMER&quot;,&quot;SUN&quot;,&quot;SUPPLY&quot;,&quot;SUPPORT&quot;,&quot;SUPPOSE&quot;, &quot;SURE&quot;,&quot;SURELY&quot;,&quot;SURFACE&quot;,&quot;SURPRISE&quot;,&quot;SURROUND&quot;,&quot;SURVEY&quot;,&quot;SURVIVE&quot;,&quot;SWITCH&quot;,&quot;SYSTEM&quot;,&quot;TABLE&quot;, &quot;TAKE&quot;,&quot;TALK&quot;,&quot;TALL&quot;,&quot;TAPE&quot;,&quot;TARGET&quot;,&quot;TASK&quot;,&quot;TAX&quot;,&quot;TEA&quot;,&quot;TEACH&quot;,&quot;TEACHER&quot;, &quot;TEACHING&quot;,&quot;TEAM&quot;,&quot;TEAR&quot;,&quot;TECHNICAL&quot;,&quot;TECHNIQUE&quot;,&quot;TECHNOLOGY&quot;,&quot;TELEPHONE&quot;,&quot;TELEVISION&quot;,&quot;TELL&quot;,&quot;TEMPERATURE&quot;, &quot;TEND&quot;,&quot;TERM&quot;,&quot;TERMS&quot;,&quot;TERRIBLE&quot;,&quot;TEST&quot;,&quot;TEXT&quot;,&quot;THAN&quot;,&quot;THANK&quot;,&quot;THANKS&quot;,&quot;THAT&quot;, &quot;THE&quot;,&quot;THEATRE&quot;,&quot;THEIR&quot;,&quot;THEM&quot;,&quot;THEME&quot;,&quot;THEMSELVES&quot;,&quot;THEN&quot;,&quot;THEORY&quot;,&quot;THERE&quot;,&quot;THEREFORE&quot;, &quot;THESE&quot;,&quot;THEY&quot;,&quot;THIN&quot;,&quot;THING&quot;,&quot;THINK&quot;,&quot;THIS&quot;,&quot;THOSE&quot;,&quot;THOUGH&quot;,&quot;THOUGHT&quot;,&quot;THREAT&quot;, &quot;THREATEN&quot;,&quot;THROUGH&quot;,&quot;THROUGHOUT&quot;,&quot;THROW&quot;,&quot;THUS&quot;,&quot;TICKET&quot;,&quot;TIME&quot;,&quot;TINY&quot;,&quot;TITLE&quot;,&quot;TO&quot;, &quot;TODAY&quot;,&quot;TOGETHER&quot;,&quot;TOMORROW&quot;,&quot;TONE&quot;,&quot;TONIGHT&quot;,&quot;TOO&quot;,&quot;TOOL&quot;,&quot;TOOTH&quot;,&quot;TOP&quot;,&quot;TOTAL&quot;, &quot;TOTALLY&quot;,&quot;TOUCH&quot;,&quot;TOUR&quot;,&quot;TOWARDS&quot;,&quot;TOWN&quot;,&quot;TRACK&quot;,&quot;TRADE&quot;,&quot;TRADITION&quot;,&quot;TRADITIONAL&quot;,&quot;TRAFFIC&quot;, &quot;TRAIN&quot;,&quot;TRAINING&quot;,&quot;TRANSFER&quot;,&quot;TRANSPORT&quot;,&quot;TRAVEL&quot;,&quot;TREAT&quot;,&quot;TREATMENT&quot;,&quot;TREATY&quot;,&quot;TREE&quot;,&quot;TREND&quot;, &quot;TRIAL&quot;,&quot;TRIP&quot;,&quot;TROOP&quot;,&quot;TROUBLE&quot;,&quot;TRUE&quot;,&quot;TRUST&quot;,&quot;TRUTH&quot;,&quot;TRY&quot;,&quot;TURN&quot;,&quot;TWICE&quot;, &quot;TYPE&quot;,&quot;TYPICAL&quot;,&quot;UNABLE&quot;,&quot;UNDER&quot;,&quot;UNDERSTAND&quot;,&quot;UNDERSTANDING&quot;,&quot;UNDERTAKE&quot;,&quot;UNEMPLOYMENT&quot;,&quot;UNFORTUNATELY&quot;,&quot;UNION&quot;, &quot;UNIT&quot;,&quot;UNITED&quot;,&quot;UNIVERSITY&quot;,&quot;UNLESS&quot;,&quot;UNLIKELY&quot;,&quot;UNTIL&quot;,&quot;UP&quot;,&quot;UPON&quot;,&quot;UPPER&quot;,&quot;URBAN&quot;, &quot;US&quot;,&quot;USE&quot;,&quot;USED&quot;,&quot;USEFUL&quot;,&quot;USER&quot;,&quot;USUAL&quot;,&quot;USUALLY&quot;,&quot;VALUE&quot;,&quot;VARIATION&quot;,&quot;VARIETY&quot;, &quot;VARIOUS&quot;,&quot;VARY&quot;,&quot;VAST&quot;,&quot;VEHICLE&quot;,&quot;VERSION&quot;,&quot;VERY&quot;,&quot;VIA&quot;,&quot;VICTIM&quot;,&quot;VICTORY&quot;,&quot;VIDEO&quot;, &quot;VIEW&quot;,&quot;VILLAGE&quot;,&quot;VIOLENCE&quot;,&quot;VISION&quot;,&quot;VISIT&quot;,&quot;VISITOR&quot;,&quot;VITAL&quot;,&quot;VOICE&quot;,&quot;VOLUME&quot;,&quot;VOTE&quot;, &quot;WAGE&quot;,&quot;WAIT&quot;,&quot;WALK&quot;,&quot;WALL&quot;,&quot;WANT&quot;,&quot;WAR&quot;,&quot;WARM&quot;,&quot;WARN&quot;,&quot;WASH&quot;,&quot;WATCH&quot;, &quot;WATER&quot;,&quot;WAVE&quot;,&quot;WAY&quot;,&quot;WE&quot;,&quot;WEAK&quot;,&quot;WEAPON&quot;,&quot;WEAR&quot;,&quot;WEATHER&quot;,&quot;WEEK&quot;,&quot;WEEKEND&quot;, &quot;WEIGHT&quot;,&quot;WELCOME&quot;,&quot;WELFARE&quot;,&quot;WELL&quot;,&quot;WEST&quot;,&quot;WESTERN&quot;,&quot;WHAT&quot;,&quot;WHATEVER&quot;,&quot;WHEN&quot;,&quot;WHERE&quot;, &quot;WHEREAS&quot;,&quot;WHETHER&quot;,&quot;WHICH&quot;,&quot;WHILE&quot;,&quot;WHILST&quot;,&quot;WHITE&quot;,&quot;WHO&quot;,&quot;WHOLE&quot;,&quot;WHOM&quot;,&quot;WHOSE&quot;, &quot;WHY&quot;,&quot;WIDE&quot;,&quot;WIDELY&quot;,&quot;WIFE&quot;,&quot;WILD&quot;,&quot;WILL&quot;,&quot;WIN&quot;,&quot;WIND&quot;,&quot;WINDOW&quot;,&quot;WINE&quot;, &quot;WING&quot;,&quot;WINNER&quot;,&quot;WINTER&quot;,&quot;WISH&quot;,&quot;WITH&quot;,&quot;WITHDRAW&quot;,&quot;WITHIN&quot;,&quot;WITHOUT&quot;,&quot;WOMAN&quot;,&quot;WONDER&quot;, &quot;WONDERFUL&quot;,&quot;WOOD&quot;,&quot;WORD&quot;,&quot;WORK&quot;,&quot;WORKER&quot;,&quot;WORKING&quot;,&quot;WORKS&quot;,&quot;WORLD&quot;,&quot;WORRY&quot;,&quot;WORTH&quot;, &quot;WOULD&quot;,&quot;WRITE&quot;,&quot;WRITER&quot;,&quot;WRITING&quot;,&quot;WRONG&quot;,&quot;YARD&quot;,&quot;YEAH&quot;,&quot;YEAR&quot;,&quot;YES&quot;,&quot;YESTERDAY&quot;, &quot;YET&quot;,&quot;YOU&quot;,&quot;YOUNG&quot;,&quot;YOUR&quot;,&quot;YOURSELF&quot;,&quot;YOUTH&quot;};int main(){ for(int i=0;i&lt;1786;++i) { int sum=0,l=1,r=30; bool flag=false; for(int j=0;s[i][j];++j)sum+=s[i][j]-'A'+1; sum&lt;&lt;=1; while(l&lt;=r) { int mid=(l+r)&gt;&gt;1,tmp=mid*(mid+1); if(tmp==sum) { flag=true; break; } if(tmp&gt;sum)r=mid-1; else l=mid+1; } ans+=flag; } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/42/"},{"title":"【欧拉计划】43. Sub-string divisibility","text":"（本题取 $n=10$） 【思路】构造 $0 \\sim 9$ 全排列，然后合成十位数后判断即可，时间复杂度为 $\\mathcal O(n!10^{\\frac{n}{2}})$： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;const int p[]={2,3,5,7,11,13,17};long long ans;int a[10];bool vis[10];void dfs(int k){ if(k&gt;9) { bool flag=true; for(int i=1;i&lt;=7;++i) { int x=a[i]*100+a[i+1]*10+a[i+2]; if(x%p[i-1]) { flag=false; break; } } if(flag) { long long x=0; for(int i=0;i&lt;=9;++i)x=x*10+a[i]; ans+=x; } return; } for(int i=0;i&lt;=9;++i) { if(vis[i])continue; a[k]=i; vis[i]=true; dfs(k+1); vis[i]=false; }}int main(){ dfs(0); printf(&quot;%lld&quot;,ans); return 0;}","link":"/projecteuler/43/"},{"title":"【欧拉计划】41. Pandigital prime","text":"（本题取 $n=9$） 【思路】$\\mathcal O(n!)$ 构造全排列并判断是否为质数。由于 $n$ 较大，因此不宜使用欧拉筛。程序的时间复杂度为 $\\mathcal O(n!10^{\\frac{n}{2}})$： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;int ans,a[10];bool vis[10];bool prime(int x){ if(x&lt;2)return false; if(x==2||x==3||x==5)return true; if(x%2==0||x%3==0||x%5==0)return false; for(int a=7,b=11;a*a&lt;=x;a+=6,b+=6)if(x%a==0||x%b==0)return false; return true;}void dfs(int k,int n){ if(k&gt;n) { int x=0; for(int i=1;i&lt;=n;++i)x=x*10+a[i]; if(prime(x)&amp;&amp;x&gt;ans)ans=x; return; } for(int i=1;i&lt;=n;++i) { if(vis[i])continue; a[k]=i; vis[i]=true; dfs(k+1,n); vis[i]=false; }}int main(){ for(int i=1;i&lt;=9;++i) { memset(vis,false,sizeof(vis)); dfs(1,i); } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/41/"},{"title":"【欧拉计划】44. Pentagon numbers","text":"【思路】选定一个足够大的项数上限 $n$，然后 $\\mathcal O(n^2)$ 枚举，判断的时候采用二分，总体时间复杂度为 $\\mathcal O(n^2 \\log n)$： 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int ans=1&lt;&lt;30;bool check(int l,int r,int x){ while(l&lt;=r) { int mid=(l+r)&gt;&gt;1,tmp=mid*(3*mid-1); if(tmp==x)return true; if(tmp&gt;x)r=mid-1; else l=mid+1; } return false;}int main(){ for(int i=1;i&lt;=10000;++i) { for(int j=1;j&lt;i;++j) { int pi=i*(i*3-1),pj=j*(j*3-1); if(check(1,i&lt;&lt;1,pi+pj)&amp;&amp;check(1,i,pi-pj)&amp;&amp;pi-pj&lt;ans)ans=pi-pj; } } printf(&quot;%d&quot;,ans&gt;&gt;1); return 0;}","link":"/projecteuler/44/"},{"title":"【欧拉计划】45. Triangular, pentagonal, and hexagonal","text":"【思路】不难发现三角形数必然是六边形数，因而我们可以从第 $144$ 项六边形数开始枚举，采用二分找到第一个既是五边形数又是六边形数的整数： 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;math.h&gt;bool check(long long l,long long r,long long x){ while(l&lt;=r) { long long mid=(l+r)&gt;&gt;1,tmp=mid*(mid*3-1); if(tmp==x)return true; if(tmp&gt;x)r=mid-1; else l=mid+1; } return false;}int main(){ for(int i=144;;++i) { long long x=2LL*i*((i&lt;&lt;1)-1); if(check(1,sqrt(x),x)) { printf(&quot;%lld&quot;,x&gt;&gt;1); return 0; } } return 0;}","link":"/projecteuler/45/"},{"title":"【欧拉计划】46. Goldbach&#39;s other conjecture","text":"【思路】取一个足够大的上限 $n$，确保最终答案不超过 $n$。我们可以采用欧拉筛得到所有的质数和合数表。注意合数不是按照顺序得到的，需要排序。 接着我们枚举所有在范围内的合数，二分找到不超过它的最大质数，然后判断二者之差是否能表示乘一个完全平方数的两倍即可。 总体时间复杂度为 $\\mathcal O(n \\log n)$： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000;int prime[maxn],composite[maxn];bool vis[maxn];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i*prime[j]&amp;1)composite[++composite[0]]=i*prime[j]; if(i%prime[j]==0)break; } } sort(composite+1,composite+composite[0]+1);}int binary(int l,int r,int x){ while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(prime[mid]&gt;x)r=mid-1; else l=mid+1; } return r;}int main(){ euler(); for(int i=1;i&lt;=composite[0];++i) { int x=composite[i]; bool flag=false; for(int j=binary(1,prime[0],x);j&gt;1;--j) { int y=prime[j],z=sqrt((x-y)&gt;&gt;1); if(z*z&lt;&lt;1==x-y) { flag=true; break; } } if(!flag) { printf(&quot;%d&quot;,x); return 0; } } return 0;}","link":"/projecteuler/46/"},{"title":"【欧拉计划】47. Distinct primes factors","text":"【思路】与 Problem 46 类似，我们先取一个足够大的上限 $n$，先欧拉筛得到质数表和合数表。 在判断合数是否有四个不同的质因数时，我们同样可以采取二分，找到不超过它的最大质数，然后倒着循环，统计出它的不同质因数个数即可。 总体时间复杂度为 $\\mathcal O(n \\log n)$： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000000;int prime[maxn],composite[maxn];bool vis[maxn];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; composite[++composite[0]]=i*prime[j]; if(i%prime[j]==0)break; } } sort(composite+1,composite+composite[0]+1);}int binary(int l,int r,int x){ while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(prime[mid]&gt;x)r=mid-1; else l=mid+1; } return r-1;}bool check(int x){ if(!vis[x])return false; int cnt=0,tmp=0; for(int i=binary(1,x,x);i;--i) { bool flag=false; while(x%prime[i]==0) { flag=true; x/=prime[i]; } cnt+=flag; if(cnt==4)return x==1; } return false;}int main(){ euler(); for(int i=1;i&lt;=composite[0];++i) { int x=composite[i]; if(check(x)&amp;&amp;check(x+1)&amp;&amp;check(x+2)&amp;&amp;check(x+3)) { printf(&quot;%d&quot;,x); return 0; } } return 0;}","link":"/projecteuler/47/"},{"title":"【欧拉计划】49. Prime permutations","text":"【思路】先欧拉筛，然后枚举所有四位数的所有排列，最后去重后检验即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=10000;int cnt,prime[maxn],a[5],b[5],ans[5];bool vis[maxn],flag[5];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } }}void dfs(int k){ if(k&gt;4) { int x=0; for(int i=1;i&lt;=4;++i)x=x*10+a[b[i]]; if(!vis[x])ans[++cnt]=x; return; } for(int i=1;i&lt;=4;++i) { if(flag[i])continue; b[k]=i; flag[i]=true; dfs(k+1); flag[i]=false; }}int main(){ euler(); for(int i=1000;i&lt;10000;++i) { a[1]=i/1000; a[2]=i/100%10; a[3]=i/10%10; a[4]=i%10; if(!a[1]||!a[2]||!a[3]||!a[4])continue; memset(flag,false,sizeof(flag)); cnt=0; dfs(1); sort(ans+1,ans+cnt+1); cnt=unique(ans+1,ans+cnt+1)-ans-1; for(int j=1;j&lt;=cnt;++j) { if(ans[j]==1487)continue; for(int k=j+1;k&lt;=cnt;++k) { for(int l=k+1;l&lt;=cnt;++l) { if(ans[l]-ans[k]==ans[k]-ans[j]) { printf(&quot;%d%d%d&quot;,ans[j],ans[k],ans[l]); return 0; } } } } } return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=10000;int cnt,prime[maxn],a[5],ans[5];bool vis[maxn];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } }}int main(){ euler(); for(int i=1000;i&lt;10000;++i) { a[1]=i/1000; a[2]=i/100%10; a[3]=i/10%10; a[4]=i%10; if(!a[1]||!a[2]||!a[3]||!a[4])continue; cnt=0; do { int x=0; for(int i=1;i&lt;=4;++i)x=x*10+a[i]; if(!vis[x])ans[++cnt]=x; }while(next_permutation(a+1,a+5)); sort(ans+1,ans+cnt+1); cnt=unique(ans+1,ans+cnt+1)-ans-1; for(int j=1;j&lt;=cnt;++j) { if(ans[j]==1487)continue; for(int k=j+1;k&lt;=cnt;++k) { for(int l=k+1;l&lt;=cnt;++l) { if(ans[l]-ans[k]==ans[k]-ans[j]) { printf(&quot;%d%d%d&quot;,ans[j],ans[k],ans[l]); return 0; } } } } } return 0;}","link":"/projecteuler/49/"},{"title":"【欧拉计划】48. Self powers","text":"（本题取 $n=1000$，$m=10^{10}$) 【思路】Python 直接套 pow： 1234mod = int(1e10)ans = 0for i in range(1, 1001): ans = (ans + pow(i, i, mod)) % modprint(ans) 也可以使用快速幂+龟速乘，时间复杂度为 $\\mathcal O(n \\log n \\log m)$。当然快速乘可优化到 $\\mathcal O(n \\log n)$： 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;const long long mod=1e10;long long ans;long long mul(long long a,long long b){ long long s=0; while(b) { if(b&amp;1)s=(s+a)%mod; a=(a&lt;&lt;1)%mod; b&gt;&gt;=1; } return s;}long long power(long long a,long long b){ long long s=1; while(b) { if(b&amp;1)s=mul(s,a)%mod; a=mul(a,a)%mod; b&gt;&gt;=1; } return s;}int main(){ for(int i=1;i&lt;=1000;++i)ans+=power(i,i); printf(&quot;%lld&quot;,ans%mod); return 0;}","link":"/projecteuler/48/"},{"title":"【欧拉计划】51. Prime digit replacements","text":"（本题取 $n=1000000$） 【思路】欧拉筛初始化后，对位数及空缺位置进行枚举，再分别判断 $0 \\sim 9$ 填入之后是否为质数即可。 其中，在枚举方面，我们可以在 $0 \\sim 9$ 之外新建一个特殊位 $10$，表示这个位置是待替换的。这样，我们的程序就无形之间被简化了。 总体时间复杂度为 $\\mathcal O(n)$： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000000;int a[7],ans=1&lt;&lt;30,prime[maxn];bool vis[maxn];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } }}int main(){ euler(); for(int i=2,j=11;i&lt;=6;++i,j*=11) { for(int k=j;k&lt;j*11;++k) { int kk=k; bool flag=false; for(int l=i;l;--l) { a[l]=kk%11; flag|=(a[l]==10); kk/=11; } if(!flag)continue; int cnt=0,x; for(int l=9;l&gt;=0;--l) { if(!l&amp;&amp;a[1]==10)break; x=0; for(int m=1;m&lt;=i;++m)x=(x&lt;&lt;3)+(x&lt;&lt;1)+(a[m]==10?l:a[m]); cnt+=(!vis[x]); } if(cnt==8)ans=min(ans,x); } if(ans!=1&lt;&lt;30)break; } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/51/"},{"title":"【欧拉计划】5. Smallest multiple","text":"（本题取 $n=20$） 【思路】本题只需求 $1 \\sim 20$ 的最小公倍数即可。 而 $\\text{lcm}(a,b)=\\dfrac{ab}{\\gcd(a,b)}$，因此问题转化成了求 $\\gcd$（为了防止爆 int 可以先除后乘或者直接开 long long）。时间复杂度为 $\\mathcal O(\\log n)$： 12345678910111213141516171819#include&lt;stdio.h&gt;int ans=1;int gcd(int a,int b){ while(b) { int t=b; b=a%b; a=t; } return a;}int lcm(int a,int b){return a/gcd(a,b)*b;}int main(){ for(int i=1;i&lt;=20;++i)ans=lcm(ans,i); printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/5/"},{"title":"【欧拉计划】52. Permuted multiples","text":"（本题取 $n=142857$） 【思路】从 $1$ 开始向更大的数进行枚举，利用 Python 整型字符串自由转换的功能进行判断，找到符合题意的数即可输出。 总体时间复杂度为 $\\mathcal O(n)$： 12345678910111213141516171819i = 1while True: a = [] for j in range(1, 7): s = [] k = str(i * j) for c in k: s.append(c) s.sort() a.append(s) flag = True for j in range(1, 6): if a[j] != a[j - 1]: flag = False break if flag: print(i) exit() i += 1","link":"/projecteuler/52/"},{"title":"【欧拉计划】50. Consecutive prime sum","text":"（本题取 $n=1000000$，$m$ 为不超过 $n$ 的质数个数） 【思路】欧拉筛初始化后，采用前缀和预处理，一旦超过 $n$ 就不再继续做下去，这样会减小后续枚举范围。 紧接着在所有质数中枚举作为起始质数，然后取连续的 $maxl+1$ 个质数得到它们的和（规定 $maxl$ 为当前最多质数的个数），再判断是否为质数即可。 总体时间复杂度为 $\\mathcal O(n+m^2)$： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;const int maxn=1000000;int cnt,ans,maxl,prime[maxn];long long s[maxn];bool vis[maxn];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } }}int main(){ euler(); s[1]=prime[1]; for(int i=2;i&lt;=prime[0];++i) { s[i]=s[i-1]+prime[i]; if(s[i]&gt;1000000) { cnt=i; break; } } for(int i=1;i&lt;=cnt;++i) { int sum=0; for(int j=i+maxl+1;j&lt;=cnt&amp;&amp;s[j]-s[i-1]&lt;=maxn;++j) { if(!vis[s[j]-s[i-1]]) { maxl=j-i; ans=s[j]-s[i-1]; } } } printf(&quot;%d&quot;,ans); return 0;}","link":"/projecteuler/50/"},{"title":"【欧拉计划】6. Sum square difference","text":"（本题取 $n=100$） 【思路】先求平方的和，再求和的平方，最后相减。时间复杂度为 $\\mathcal O(n)$： 123456789#include&lt;stdio.h&gt;int sum;int square(int x){return x*x;}int main(){ for(int i=1;i&lt;=100;++i)sum+=square(i); printf(&quot;%d&quot;,square((1+100)*100&gt;&gt;1)-sum); return 0;}","link":"/projecteuler/6/"},{"title":"【欧拉计划】8. Largest product in a series","text":"（本题取 $n=1000$，m=13$） 【思路】$\\mathcal O(nm)$ 暴力枚举： 1234567891011121314#include&lt;stdio.h&gt;const char *s=&quot;7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450&quot;;long long ans;int main(){ for(int i=0;i&lt;988;++i) { long long x=1; for(int j=i;j&lt;i+13;++j)x*=(s[j]^48); if(x&gt;ans)ans=x; } printf(&quot;%lld&quot;,ans); return 0;}","link":"/projecteuler/8/"},{"title":"【欧拉计划】7. 10001st prime","text":"（本题取 $n=\\text{prime}_{10001}=104743$） 【思路】使用 $\\mathcal O(n)$ 的欧拉筛： 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;const int maxn=200000;int prime[maxn];bool vis[maxn];int euler(int x){ for(int i=2;i&lt;=maxn&amp;&amp;prime[0]&lt;x;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0]&amp;&amp;prime[0]&lt;x;++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } } return prime[x];}int main(){ printf(&quot;%d&quot;,euler(10001)); return 0;}","link":"/projecteuler/7/"},{"title":"【欧拉计划】9. Special Pythagorean triplet","text":"（本题取 $n=1000$） 【思路】$\\mathcal O(n^3)$ 分别枚举 $a,b,c$ 并判断。 【优化】由于 $a,b,c$ 中的其中一个值可以由另外两个得到，因此可省去第三重循环，时间复杂度优化为 $\\mathcal O(n^2)$： 1234567891011121314151617#include&lt;stdio.h&gt;int main(){ for(int a=0;a&lt;1000;++a) { for(int b=a+1;b&lt;1000;++b) { int c=1000-a-b; if(b&lt;c&amp;&amp;a*a+b*b==c*c) { printf(&quot;%d&quot;,a*b*c); return 0; } } } return 0;}","link":"/projecteuler/9/"},{"title":"欧拉计划","text":"所有代码归档压缩包完整版题解1. Multiples of 3 and 52. Even Fibonacci numbers3. Largest prime factor4. Largest palindrome product5. Smallest multiple6. Sum square difference7. 10001st prime8. Largest product in a series9. Special Pythagorean triplet10. Summation of primes11. Largest product in a grid12. Highly divisible triangular number13. Large sum14. Longest Collatz sequence15. Lattice paths16. Power digit sum17. Number letter counts18. Maximum path sum I19. Counting Sundays20. Factorial digit sum21. Amicable numbers22. Names scores23. Non-abundant sums24. Lexicographic permutations25. 1000-digit Fibonacci number26. Reciprocal cycles27. Quadratic primes28. Number spiral diagonals29. Distinct powers30. Digit fifth powers31. Coin sums32. Pandigital products33. Digit cancelling fractions34. Digit factorials35. Circular primes36. Double-base palindromes37. Truncatable primes38. Pandigital multiples39. Integer right triangles40. Champernowne’s constant41. Pandigital prime42. Coded triangle numbers43. Sub-string divisibility44. Pentagon numbers45. Triangular, pentagonal, and hexagonal46. Goldbach’s other conjecture47. Distinct primes factors48. Self powers49. Prime permutations50. Consecutive prime sum51. Prime digit replacements52. Permuted multiples","link":"/projecteuler/euler/"},{"title":"欧拉计划完整版题解","text":"Problem 1: Multiples of 3 and 5（本题取 $n=1000$） 【思路】$\\mathcal O(n)$ 枚举所有能被 $3$ 和被 $5$ 整除的数，最后把能被 $15$ 整除的数减掉： 12345678910#include&lt;stdio.h&gt;int ans;int main(){ for(int i=3;i&lt;1000;i+=3)ans+=i; for(int i=5;i&lt;1000;i+=5)ans+=i; for(int i=15;i&lt;1000;i+=15)ans-=i; printf(&quot;%d&quot;,ans); return 0;} 【优化】利用等差数列求和公式 $\\mathcal O(1)$ 求解： 12345678#include&lt;stdio.h&gt;int ans;int main(){ ans=((3+999)*333&gt;&gt;1)+((5+995)*199&gt;&gt;1)-((15+990)*66&gt;&gt;1); printf(&quot;%d&quot;,ans); return 0;} Problem 2: Even Fibonacci numbers（本题取 $n=\\lfloor \\text{fib}^{-1}(4000000) \\rfloor=33$） 【思路】运用斐波那契数列递推公式 $a_i=a_{i-1}+a_{i-2}$ 进行递推，超过 $4000000$ 就中断。最后统计其中偶数的和即可。时空复杂度均为 $\\mathcal O(n)$。 【优化 $1$】采用滚动变量，将空间复杂度优化到 $\\mathcal O(1)$： 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int last,now,ans;int main(){ last=now=1; while(true) { int t=last; last=now; now+=t; if(now&gt;4000000)break; if(now%2==0)ans+=now; } printf(&quot;%d&quot;,ans); return 0;} 【优化 $2$】采用矩阵乘法，构造初始矩阵为： $$\\begin{bmatrix}1 &amp; 1 \\cr0 &amp; 0 \\cr\\end{bmatrix}$$ 每次需要乘上的矩阵为： $$\\begin{bmatrix}1 &amp; 1 \\cr1 &amp; 0 \\cr\\end{bmatrix}$$ 这样不停地累乘，只要矩阵第 $1$ 行第 $1$ 列的元素（即数列的值）超过 $4000000$，就直接中断： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;int ans;struct matrix{ long long a[3][3]; matrix operator*(const matrix &amp;x)const { matrix res; memset(res.a,0,sizeof(res.a)); for(int k=1;k&lt;=2;++k) { for(int i=1;i&lt;=2;++i) { for(int j=1;j&lt;=2;++j) { res.a[i][j]+=a[i][k]*x.a[k][j]; } } } return res; }}m,base;int main(){ m.a[1][1]=m.a[1][2]=1; base.a[1][1]=base.a[1][2]=base.a[2][1]=1; while(m.a[1][1]&lt;=4000000) { if(m.a[1][1]%2==0)ans+=m.a[1][1]; m=m*base; } printf(&quot;%d&quot;,ans); return 0;} 做一次矩阵乘法的时间复杂度为 $\\mathcal O(1)$，需要做 $n$ 次，因此时间复杂度仍为 $\\mathcal O(n)$。矩阵的大小为常数，因此空间复杂度为 $\\mathcal O(1)$。 由于没有要求具体求出数列中一个元素的值，因此矩阵并没有真正起到优化作用。 Problem 3: Largest prime factor（本题取 $n=600851475143$） 【思路】在区间 $[2,n]$ 内倒序枚举 $n$ 的所有质因数，输出第一个遍历到的。时空复杂度分别为 $\\mathcal O(n \\sqrt n)$，$\\mathcal O(1)$。 【优化 $1$】在原思路的基础上使用埃氏筛，时间复杂度优化为 $\\mathcal O(n \\ln \\ln n+n)$；使用欧拉筛可优化为 $\\mathcal O(n)$。 【优化 $2$】在原思路的基础上将区间缩小为 $[2,\\sqrt n]$，时间复杂度优化为 $\\mathcal O(n)$。 【优化 $3$】结合优化 $1,2$，时间复杂度可进一步优化至 $\\mathcal O(\\sqrt n)$（后面研究质数时不再提及质数判断法或埃氏筛，一律只保留欧拉筛）。 【优化 $4$】在【优化 $3$】的基础上，将循环改为正序。这样能减小时间复杂度的常数，同时将空间复杂度降为 $\\mathcal O(1)$： 12345678910111213141516171819#include&lt;stdio.h&gt;long long n=600851475143;int main(){ for(long long i=3;i*i&lt;=n;i+=2) { while(n%i==0) { n/=i; if(n==1) { printf(&quot;%lld&quot;,i); return 0; } } } printf(&quot;%lld&quot;,n); return 0;} Problem 4: Largest palindrome product（本题取 $d=10$，$n=1000-100=900$） 【思路】显然满足要求的最大回文数一定为六位数。因此我们只需要三重循环枚举前三位，然后通过回文数性质得到后三位，从而得到一个六位数。最后枚举是否能表示成两个三位数乘积即可。时间复杂度为 $\\mathcal O(d^3n)$： 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int main(){ for(int i=9;i;--i) { for(int j=9;j&gt;=0;--j) { for(int k=9;k&gt;=0;--k) { int x=i*100000+j*10000+k*1000+k*100+j*10+i; for(int p=100;p&lt;=999;++p) { if(x%p)continue; int q=x/p; if(q&gt;=100&amp;&amp;q&lt;1000) { printf(&quot;%d&quot;,x); return 0; } } } } } return 0;} Problem 5: Smallest multiple（本题取 $n=20$） 【思路】本题只需求 $1 \\sim 20$ 的最小公倍数即可。 而 $\\text{lcm}(a,b)=\\dfrac{ab}{\\gcd(a,b)}$，因此问题转化成了求 $\\gcd$（为了防止爆 int 可以先除后乘或者直接开 long long）。时间复杂度为 $\\mathcal O(\\log n)$： 12345678910111213141516171819#include&lt;stdio.h&gt;int ans=1;int gcd(int a,int b){ while(b) { int t=b; b=a%b; a=t; } return a;}int lcm(int a,int b){return a/gcd(a,b)*b;}int main(){ for(int i=1;i&lt;=20;++i)ans=lcm(ans,i); printf(&quot;%d&quot;,ans); return 0;} Problem 6: Sum square difference（本题取 $n=100$） 【思路】先求平方的和，再求和的平方，最后相减。时间复杂度为 $\\mathcal O(n)$： 123456789#include&lt;stdio.h&gt;int sum;int square(int x){return x*x;}int main(){ for(int i=1;i&lt;=100;++i)sum+=square(i); printf(&quot;%d&quot;,square((1+100)*100&gt;&gt;1)-sum); return 0;} Problem 7: 10001st prime（本题取 $n=\\text{prime}_{10001}=104743$） 【思路】使用 $\\mathcal O(n)$ 的欧拉筛： 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;const int maxn=200000;int prime[maxn];bool vis[maxn];int euler(int x){ for(int i=2;i&lt;=maxn&amp;&amp;prime[0]&lt;x;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0]&amp;&amp;prime[0]&lt;x;++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } } return prime[x];}int main(){ printf(&quot;%d&quot;,euler(10001)); return 0;} Problem 8: Largest product in a series（本题取 $n=1000$，m=13$） 【思路】$\\mathcal O(nm)$ 暴力枚举： 1234567891011121314#include&lt;stdio.h&gt;const char *s=&quot;7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450&quot;;long long ans;int main(){ for(int i=0;i&lt;988;++i) { long long x=1; for(int j=i;j&lt;i+13;++j)x*=(s[j]^48); if(x&gt;ans)ans=x; } printf(&quot;%lld&quot;,ans); return 0;} Problem 9: Special Pythagorean triplet（本题取 $n=1000$） 【思路】$\\mathcal O(n^3)$ 分别枚举 $a,b,c$ 并判断。 【优化】由于 $a,b,c$ 中的其中一个值可以由另外两个得到，因此可省去第三重循环，时间复杂度优化为 $\\mathcal O(n^2)$： 1234567891011121314151617#include&lt;stdio.h&gt;int main(){ for(int a=0;a&lt;1000;++a) { for(int b=a+1;b&lt;1000;++b) { int c=1000-a-b; if(b&lt;c&amp;&amp;a*a+b*b==c*c) { printf(&quot;%d&quot;,a*b*c); return 0; } } } return 0;} Problem 10: Summation of primes（本题取 $n=2000000$） 【思路】$\\mathcal O(n)$ 欧拉筛： 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;const int maxn=2000000;int prime[maxn];bool vis[maxn];long long ans;void euler(){ for(int i=2;i&lt;=maxn;++i) { if(!vis[i]) { prime[++prime[0]]=i; ans+=i; } for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } }}int main(){ euler(); printf(&quot;%lld\\n&quot;,ans); return 0;} Problem 11: Largest product in a grid（本题取 $n=20$，$m=4$，$d=8$） 【思路】先 $O(n^2)$ 枚举起始数字，然后 $\\mathcal O(md)$ 枚举所有方向的所有数字。时间复杂度为 $\\mathcal O(n^2md)$： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;const int dx[]={-1,-1,-1,0,0,1,1,1},dy[]={-1,0,1,-1,1,-1,0,1};int ans;const int matrix[20][20]={ {8,02,22,97,38,15,00,40,00,75,04,05,07,78,52,12,50,77,91,8}, {49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48,04,56,62,00}, {81,49,31,73,55,79,14,29,93,71,40,67,53,88,30,03,49,13,36,65}, {52,70,95,23,04,60,11,42,69,24,68,56,01,32,56,71,37,02,36,91}, {22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80}, {24,47,32,60,99,03,45,02,44,75,33,53,78,36,84,20,35,17,12,50}, {32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70}, {67,26,20,68,02,62,12,20,95,63,94,39,63,8,40,91,66,49,94,21}, {24,55,58,05,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72}, {21,36,23,9,75,00,76,44,20,45,35,14,00,61,33,97,34,31,33,95}, {78,17,53,28,22,75,31,67,15,94,03,80,04,62,16,14,9,53,56,92}, {16,39,05,42,96,35,31,47,55,58,88,24,00,17,54,24,36,29,85,57}, {86,56,00,48,35,71,89,07,05,44,44,37,44,60,21,58,51,54,17,58}, {19,80,81,68,05,94,47,69,28,73,92,13,86,52,17,77,04,89,55,40}, {04,52,8,83,97,35,99,16,07,97,57,32,16,26,26,79,33,27,98,66}, {88,36,68,87,57,62,20,72,03,46,33,67,46,55,12,32,63,93,53,69}, {04,42,16,73,38,25,39,11,24,94,72,18,8,46,29,32,40,62,76,36}, {20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74,04,36,16}, {20,73,35,29,78,31,90,01,74,31,49,71,48,86,81,16,23,57,05,54}, {01,70,54,71,83,51,54,69,16,92,33,48,61,43,52,01,89,19,67,48}};int main(){ for(int i=0;i&lt;20;++i) { for(int j=0;j&lt;20;++j) { for(int k=0;k&lt;8;++k) { int mx=i+dx[k]*3,my=j+dy[k]*3,fac=matrix[i][j]; if(mx&lt;0||my&lt;0||mx&gt;=20||my&gt;=20)continue; for(int l=0,lx=i,ly=j;l&lt;3;++l) { int nx=lx+dx[k],ny=ly+dy[k]; fac*=matrix[nx][ny]; lx=nx,ly=ny; } if(fac&gt;ans)ans=fac; } } } printf(&quot;%d&quot;,ans); return 0;} Problem 12: Highly divisible triangular number（本题取 $n$ 为第一个因数个数大于 $500$ 的三角形数 $76576500$） 【思路】依次枚举三角形数，每次 $\\mathcal O(n)$ 求所有因数，因数个数大于 $500$ 就中断。时间复杂度为 $\\mathcal O(n^2)$。 【优化】如果整数 $x$ 有因数 $i$，那么 $\\dfrac{x}{i}$ 必然也是它的因数。因此可以把统计因数个数的时间复杂度降到 $\\mathcal O(\\sqrt n)$，总体优化到 $\\mathcal O(n \\sqrt n)$： 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int fac(int x){ if(x==1)return 1; int s=2; for(int i=2;i*i&lt;=x;++i) { if(x%i==0) { ++s; if(i*i!=x)++s; } } return s;}int main(){ for(int i=1,x=1;;++i,x+=i) { if(fac(x)&gt;500) { printf(&quot;%d&quot;,x); return 0; } } return 0;} Problem 13: Large sum【思路】C/C++ 应用高精度，但 Python 可直接计算。同时还可以利用整型和字符串之间的转换和子串功能求解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107a = [ 37107287533902102798797998220837590246510135740250, 46376937677490009712648124896970078050417018260538, 74324986199524741059474233309513058123726617309629, 91942213363574161572522430563301811072406154908250, 23067588207539346171171980310421047513778063246676, 89261670696623633820136378418383684178734361726757, 28112879812849979408065481931592621691275889832738, 44274228917432520321923589422876796487670272189318, 47451445736001306439091167216856844588711603153276, 70386486105843025439939619828917593665686757934951, 62176457141856560629502157223196586755079324193331, 64906352462741904929101432445813822663347944758178, 92575867718337217661963751590579239728245598838407, 58203565325359399008402633568948830189458628227828, 80181199384826282014278194139940567587151170094390, 35398664372827112653829987240784473053190104293586, 86515506006295864861532075273371959191420517255829, 71693888707715466499115593487603532921714970056938, 54370070576826684624621495650076471787294438377604, 53282654108756828443191190634694037855217779295145, 36123272525000296071075082563815656710885258350721, 45876576172410976447339110607218265236877223636045, 17423706905851860660448207621209813287860733969412, 81142660418086830619328460811191061556940512689692, 51934325451728388641918047049293215058642563049483, 62467221648435076201727918039944693004732956340691, 15732444386908125794514089057706229429197107928209, 55037687525678773091862540744969844508330393682126, 18336384825330154686196124348767681297534375946515, 80386287592878490201521685554828717201219257766954, 78182833757993103614740356856449095527097864797581, 16726320100436897842553539920931837441497806860984, 48403098129077791799088218795327364475675590848030, 87086987551392711854517078544161852424320693150332, 59959406895756536782107074926966537676326235447210, 69793950679652694742597709739166693763042633987085, 41052684708299085211399427365734116182760315001271, 65378607361501080857009149939512557028198746004375, 35829035317434717326932123578154982629742552737307, 94953759765105305946966067683156574377167401875275, 88902802571733229619176668713819931811048770190271, 25267680276078003013678680992525463401061632866526, 36270218540497705585629946580636237993140746255962, 24074486908231174977792365466257246923322810917141, 91430288197103288597806669760892938638285025333403, 34413065578016127815921815005561868836468420090470, 23053081172816430487623791969842487255036638784583, 11487696932154902810424020138335124462181441773470, 63783299490636259666498587618221225225512486764533, 67720186971698544312419572409913959008952310058822, 95548255300263520781532296796249481641953868218774, 76085327132285723110424803456124867697064507995236, 37774242535411291684276865538926205024910326572967, 23701913275725675285653248258265463092207058596522, 29798860272258331913126375147341994889534765745501, 18495701454879288984856827726077713721403798879715, 38298203783031473527721580348144513491373226651381, 34829543829199918180278916522431027392251122869539, 40957953066405232632538044100059654939159879593635, 29746152185502371307642255121183693803580388584903, 41698116222072977186158236678424689157993532961922, 62467957194401269043877107275048102390895523597457, 23189706772547915061505504953922979530901129967519, 86188088225875314529584099251203829009407770775672, 11306739708304724483816533873502340845647058077308, 82959174767140363198008187129011875491310547126581, 97623331044818386269515456334926366572897563400500, 42846280183517070527831839425882145521227251250327, 55121603546981200581762165212827652751691296897789, 32238195734329339946437501907836945765883352399886, 75506164965184775180738168837861091527357929701337, 62177842752192623401942399639168044983993173312731, 32924185707147349566916674687634660915035914677504, 99518671430235219628894890102423325116913619626622, 73267460800591547471830798392868535206946944540724, 76841822524674417161514036427982273348055556214818, 97142617910342598647204516893989422179826088076852, 87783646182799346313767754307809363333018982642090, 10848802521674670883215120185883543223812876952786, 71329612474782464538636993009049310363619763878039, 62184073572399794223406235393808339651327408011116, 66627891981488087797941876876144230030984490851411, 60661826293682836764744779239180335110989069790714, 85786944089552990653640447425576083659976645795096, 66024396409905389607120198219976047599490197230297, 64913982680032973156037120041377903785566085089252, 16730939319872750275468906903707539413042652315011, 94809377245048795150954100921645863754710598436791, 78639167021187492431995700641917969777599028300699, 15368713711936614952811305876380278410754449733078, 40789923115535562561142322423255033685442488917353, 44889911501440648020369068063960672322193204149535, 41503128880339536053299340368006977710650566631954, 81234880673210146739058568557934581403627822703280, 82616570773948327592232845941706525094512325230608, 22918802058777319719839450180888072429661980811197, 77158542502016545090413245809786882778948721859617, 72107838435069186155435662884062257473692284509516, 20849603980134001723930671666823555245252804609722, 53503534226472524250874054075591789781264330331690]s = 0for i in range(100): s += a[i]ans = str(s)[0: 10]print(ans) Problem 14: Longest Collatz sequence（本题取 $n=1000000$，规定 $\\text{col}_n$ 为 $n$ 的序列长度） 【思路】直接 $\\mathcal O(n \\max {\\text{col}_i})$ 求解： 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int ans,maxn;int main(){ for(int i=1;i&lt;=1000000;++i) { int x=1; long long t=i; while(t!=1) { if(t&amp;1)t=t*3+1; else t&gt;&gt;=1; ++x; } if(x&gt;maxn) { ans=i; maxn=x; } } printf(&quot;%d&quot;,ans); return 0;} 【优化】采用记忆化减小常数： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;int ans,f[1000001];int main(){ for(int i=1;i&lt;=1000000;++i) { if(!f[i]) { f[i]=1; long long t=i; int a[1001]={}; while(t!=1) { if(t&amp;1)t=t*3+1; else t&gt;&gt;=1; ++f[i]; if(t&lt;=1000000) { a[f[i]]=t; if(f[t]) { f[i]+=f[t]-1; break; } } } for(int j=2;j&lt;=f[i];++j) { if(a[j]) { f[a[j]]=f[i]-j+1; } } } if(f[i]&gt;f[ans])ans=i; } printf(&quot;%d&quot;,ans); return 0;} Problem 15: Lattice paths（本题取 $n=20$） 【思路】$\\mathcal O(n^2)$ DP 即可： 123456789101112131415#include&lt;stdio.h&gt;long long f[21][21];int main(){ for(int i=0;i&lt;=20;++i)f[0][i]=f[i][0]=1; for(int i=1;i&lt;=20;++i) { for(int j=1;j&lt;=20;++j) { f[i][j]=f[i][j-1]+f[i-1][j]; } } printf(&quot;%lld&quot;,f[20][20]); return 0;} Problem 16: Power digit sum【思路】Python 可简单模拟，但在 C/C++ 中需用高精度： 12345s = str(1 &lt;&lt; 1000)ans = 0for i in s: ans += int(i)print(ans) Problem 17: Number letter counts（本题取 $n=1000$） 【思路】本题细节较多，可先预处理一些数的字母个数，这样后面的数就可以由前面递推而来。时间复杂度为 $\\mathcal O(n)$。 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int ans,a[1001]={0,3,3,5,4,4,3,5,5,4,3,6,6,8,8,7,7,9,8,8};void init(){ a[20]=a[30]=6; a[40]=a[50]=a[60]=5; a[70]=7; a[80]=a[90]=6; a[1000]=11; for(int i=20;i&lt;100;++i) { if(i%10==0)continue; a[i]=a[i/10*10]+a[i%10]; }}int main(){ init(); for(int i=1;i&lt;=1000;++i) { if(a[i])ans+=a[i]; else if(i%100)ans+=a[i/100]+10+a[i%100]; else ans+=a[i/100]+7; } printf(&quot;%d&quot;,ans); return 0;} Problem 18: Maximum path sum I（本题取 $n=16$） 【思路】暴力 DFS，时间复杂度为 $\\mathcal O(2^n)$。 【优化】采用 $\\mathcal O(n^2)$ 的 DP： 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;int dp[16][16],ans;int max(int a,int b){return a&gt;b?a:b;}const int matrix[16][16]={ {0}, {0,75}, {0,95,64}, {0,17,47,82}, {0,18,35,87,10}, {0,20,04,82,47,65}, {0,19,01,23,75,03,34}, {0,88,02,77,73,07,63,67}, {0,99,65,04,28,06,16,70,92}, {0,41,41,26,56,83,40,80,70,33}, {0,41,48,72,33,47,32,37,16,94,29}, {0,53,71,44,65,25,43,91,52,97,51,14}, {0,70,11,33,28,77,73,17,78,39,68,17,57}, {0,91,71,52,38,17,14,91,43,58,50,27,29,48}, {0,63,66,04,68,89,53,67,30,73,16,69,87,40,31}, {0,04,62,98,27,23,9,70,98,73,93,38,53,60,04,23}};int main(){ for(int i=1;i&lt;=15;++i) { for(int j=1;j&lt;=i;++j) { dp[i][j]=max(dp[i-1][j-1],dp[i-1][j])+matrix[i][j]; } } for(int i=1;i&lt;=15;++i)ans=max(ans,dp[15][i]); printf(&quot;%d&quot;,ans); return 0;} Problem 19: Counting Sundays【思路】按照题意模拟即可： 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;const int days[]={0,31,28,31,30,31,30,31,31,30,31,30,31};int ans,d=1;int main(){ for(int m=1;m&lt;=12;++m)d=(d+days[m])%7; for(int y=1901;y&lt;=2000;++y) { for(int m=1;m&lt;=12;++m) { if(!d)++ans; d=(d+days[m]+(m==2&amp;&amp;((bool)(y&amp;3)^true)))%7; } } printf(&quot;%d&quot;,ans); return 0;} Problem 20: Factorial digit sum【思路】Python 模拟 / C/C++ 高精度： 123456import maths = str(math.factorial(100))ans = 0for i in s: ans += int(i)print(ans) Problem 21: Amicable numbers（本题取 $n=10000$） 【思路】先 $\\mathcal O(n)$ 预处理 $1 \\sim 10000$ 因数个数，然后 $\\mathcal O(n)$ 枚举，总体时间复杂度仍为 $\\mathcal O(n)$： 123456789101112131415161718192021#include&lt;stdio.h&gt;int ans,d[10001];int main(){ for(int i=1;i&lt;=10000;++i) { for(int j=i&lt;&lt;1;j&lt;=10000;j+=i) { d[j]+=i; } } for(int i=1;i&lt;=10000;++i) { if(d[i]&lt;=10000&amp;&amp;d[d[i]]==i&amp;&amp;d[i]!=i) { ans+=i; } } printf(&quot;%d&quot;,ans); return 0;} Problem 22: Names scores【思路】从文件读入所有名字，然后模拟。难点在于读入的方法。当然也可以另编写一个程序，将所有名字每几个就换一次行，然后把表存在最终程序里（详见 Problem 42）： 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;string s[6001],t;int n,ans;bool read(string &amp;s){ char ch=getchar(); if(ch==EOF)return false; while(ch&lt;'A'||ch&gt;'Z') { ch=getchar(); if(ch==EOF)return false; } s=ch; while(true) { ch=getchar(); if(ch&lt;'A'||ch&gt;'Z')break; s+=ch; } return true;}int main(){ freopen(&quot;p022_names.txt&quot;,&quot;r&quot;,stdin); while(read(t))s[++n]=t; sort(s+1,s+n+1); for(int i=1;i&lt;=n;++i) { int x=0; for(int j=0;s[i][j];++j)x+=s[i][j]-'A'+1; ans+=x*i; } printf(&quot;%d&quot;,ans); return 0;} Problem 23: Non-abundant sums（本题取 $n=28123$） 【思路】$\\mathcal O(n \\sqrt n)$ 预处理因数个数（用 Problem 21 的思路可优化至 $\\mathcal O(n)$），然后 $\\mathcal O(n^2)$ 模拟。最终的时间复杂度都为 $\\mathcal O(n^2)$： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int ans;bool a[30001];int fac(int x){ if(x==1)return 1; int s=1; for(int i=2;i*i&lt;=x;++i) { if(x%i==0) { s+=i; if(i*i!=x)s+=x/i; } } return s;}int main(){ for(int i=1;i&lt;=28123;++i)a[i]=fac(i)&gt;i; for(int i=1;i&lt;=28123;++i) { bool flag=false; for(int j=1;j&lt;=i&gt;&gt;1;++j) { if(a[j]&amp;a[i-j]) { flag=true; break; } } if(!flag)ans+=i; } printf(&quot;%d&quot;,ans); return 0;} Problem 24: Lexicographic permutations（本题取 $n=10$） 【思路】$\\mathcal O(n!)$ 枚举所有排列情况，可用 DFS 实现或直接调用函数 next_permutation： 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;int a[10],cnt;bool b[10];void dfs(int k){ if(k&gt;9) { if(++cnt==1000000) { for(int i=0;i&lt;10;++i)printf(&quot;%d&quot;,a[i]); exit(0); } return; } for(int i=0;i&lt;10;++i) { if(b[i])continue; a[k]=i; b[i]=true; dfs(k+1); b[i]=false; }}int main(){ dfs(0); return 0;} 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int cnt,a[10];int main(){ for(int i=0;i&lt;=9;++i)a[i]=i; while(next_permutation(a,a+10)&amp;&amp;++cnt&lt;999999); for(int i=0;i&lt;=9;++i)printf(&quot;%d&quot;,a[i]); return 0;} Problem 25: 1000-digit Fibonacci number【思路】采用 Problem 2 中滚动数组的方法，再使用 Python 模拟 / C/C++ 高精度： 123456789import sysa = b = 1ans = 2while True: a, b = b, a + b ans += 1 if len(str(b)) == 1000: print(ans) sys.exit() Problem 26: Reciprocal cycles【思路】这题的关键就是如何得到循环节。试想，当我们把一个单位分数扩大 $10$ 的若干次幂之后，得到的数的整数部分会出现循环。 因此，我们可以重复地将一个初始值为 $1$ 的数对单位分数的分母取模，然后乘上 $10$。 每操作一次，就检查这个数是否已经出现过。如果出现过，就说明已经找到循环节；否则标记并继续操作： 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;int ans,maxn;bool vis[10001];int main(){ for(int i=3;i&lt;1000;i+=2) { int r=1,cur=0; memset(vis,false,sizeof(vis)); while(!vis[r]) { vis[r]=true; r=r%i*10; ++cur; } if(cur&gt;maxn) { ans=i; maxn=cur; } } printf(&quot;%d&quot;,ans); return 0;} Problem 27: Quadratic primes（本题取 $n=1000$） 【思路】由于范围不大，因而可以直接 $\\mathcal O(n^2)$ 枚举，然后套上质数的判断即可。由于待判断的数大小不确定，因而用质数判断函数来代替欧拉筛： 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int maxn,ans;bool prime(int x){ if(x&lt;2)return false; if(x==2||x==3||x==5)return true; if(x%2==0||x%3==0||x%5==0)return false; for(int a=7,b=11;a*a&lt;=x;a+=6,b+=6)if(x%a==0||x%b==0)return false; return true;}int main(){ for(int a=-999;a&lt;=999;++a) { for(int b=-1000;b&lt;=1000;++b) { int n=0; while(prime(n*n+a*n+b))++n; if(n&gt;maxn) { maxn=n; ans=a*b; } } } printf(&quot;%d&quot;,ans); return 0;} Problem 28: Number spiral diagonals（本题取 $n=1000$） 【思路】首先可以发现 $1$ 位于矩阵正中央，即 $(501,501)$ 处。 通过找规律可以发现，每走一步需要顺时针变换一次方向，但是如果已经走过或越界则需再次变换。这样，我们就可以遍历整个矩阵，从而在 $\\mathcal O(n^2)$ 的效率下求出对角线的元素之和： 123456789101112131415161718192021#include&lt;stdio.h&gt;int x=501,y=501,cnt,d=-1,ans,a[1005][1005];const int dx[]={0,1,0,-1},dy[]={1,0,-1,0};int main(){ while(cnt&lt;=1002001) { a[x][y]=++cnt; d=(d+1)%4; int nx=x+dx[d],ny=y+dy[d]; if(nx&lt;1||ny&lt;1||nx&gt;1001||ny&gt;1001||a[nx][ny]) { d=(d+3)%4; x+=dx[d],y+=dy[d]; } else x=nx,y=ny; } for(int i=1;i&lt;=1001;++i)ans+=a[i][i]+a[i][1002-i]; printf(&quot;%d&quot;,ans-1); return 0;} Problem 29: Distinct powers（本题取 $n=100$） 【思路】考虑构造一个元素不可重的集合，通过 $\\mathcal O(n^2)$ 的二维循环枚举所有乘方的结果，最后统计集合内元素个数： 12345a = []for i in range(2, 101): for j in range(2, 101): a.append(i ** j)print(len(list(set(a)))) Problem 30: Digit fifth powers【思路】从二位数开始枚举，直到到达一个较大的预先设置好的上界，在枚举时暴力判断是否符合题意即可： 123456789101112131415161718#include&lt;stdio.h&gt;int ans;int pow5(int x){return x*x*x*x*x;}int main(){ for(int i=11;i&lt;=500000;++i) { int j=i,t=0; while(j) { t+=pow5(j%10); j/=10; } if(i==t)ans+=i; } printf(&quot;%d&quot;,ans); return 0;} Problem 31: Coin sums（本题取 $n=200$，$m=8$） 【思路】通过观察不难发现本题考察的是 DP。 如果我们用 $dp_{i,j}$ 表示使用 $j$ 种不同面额凑出 $i$ 分钱的方案个数，那么显然有初始状态： $$dp_{0,1}=1$$ 由于本题数据范围不大，我们可以暴力递推，从而覆盖所有情况。用 $val_i$ 表示第 $i$ 种货币的面额，则有： $$dp_{i,j}=\\sum_{i=1}^n \\sum_{j=1}^m \\sum_{k=1}^j dp_{i-val_j,k}$$ 这样我们便得到了一个 $\\mathcal O(nm^2)$ 的做法： 1234567891011121314151617181920#include&lt;stdio.h&gt;const int value[]={0,1,2,5,10,20,50,100,200};int dp[201][10],ans;int main(){ dp[0][1]=1; for(int i=1;i&lt;=200;++i) { for(int j=1;value[j]&lt;=i;++j) { for(int k=1;k&lt;=j;++k) { dp[i][j]+=dp[i-value[j]][k]; } } } for(int i=1;i&lt;10;++i)ans+=dp[200][i]; printf(&quot;%d&quot;,ans); return 0;} 【优化】我们可以采用完全背包进行优化。 不妨用 $dp_j$ 表示能够凑出 $j$ 分钱的方案总数，则初始状态为： $$dp_0=1$$ 接着我们使用完全背包的递推方式： $$dp_j=\\sum_{i=1}^m \\sum_{j=val_i}^n dp_{j-val_i}$$ 这样我们可以将时间复杂度优化到 $\\mathcal O(nm)$，空间复杂度优化到 $\\mathcal O(n)$： 12345678910111213141516#include&lt;stdio.h&gt;const int value[]={0,1,2,5,10,20,50,100,200};int dp[201],ans;int main(){ dp[0]=1; for(int i=1;i&lt;=8;++i) { for(int j=value[i];j&lt;=200;++j) { dp[j]+=dp[j-value[i]]; } } printf(&quot;%d&quot;,dp[200]); return 0;} Problem 32: Pandigital products（本题取 $n=9$） 【思路】我们可以 $\\mathcal O(n!)$ 获得 $1 \\sim 9$ 的排列，然后在排列组成的九位数中插两个空——其中一个位于两个乘数之间（相当于乘号），另一个位于左式和右式之间（相当于等号）。最后我们检查一下等式是否正确，正确就累加进入答案： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int ans,a[10];bool vis[10],flag[10000];void dfs(int k){ if(k&gt;9) { for(int i=1;i&lt;=2;++i) { int m1=0; for(int j=1;j&lt;=i;++j)m1=m1*10+a[j]; for(int j=i;j&lt;=5-i;++j) { int m2=0,p=0; for(int k=i+1;k&lt;=i+j;++k)m2=m2*10+a[k]; for(int k=i+j+1;k&lt;=9;++k)p=p*10+a[k]; if(m1*m2==p&amp;&amp;!flag[p]) { flag[p]=true; ans+=p; } } } return; } for(int i=1;i&lt;=9;++i) { if(vis[i])continue; a[k]=i; vis[i]=true; dfs(k+1); vis[i]=false; }}int main(){ dfs(1); printf(&quot;%d&quot;,ans); return 0;} Problem 33: Digit cancelling fractions（本题取 $n=9$） 【思路】题目描述得有些模糊，要求我们找到两个十位数 $a,b$（$a \\lt b$），使得 $a$ 的十位数和 $b$ 的个位数相等，同时使得 $\\dfrac{a}{b}$ 与 $a,b$ 分别删去相同位数之后的商相等。 由于有两个数位相等，因此我们只需要枚举三个数位，这样就可以在 $\\mathcal O(n^3)$ 枚举出所有的情况。约分需要用到 $\\gcd$，因此最终时间复杂度为 $\\mathcal O(n^3 \\log n)$： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;struct fraction{ int n,d;}ans;int gcd(int a,int b){ while(b) { int t=b; b=a%b; a=t; } return a;}int main(){ ans.n=ans.d=1; for(int i=1;i&lt;=9;++i) { for(int j=i+1;j&lt;=9;++j) { for(int k=i+1;k&lt;=9;++k) { int n=i*10+j,d=j*10+k; if(n*k==d*i) { ans.n*=n; ans.d*=d; } } } } printf(&quot;%d&quot;,ans.d/gcd(ans.n,ans.d)); return 0;} Problem 34: Digit factorials（本题取 $n=9$） 【思路】我们可以储存 $0 \\sim 9$ 的所有阶乘的值，然后在 $[10,9!]$ 内枚举所有的数并检验即可。枚举的时间复杂度为 $\\mathcal O(n!)$： 123456789101112131415161718#include&lt;stdio.h&gt;const int fac[]={1,1,2,6,24,120,720,5040,40320,362880};int ans;int main(){ for(int i=10;i&lt;=362880;++i) { int j=i,s=0; while(j) { s+=fac[j%10]; j/=10; } if(s==i)ans+=i; } printf(&quot;%d&quot;,ans); return 0;} Problem 35: Circular primes（本题取 $n=1000000$） 【思路】先 $\\mathcal O(n)$ 欧拉筛，然后暴力枚举所有在范围内的质数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;stdbool.h&gt;const int maxn=1000000;int ans,a[7],prime[maxn];bool vis[maxn];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } }}int main(){ euler(); for(int i=1;i&lt;=prime[0];++i) { int x=prime[i],y=x,n=log10(x)+1; bool f=true; for(int j=1;j&lt;=n;++j) { a[n-j+1]=y%10; y/=10; } for(int j=2;j&lt;=n;++j) { int z=0; for(int k=1;k&lt;=n;++k) { int pos=j+k-1; if(pos&gt;n)pos-=n; z=z*10+a[pos]; } if(vis[z]) { f=false; break; } } ans+=f; } printf(&quot;%d&quot;,ans); return 0;} Problem 36: Double-base palindromes（本题取 $n=1000000$） 【思路】我们可以 $\\mathcal O(n)$ 枚举所有在范围的整数，然后每次 $\\mathcal O(\\log n)$ 进行数位的处理和检查。总体时间复杂度为 $\\mathcal O(n \\log n)$： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int ans,d[7],b[21];int main(){ for(int i=1;i&lt;1000000;++i) { int j=i,cd=0,cb=0; bool flag=true; while(j) { d[++cd]=j%10; j/=10; } for(int k=1;k&lt;=cd&gt;&gt;1;++k) { if(d[k]!=d[cd-k+1]) { flag=false; break; } } if(!flag)continue; j=i; while(j) { b[++cb]=j&amp;1; j&gt;&gt;=1; } for(int k=1;k&lt;=cb&gt;&gt;1;++k) { if(b[k]!=b[cb-k+1]) { flag=false; break; } } if(flag)ans+=i; } printf(&quot;%d&quot;,ans); return 0;} Problem 37: Truncatable primes（本题取 $n=1000000$） 【思路】$\\mathcal O(n)$ 欧拉筛，然后枚举所有在范围内质数并检查是否符合题意。程序的时间复杂度为 $\\mathcal O(n \\log_{10} n)$： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;math.h&gt;const int maxn=1000000;const int pow10[]={1,10,100,1000,10000,100000,1000000};int ans,prime[maxn];bool vis[maxn];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } }}int main(){ euler(); for(int i=5;i&lt;=prime[0];++i) { int x=prime[i],y=x; if(vis[x])continue; bool flag=true; while(true) { y/=10; if(!y)break; if(vis[y]) { flag=false; break; } } y=x; while(y) { if(y&lt;10)break; y%=pow10[int(log10(y))]; if(vis[y]) { flag=false; break; } } if(flag)ans+=x; } printf(&quot;%d&quot;,ans); return 0;} Problem 38: Pandigital multiples【思路】暴力倒序枚举 $10000$ 以内的整数并检查： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int main(){ for(int i=9999;i;--i) { for(int j=2;;++j) { int a[10]={},b[10]={}; for(int k=1;k&lt;=j;++k) { int x=i*k; b[k]=x; while(x) { ++a[x%10]; x/=10; } } bool flag=true; int cnt=a[0]; for(int k=1;k&lt;10;++k) { cnt+=a[k]; if(a[k]!=1)flag=false; } if(cnt&gt;9)break; if(flag) { for(int k=1;k&lt;=j;++k)printf(&quot;%d&quot;,b[k]); return 0; } } } return 0;} Problem 39: Integer right triangles（本题取 $n=1000$） 【思路】最外层枚举 $p$ 的值，里面两层枚举 $a,b$，从而计算得到是否有符合的 $c$。时间复杂度为 $\\mathcal O(n^3)$： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int maxp,maxn;int main(){ for(int p=12;p&lt;=1000;++p) { int s=0; for(int a=3;a&lt;=p/3;++a) { for(int b=a+1;b&lt;=p;++b) { int c=p-a-b; if(a*a+b*b==c*c&amp;&amp;c&gt;b)++s; } } if(s&gt;maxn) { maxn=s; maxp=p; } } printf(&quot;%d&quot;,maxp); return 0;} Problem 40: Champernowne’s constant【思路】由于一个整数 $x$ 的数位个数等于 $\\log_{10} x+1$，因而我们可以不停累加，到了所需的值就进行计算： 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;math.h&gt;const int a[]={1,10,100,1000,10000,100000,1000000};int cnt,ans=1;int main(){ for(int i=1,x=0;x&lt;=1000000;++i) { int len=log10(i)+1,j=i; x+=len; if(x&gt;=a[cnt]) { for(int k=0;k&lt;x-a[cnt];++k)j/=10; ans*=j%10; ++cnt; } } printf(&quot;%d&quot;,ans); return 0;} Problem 41: Pandigital prime（本题取 $n=9$） 【思路】$\\mathcal O(n!)$ 构造全排列并判断是否为质数。由于 $n$ 较大，因此不宜使用欧拉筛。程序的时间复杂度为 $\\mathcal O(n!10^{\\frac{n}{2}})$： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;int ans,a[10];bool vis[10];bool prime(int x){ if(x&lt;2)return false; if(x==2||x==3||x==5)return true; if(x%2==0||x%3==0||x%5==0)return false; for(int a=7,b=11;a*a&lt;=x;a+=6,b+=6)if(x%a==0||x%b==0)return false; return true;}void dfs(int k,int n){ if(k&gt;n) { int x=0; for(int i=1;i&lt;=n;++i)x=x*10+a[i]; if(prime(x)&amp;&amp;x&gt;ans)ans=x; return; } for(int i=1;i&lt;=n;++i) { if(vis[i])continue; a[k]=i; vis[i]=true; dfs(k+1,n); vis[i]=false; }}int main(){ for(int i=1;i&lt;=9;++i) { memset(vis,false,sizeof(vis)); dfs(1,i); } printf(&quot;%d&quot;,ans); return 0;} Problem 42: Coded triangle numbers（取 $n$ 为单词数量，$m$ 为所有单词对应数值的最大值） 【思路】我们在 Problem 22 中使用了文件输入索引，同时对其进行操作。这次我们直接将索引每十个元素空一行，并存放于数组中。 接着我们只需要枚举每个单词并判断它所对应的数值是否为三角形数即可。 判断是否为三角形数可以采用二分法，单次时间复杂度为 $\\mathcal O(\\log \\sqrt m)$ 总体时间复杂度为 $\\mathcal O(n \\log \\sqrt m)$： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int ans;const char *s[]={ &quot;A&quot;,&quot;ABILITY&quot;,&quot;ABLE&quot;,&quot;ABOUT&quot;,&quot;ABOVE&quot;,&quot;ABSENCE&quot;,&quot;ABSOLUTELY&quot;,&quot;ACADEMIC&quot;,&quot;ACCEPT&quot;,&quot;ACCESS&quot;, &quot;ACCIDENT&quot;,&quot;ACCOMPANY&quot;,&quot;ACCORDING&quot;,&quot;ACCOUNT&quot;,&quot;ACHIEVE&quot;,&quot;ACHIEVEMENT&quot;,&quot;ACID&quot;,&quot;ACQUIRE&quot;,&quot;ACROSS&quot;,&quot;ACT&quot;, &quot;ACTION&quot;,&quot;ACTIVE&quot;,&quot;ACTIVITY&quot;,&quot;ACTUAL&quot;,&quot;ACTUALLY&quot;,&quot;ADD&quot;,&quot;ADDITION&quot;,&quot;ADDITIONAL&quot;,&quot;ADDRESS&quot;,&quot;ADMINISTRATION&quot;, &quot;ADMIT&quot;,&quot;ADOPT&quot;,&quot;ADULT&quot;,&quot;ADVANCE&quot;,&quot;ADVANTAGE&quot;,&quot;ADVICE&quot;,&quot;ADVISE&quot;,&quot;AFFAIR&quot;,&quot;AFFECT&quot;,&quot;AFFORD&quot;, &quot;AFRAID&quot;,&quot;AFTER&quot;,&quot;AFTERNOON&quot;,&quot;AFTERWARDS&quot;,&quot;AGAIN&quot;,&quot;AGAINST&quot;,&quot;AGE&quot;,&quot;AGENCY&quot;,&quot;AGENT&quot;,&quot;AGO&quot;, &quot;AGREE&quot;,&quot;AGREEMENT&quot;,&quot;AHEAD&quot;,&quot;AID&quot;,&quot;AIM&quot;,&quot;AIR&quot;,&quot;AIRCRAFT&quot;,&quot;ALL&quot;,&quot;ALLOW&quot;,&quot;ALMOST&quot;, &quot;ALONE&quot;,&quot;ALONG&quot;,&quot;ALREADY&quot;,&quot;ALRIGHT&quot;,&quot;ALSO&quot;,&quot;ALTERNATIVE&quot;,&quot;ALTHOUGH&quot;,&quot;ALWAYS&quot;,&quot;AMONG&quot;,&quot;AMONGST&quot;, &quot;AMOUNT&quot;,&quot;AN&quot;,&quot;ANALYSIS&quot;,&quot;ANCIENT&quot;,&quot;AND&quot;,&quot;ANIMAL&quot;,&quot;ANNOUNCE&quot;,&quot;ANNUAL&quot;,&quot;ANOTHER&quot;,&quot;ANSWER&quot;, &quot;ANY&quot;,&quot;ANYBODY&quot;,&quot;ANYONE&quot;,&quot;ANYTHING&quot;,&quot;ANYWAY&quot;,&quot;APART&quot;,&quot;APPARENT&quot;,&quot;APPARENTLY&quot;,&quot;APPEAL&quot;,&quot;APPEAR&quot;, &quot;APPEARANCE&quot;,&quot;APPLICATION&quot;,&quot;APPLY&quot;,&quot;APPOINT&quot;,&quot;APPOINTMENT&quot;,&quot;APPROACH&quot;,&quot;APPROPRIATE&quot;,&quot;APPROVE&quot;,&quot;AREA&quot;,&quot;ARGUE&quot;, &quot;ARGUMENT&quot;,&quot;ARISE&quot;,&quot;ARM&quot;,&quot;ARMY&quot;,&quot;AROUND&quot;,&quot;ARRANGE&quot;,&quot;ARRANGEMENT&quot;,&quot;ARRIVE&quot;,&quot;ART&quot;,&quot;ARTICLE&quot;, &quot;ARTIST&quot;,&quot;AS&quot;,&quot;ASK&quot;,&quot;ASPECT&quot;,&quot;ASSEMBLY&quot;,&quot;ASSESS&quot;,&quot;ASSESSMENT&quot;,&quot;ASSET&quot;,&quot;ASSOCIATE&quot;,&quot;ASSOCIATION&quot;, &quot;ASSUME&quot;,&quot;ASSUMPTION&quot;,&quot;AT&quot;,&quot;ATMOSPHERE&quot;,&quot;ATTACH&quot;,&quot;ATTACK&quot;,&quot;ATTEMPT&quot;,&quot;ATTEND&quot;,&quot;ATTENTION&quot;,&quot;ATTITUDE&quot;, &quot;ATTRACT&quot;,&quot;ATTRACTIVE&quot;,&quot;AUDIENCE&quot;,&quot;AUTHOR&quot;,&quot;AUTHORITY&quot;,&quot;AVAILABLE&quot;,&quot;AVERAGE&quot;,&quot;AVOID&quot;,&quot;AWARD&quot;,&quot;AWARE&quot;, &quot;AWAY&quot;,&quot;AYE&quot;,&quot;BABY&quot;,&quot;BACK&quot;,&quot;BACKGROUND&quot;,&quot;BAD&quot;,&quot;BAG&quot;,&quot;BALANCE&quot;,&quot;BALL&quot;,&quot;BAND&quot;, &quot;BANK&quot;,&quot;BAR&quot;,&quot;BASE&quot;,&quot;BASIC&quot;,&quot;BASIS&quot;,&quot;BATTLE&quot;,&quot;BE&quot;,&quot;BEAR&quot;,&quot;BEAT&quot;,&quot;BEAUTIFUL&quot;, &quot;BECAUSE&quot;,&quot;BECOME&quot;,&quot;BED&quot;,&quot;BEDROOM&quot;,&quot;BEFORE&quot;,&quot;BEGIN&quot;,&quot;BEGINNING&quot;,&quot;BEHAVIOUR&quot;,&quot;BEHIND&quot;,&quot;BELIEF&quot;, &quot;BELIEVE&quot;,&quot;BELONG&quot;,&quot;BELOW&quot;,&quot;BENEATH&quot;,&quot;BENEFIT&quot;,&quot;BESIDE&quot;,&quot;BEST&quot;,&quot;BETTER&quot;,&quot;BETWEEN&quot;,&quot;BEYOND&quot;, &quot;BIG&quot;,&quot;BILL&quot;,&quot;BIND&quot;,&quot;BIRD&quot;,&quot;BIRTH&quot;,&quot;BIT&quot;,&quot;BLACK&quot;,&quot;BLOCK&quot;,&quot;BLOOD&quot;,&quot;BLOODY&quot;, &quot;BLOW&quot;,&quot;BLUE&quot;,&quot;BOARD&quot;,&quot;BOAT&quot;,&quot;BODY&quot;,&quot;BONE&quot;,&quot;BOOK&quot;,&quot;BORDER&quot;,&quot;BOTH&quot;,&quot;BOTTLE&quot;, &quot;BOTTOM&quot;,&quot;BOX&quot;,&quot;BOY&quot;,&quot;BRAIN&quot;,&quot;BRANCH&quot;,&quot;BREAK&quot;,&quot;BREATH&quot;,&quot;BRIDGE&quot;,&quot;BRIEF&quot;,&quot;BRIGHT&quot;, &quot;BRING&quot;,&quot;BROAD&quot;,&quot;BROTHER&quot;,&quot;BUDGET&quot;,&quot;BUILD&quot;,&quot;BUILDING&quot;,&quot;BURN&quot;,&quot;BUS&quot;,&quot;BUSINESS&quot;,&quot;BUSY&quot;, &quot;BUT&quot;,&quot;BUY&quot;,&quot;BY&quot;,&quot;CABINET&quot;,&quot;CALL&quot;,&quot;CAMPAIGN&quot;,&quot;CAN&quot;,&quot;CANDIDATE&quot;,&quot;CAPABLE&quot;,&quot;CAPACITY&quot;, &quot;CAPITAL&quot;,&quot;CAR&quot;,&quot;CARD&quot;,&quot;CARE&quot;,&quot;CAREER&quot;,&quot;CAREFUL&quot;,&quot;CAREFULLY&quot;,&quot;CARRY&quot;,&quot;CASE&quot;,&quot;CASH&quot;, &quot;CAT&quot;,&quot;CATCH&quot;,&quot;CATEGORY&quot;,&quot;CAUSE&quot;,&quot;CELL&quot;,&quot;CENTRAL&quot;,&quot;CENTRE&quot;,&quot;CENTURY&quot;,&quot;CERTAIN&quot;,&quot;CERTAINLY&quot;, &quot;CHAIN&quot;,&quot;CHAIR&quot;,&quot;CHAIRMAN&quot;,&quot;CHALLENGE&quot;,&quot;CHANCE&quot;,&quot;CHANGE&quot;,&quot;CHANNEL&quot;,&quot;CHAPTER&quot;,&quot;CHARACTER&quot;,&quot;CHARACTERISTIC&quot;, &quot;CHARGE&quot;,&quot;CHEAP&quot;,&quot;CHECK&quot;,&quot;CHEMICAL&quot;,&quot;CHIEF&quot;,&quot;CHILD&quot;,&quot;CHOICE&quot;,&quot;CHOOSE&quot;,&quot;CHURCH&quot;,&quot;CIRCLE&quot;, &quot;CIRCUMSTANCE&quot;,&quot;CITIZEN&quot;,&quot;CITY&quot;,&quot;CIVIL&quot;,&quot;CLAIM&quot;,&quot;CLASS&quot;,&quot;CLEAN&quot;,&quot;CLEAR&quot;,&quot;CLEARLY&quot;,&quot;CLIENT&quot;, &quot;CLIMB&quot;,&quot;CLOSE&quot;,&quot;CLOSELY&quot;,&quot;CLOTHES&quot;,&quot;CLUB&quot;,&quot;COAL&quot;,&quot;CODE&quot;,&quot;COFFEE&quot;,&quot;COLD&quot;,&quot;COLLEAGUE&quot;, &quot;COLLECT&quot;,&quot;COLLECTION&quot;,&quot;COLLEGE&quot;,&quot;COLOUR&quot;,&quot;COMBINATION&quot;,&quot;COMBINE&quot;,&quot;COME&quot;,&quot;COMMENT&quot;,&quot;COMMERCIAL&quot;,&quot;COMMISSION&quot;, &quot;COMMIT&quot;,&quot;COMMITMENT&quot;,&quot;COMMITTEE&quot;,&quot;COMMON&quot;,&quot;COMMUNICATION&quot;,&quot;COMMUNITY&quot;,&quot;COMPANY&quot;,&quot;COMPARE&quot;,&quot;COMPARISON&quot;,&quot;COMPETITION&quot;, &quot;COMPLETE&quot;,&quot;COMPLETELY&quot;,&quot;COMPLEX&quot;,&quot;COMPONENT&quot;,&quot;COMPUTER&quot;,&quot;CONCENTRATE&quot;,&quot;CONCENTRATION&quot;,&quot;CONCEPT&quot;,&quot;CONCERN&quot;,&quot;CONCERNED&quot;, &quot;CONCLUDE&quot;,&quot;CONCLUSION&quot;,&quot;CONDITION&quot;,&quot;CONDUCT&quot;,&quot;CONFERENCE&quot;,&quot;CONFIDENCE&quot;,&quot;CONFIRM&quot;,&quot;CONFLICT&quot;,&quot;CONGRESS&quot;,&quot;CONNECT&quot;, &quot;CONNECTION&quot;,&quot;CONSEQUENCE&quot;,&quot;CONSERVATIVE&quot;,&quot;CONSIDER&quot;,&quot;CONSIDERABLE&quot;,&quot;CONSIDERATION&quot;,&quot;CONSIST&quot;,&quot;CONSTANT&quot;,&quot;CONSTRUCTION&quot;,&quot;CONSUMER&quot;, &quot;CONTACT&quot;,&quot;CONTAIN&quot;,&quot;CONTENT&quot;,&quot;CONTEXT&quot;,&quot;CONTINUE&quot;,&quot;CONTRACT&quot;,&quot;CONTRAST&quot;,&quot;CONTRIBUTE&quot;,&quot;CONTRIBUTION&quot;,&quot;CONTROL&quot;, &quot;CONVENTION&quot;,&quot;CONVERSATION&quot;,&quot;COPY&quot;,&quot;CORNER&quot;,&quot;CORPORATE&quot;,&quot;CORRECT&quot;,&quot;COS&quot;,&quot;COST&quot;,&quot;COULD&quot;,&quot;COUNCIL&quot;, &quot;COUNT&quot;,&quot;COUNTRY&quot;,&quot;COUNTY&quot;,&quot;COUPLE&quot;,&quot;COURSE&quot;,&quot;COURT&quot;,&quot;COVER&quot;,&quot;CREATE&quot;,&quot;CREATION&quot;,&quot;CREDIT&quot;, &quot;CRIME&quot;,&quot;CRIMINAL&quot;,&quot;CRISIS&quot;,&quot;CRITERION&quot;,&quot;CRITICAL&quot;,&quot;CRITICISM&quot;,&quot;CROSS&quot;,&quot;CROWD&quot;,&quot;CRY&quot;,&quot;CULTURAL&quot;, &quot;CULTURE&quot;,&quot;CUP&quot;,&quot;CURRENT&quot;,&quot;CURRENTLY&quot;,&quot;CURRICULUM&quot;,&quot;CUSTOMER&quot;,&quot;CUT&quot;,&quot;DAMAGE&quot;,&quot;DANGER&quot;,&quot;DANGEROUS&quot;, &quot;DARK&quot;,&quot;DATA&quot;,&quot;DATE&quot;,&quot;DAUGHTER&quot;,&quot;DAY&quot;,&quot;DEAD&quot;,&quot;DEAL&quot;,&quot;DEATH&quot;,&quot;DEBATE&quot;,&quot;DEBT&quot;, &quot;DECADE&quot;,&quot;DECIDE&quot;,&quot;DECISION&quot;,&quot;DECLARE&quot;,&quot;DEEP&quot;,&quot;DEFENCE&quot;,&quot;DEFENDANT&quot;,&quot;DEFINE&quot;,&quot;DEFINITION&quot;,&quot;DEGREE&quot;, &quot;DELIVER&quot;,&quot;DEMAND&quot;,&quot;DEMOCRATIC&quot;,&quot;DEMONSTRATE&quot;,&quot;DENY&quot;,&quot;DEPARTMENT&quot;,&quot;DEPEND&quot;,&quot;DEPUTY&quot;,&quot;DERIVE&quot;,&quot;DESCRIBE&quot;, &quot;DESCRIPTION&quot;,&quot;DESIGN&quot;,&quot;DESIRE&quot;,&quot;DESK&quot;,&quot;DESPITE&quot;,&quot;DESTROY&quot;,&quot;DETAIL&quot;,&quot;DETAILED&quot;,&quot;DETERMINE&quot;,&quot;DEVELOP&quot;, &quot;DEVELOPMENT&quot;,&quot;DEVICE&quot;,&quot;DIE&quot;,&quot;DIFFERENCE&quot;,&quot;DIFFERENT&quot;,&quot;DIFFICULT&quot;,&quot;DIFFICULTY&quot;,&quot;DINNER&quot;,&quot;DIRECT&quot;,&quot;DIRECTION&quot;, &quot;DIRECTLY&quot;,&quot;DIRECTOR&quot;,&quot;DISAPPEAR&quot;,&quot;DISCIPLINE&quot;,&quot;DISCOVER&quot;,&quot;DISCUSS&quot;,&quot;DISCUSSION&quot;,&quot;DISEASE&quot;,&quot;DISPLAY&quot;,&quot;DISTANCE&quot;, &quot;DISTINCTION&quot;,&quot;DISTRIBUTION&quot;,&quot;DISTRICT&quot;,&quot;DIVIDE&quot;,&quot;DIVISION&quot;,&quot;DO&quot;,&quot;DOCTOR&quot;,&quot;DOCUMENT&quot;,&quot;DOG&quot;,&quot;DOMESTIC&quot;, &quot;DOOR&quot;,&quot;DOUBLE&quot;,&quot;DOUBT&quot;,&quot;DOWN&quot;,&quot;DRAW&quot;,&quot;DRAWING&quot;,&quot;DREAM&quot;,&quot;DRESS&quot;,&quot;DRINK&quot;,&quot;DRIVE&quot;, &quot;DRIVER&quot;,&quot;DROP&quot;,&quot;DRUG&quot;,&quot;DRY&quot;,&quot;DUE&quot;,&quot;DURING&quot;,&quot;DUTY&quot;,&quot;EACH&quot;,&quot;EAR&quot;,&quot;EARLY&quot;, &quot;EARN&quot;,&quot;EARTH&quot;,&quot;EASILY&quot;,&quot;EAST&quot;,&quot;EASY&quot;,&quot;EAT&quot;,&quot;ECONOMIC&quot;,&quot;ECONOMY&quot;,&quot;EDGE&quot;,&quot;EDITOR&quot;, &quot;EDUCATION&quot;,&quot;EDUCATIONAL&quot;,&quot;EFFECT&quot;,&quot;EFFECTIVE&quot;,&quot;EFFECTIVELY&quot;,&quot;EFFORT&quot;,&quot;EGG&quot;,&quot;EITHER&quot;,&quot;ELDERLY&quot;,&quot;ELECTION&quot;, &quot;ELEMENT&quot;,&quot;ELSE&quot;,&quot;ELSEWHERE&quot;,&quot;EMERGE&quot;,&quot;EMPHASIS&quot;,&quot;EMPLOY&quot;,&quot;EMPLOYEE&quot;,&quot;EMPLOYER&quot;,&quot;EMPLOYMENT&quot;,&quot;EMPTY&quot;, &quot;ENABLE&quot;,&quot;ENCOURAGE&quot;,&quot;END&quot;,&quot;ENEMY&quot;,&quot;ENERGY&quot;,&quot;ENGINE&quot;,&quot;ENGINEERING&quot;,&quot;ENJOY&quot;,&quot;ENOUGH&quot;,&quot;ENSURE&quot;, &quot;ENTER&quot;,&quot;ENTERPRISE&quot;,&quot;ENTIRE&quot;,&quot;ENTIRELY&quot;,&quot;ENTITLE&quot;,&quot;ENTRY&quot;,&quot;ENVIRONMENT&quot;,&quot;ENVIRONMENTAL&quot;,&quot;EQUAL&quot;,&quot;EQUALLY&quot;, &quot;EQUIPMENT&quot;,&quot;ERROR&quot;,&quot;ESCAPE&quot;,&quot;ESPECIALLY&quot;,&quot;ESSENTIAL&quot;,&quot;ESTABLISH&quot;,&quot;ESTABLISHMENT&quot;,&quot;ESTATE&quot;,&quot;ESTIMATE&quot;,&quot;EVEN&quot;, &quot;EVENING&quot;,&quot;EVENT&quot;,&quot;EVENTUALLY&quot;,&quot;EVER&quot;,&quot;EVERY&quot;,&quot;EVERYBODY&quot;,&quot;EVERYONE&quot;,&quot;EVERYTHING&quot;,&quot;EVIDENCE&quot;,&quot;EXACTLY&quot;, &quot;EXAMINATION&quot;,&quot;EXAMINE&quot;,&quot;EXAMPLE&quot;,&quot;EXCELLENT&quot;,&quot;EXCEPT&quot;,&quot;EXCHANGE&quot;,&quot;EXECUTIVE&quot;,&quot;EXERCISE&quot;,&quot;EXHIBITION&quot;,&quot;EXIST&quot;, &quot;EXISTENCE&quot;,&quot;EXISTING&quot;,&quot;EXPECT&quot;,&quot;EXPECTATION&quot;,&quot;EXPENDITURE&quot;,&quot;EXPENSE&quot;,&quot;EXPENSIVE&quot;,&quot;EXPERIENCE&quot;,&quot;EXPERIMENT&quot;,&quot;EXPERT&quot;, &quot;EXPLAIN&quot;,&quot;EXPLANATION&quot;,&quot;EXPLORE&quot;,&quot;EXPRESS&quot;,&quot;EXPRESSION&quot;,&quot;EXTEND&quot;,&quot;EXTENT&quot;,&quot;EXTERNAL&quot;,&quot;EXTRA&quot;,&quot;EXTREMELY&quot;, &quot;EYE&quot;,&quot;FACE&quot;,&quot;FACILITY&quot;,&quot;FACT&quot;,&quot;FACTOR&quot;,&quot;FACTORY&quot;,&quot;FAIL&quot;,&quot;FAILURE&quot;,&quot;FAIR&quot;,&quot;FAIRLY&quot;, &quot;FAITH&quot;,&quot;FALL&quot;,&quot;FAMILIAR&quot;,&quot;FAMILY&quot;,&quot;FAMOUS&quot;,&quot;FAR&quot;,&quot;FARM&quot;,&quot;FARMER&quot;,&quot;FASHION&quot;,&quot;FAST&quot;, &quot;FATHER&quot;,&quot;FAVOUR&quot;,&quot;FEAR&quot;,&quot;FEATURE&quot;,&quot;FEE&quot;,&quot;FEEL&quot;,&quot;FEELING&quot;,&quot;FEMALE&quot;,&quot;FEW&quot;,&quot;FIELD&quot;, &quot;FIGHT&quot;,&quot;FIGURE&quot;,&quot;FILE&quot;,&quot;FILL&quot;,&quot;FILM&quot;,&quot;FINAL&quot;,&quot;FINALLY&quot;,&quot;FINANCE&quot;,&quot;FINANCIAL&quot;,&quot;FIND&quot;, &quot;FINDING&quot;,&quot;FINE&quot;,&quot;FINGER&quot;,&quot;FINISH&quot;,&quot;FIRE&quot;,&quot;FIRM&quot;,&quot;FIRST&quot;,&quot;FISH&quot;,&quot;FIT&quot;,&quot;FIX&quot;, &quot;FLAT&quot;,&quot;FLIGHT&quot;,&quot;FLOOR&quot;,&quot;FLOW&quot;,&quot;FLOWER&quot;,&quot;FLY&quot;,&quot;FOCUS&quot;,&quot;FOLLOW&quot;,&quot;FOLLOWING&quot;,&quot;FOOD&quot;, &quot;FOOT&quot;,&quot;FOOTBALL&quot;,&quot;FOR&quot;,&quot;FORCE&quot;,&quot;FOREIGN&quot;,&quot;FOREST&quot;,&quot;FORGET&quot;,&quot;FORM&quot;,&quot;FORMAL&quot;,&quot;FORMER&quot;, &quot;FORWARD&quot;,&quot;FOUNDATION&quot;,&quot;FREE&quot;,&quot;FREEDOM&quot;,&quot;FREQUENTLY&quot;,&quot;FRESH&quot;,&quot;FRIEND&quot;,&quot;FROM&quot;,&quot;FRONT&quot;,&quot;FRUIT&quot;, &quot;FUEL&quot;,&quot;FULL&quot;,&quot;FULLY&quot;,&quot;FUNCTION&quot;,&quot;FUND&quot;,&quot;FUNNY&quot;,&quot;FURTHER&quot;,&quot;FUTURE&quot;,&quot;GAIN&quot;,&quot;GAME&quot;, &quot;GARDEN&quot;,&quot;GAS&quot;,&quot;GATE&quot;,&quot;GATHER&quot;,&quot;GENERAL&quot;,&quot;GENERALLY&quot;,&quot;GENERATE&quot;,&quot;GENERATION&quot;,&quot;GENTLEMAN&quot;,&quot;GET&quot;, &quot;GIRL&quot;,&quot;GIVE&quot;,&quot;GLASS&quot;,&quot;GO&quot;,&quot;GOAL&quot;,&quot;GOD&quot;,&quot;GOLD&quot;,&quot;GOOD&quot;,&quot;GOVERNMENT&quot;,&quot;GRANT&quot;, &quot;GREAT&quot;,&quot;GREEN&quot;,&quot;GREY&quot;,&quot;GROUND&quot;,&quot;GROUP&quot;,&quot;GROW&quot;,&quot;GROWING&quot;,&quot;GROWTH&quot;,&quot;GUEST&quot;,&quot;GUIDE&quot;, &quot;GUN&quot;,&quot;HAIR&quot;,&quot;HALF&quot;,&quot;HALL&quot;,&quot;HAND&quot;,&quot;HANDLE&quot;,&quot;HANG&quot;,&quot;HAPPEN&quot;,&quot;HAPPY&quot;,&quot;HARD&quot;, &quot;HARDLY&quot;,&quot;HATE&quot;,&quot;HAVE&quot;,&quot;HE&quot;,&quot;HEAD&quot;,&quot;HEALTH&quot;,&quot;HEAR&quot;,&quot;HEART&quot;,&quot;HEAT&quot;,&quot;HEAVY&quot;, &quot;HELL&quot;,&quot;HELP&quot;,&quot;HENCE&quot;,&quot;HER&quot;,&quot;HERE&quot;,&quot;HERSELF&quot;,&quot;HIDE&quot;,&quot;HIGH&quot;,&quot;HIGHLY&quot;,&quot;HILL&quot;, &quot;HIM&quot;,&quot;HIMSELF&quot;,&quot;HIS&quot;,&quot;HISTORICAL&quot;,&quot;HISTORY&quot;,&quot;HIT&quot;,&quot;HOLD&quot;,&quot;HOLE&quot;,&quot;HOLIDAY&quot;,&quot;HOME&quot;, &quot;HOPE&quot;,&quot;HORSE&quot;,&quot;HOSPITAL&quot;,&quot;HOT&quot;,&quot;HOTEL&quot;,&quot;HOUR&quot;,&quot;HOUSE&quot;,&quot;HOUSEHOLD&quot;,&quot;HOUSING&quot;,&quot;HOW&quot;, &quot;HOWEVER&quot;,&quot;HUGE&quot;,&quot;HUMAN&quot;,&quot;HURT&quot;,&quot;HUSBAND&quot;,&quot;I&quot;,&quot;IDEA&quot;,&quot;IDENTIFY&quot;,&quot;IF&quot;,&quot;IGNORE&quot;, &quot;ILLUSTRATE&quot;,&quot;IMAGE&quot;,&quot;IMAGINE&quot;,&quot;IMMEDIATE&quot;,&quot;IMMEDIATELY&quot;,&quot;IMPACT&quot;,&quot;IMPLICATION&quot;,&quot;IMPLY&quot;,&quot;IMPORTANCE&quot;,&quot;IMPORTANT&quot;, &quot;IMPOSE&quot;,&quot;IMPOSSIBLE&quot;,&quot;IMPRESSION&quot;,&quot;IMPROVE&quot;,&quot;IMPROVEMENT&quot;,&quot;IN&quot;,&quot;INCIDENT&quot;,&quot;INCLUDE&quot;,&quot;INCLUDING&quot;,&quot;INCOME&quot;, &quot;INCREASE&quot;,&quot;INCREASED&quot;,&quot;INCREASINGLY&quot;,&quot;INDEED&quot;,&quot;INDEPENDENT&quot;,&quot;INDEX&quot;,&quot;INDICATE&quot;,&quot;INDIVIDUAL&quot;,&quot;INDUSTRIAL&quot;,&quot;INDUSTRY&quot;, &quot;INFLUENCE&quot;,&quot;INFORM&quot;,&quot;INFORMATION&quot;,&quot;INITIAL&quot;,&quot;INITIATIVE&quot;,&quot;INJURY&quot;,&quot;INSIDE&quot;,&quot;INSIST&quot;,&quot;INSTANCE&quot;,&quot;INSTEAD&quot;, &quot;INSTITUTE&quot;,&quot;INSTITUTION&quot;,&quot;INSTRUCTION&quot;,&quot;INSTRUMENT&quot;,&quot;INSURANCE&quot;,&quot;INTEND&quot;,&quot;INTENTION&quot;,&quot;INTEREST&quot;,&quot;INTERESTED&quot;,&quot;INTERESTING&quot;, &quot;INTERNAL&quot;,&quot;INTERNATIONAL&quot;,&quot;INTERPRETATION&quot;,&quot;INTERVIEW&quot;,&quot;INTO&quot;,&quot;INTRODUCE&quot;,&quot;INTRODUCTION&quot;,&quot;INVESTIGATE&quot;,&quot;INVESTIGATION&quot;,&quot;INVESTMENT&quot;, &quot;INVITE&quot;,&quot;INVOLVE&quot;,&quot;IRON&quot;,&quot;IS&quot;,&quot;ISLAND&quot;,&quot;ISSUE&quot;,&quot;IT&quot;,&quot;ITEM&quot;,&quot;ITS&quot;,&quot;ITSELF&quot;, &quot;JOB&quot;,&quot;JOIN&quot;,&quot;JOINT&quot;,&quot;JOURNEY&quot;,&quot;JUDGE&quot;,&quot;JUMP&quot;,&quot;JUST&quot;,&quot;JUSTICE&quot;,&quot;KEEP&quot;,&quot;KEY&quot;, &quot;KID&quot;,&quot;KILL&quot;,&quot;KIND&quot;,&quot;KING&quot;,&quot;KITCHEN&quot;,&quot;KNEE&quot;,&quot;KNOW&quot;,&quot;KNOWLEDGE&quot;,&quot;LABOUR&quot;,&quot;LACK&quot;, &quot;LADY&quot;,&quot;LAND&quot;,&quot;LANGUAGE&quot;,&quot;LARGE&quot;,&quot;LARGELY&quot;,&quot;LAST&quot;,&quot;LATE&quot;,&quot;LATER&quot;,&quot;LATTER&quot;,&quot;LAUGH&quot;, &quot;LAUNCH&quot;,&quot;LAW&quot;,&quot;LAWYER&quot;,&quot;LAY&quot;,&quot;LEAD&quot;,&quot;LEADER&quot;,&quot;LEADERSHIP&quot;,&quot;LEADING&quot;,&quot;LEAF&quot;,&quot;LEAGUE&quot;, &quot;LEAN&quot;,&quot;LEARN&quot;,&quot;LEAST&quot;,&quot;LEAVE&quot;,&quot;LEFT&quot;,&quot;LEG&quot;,&quot;LEGAL&quot;,&quot;LEGISLATION&quot;,&quot;LENGTH&quot;,&quot;LESS&quot;, &quot;LET&quot;,&quot;LETTER&quot;,&quot;LEVEL&quot;,&quot;LIABILITY&quot;,&quot;LIBERAL&quot;,&quot;LIBRARY&quot;,&quot;LIE&quot;,&quot;LIFE&quot;,&quot;LIFT&quot;,&quot;LIGHT&quot;, &quot;LIKE&quot;,&quot;LIKELY&quot;,&quot;LIMIT&quot;,&quot;LIMITED&quot;,&quot;LINE&quot;,&quot;LINK&quot;,&quot;LIP&quot;,&quot;LIST&quot;,&quot;LISTEN&quot;,&quot;LITERATURE&quot;, &quot;LITTLE&quot;,&quot;LIVE&quot;,&quot;LIVING&quot;,&quot;LOAN&quot;,&quot;LOCAL&quot;,&quot;LOCATION&quot;,&quot;LONG&quot;,&quot;LOOK&quot;,&quot;LORD&quot;,&quot;LOSE&quot;, &quot;LOSS&quot;,&quot;LOT&quot;,&quot;LOVE&quot;,&quot;LOVELY&quot;,&quot;LOW&quot;,&quot;LUNCH&quot;,&quot;MACHINE&quot;,&quot;MAGAZINE&quot;,&quot;MAIN&quot;,&quot;MAINLY&quot;, &quot;MAINTAIN&quot;,&quot;MAJOR&quot;,&quot;MAJORITY&quot;,&quot;MAKE&quot;,&quot;MALE&quot;,&quot;MAN&quot;,&quot;MANAGE&quot;,&quot;MANAGEMENT&quot;,&quot;MANAGER&quot;,&quot;MANNER&quot;, &quot;MANY&quot;,&quot;MAP&quot;,&quot;MARK&quot;,&quot;MARKET&quot;,&quot;MARRIAGE&quot;,&quot;MARRIED&quot;,&quot;MARRY&quot;,&quot;MASS&quot;,&quot;MASTER&quot;,&quot;MATCH&quot;, &quot;MATERIAL&quot;,&quot;MATTER&quot;,&quot;MAY&quot;,&quot;MAYBE&quot;,&quot;ME&quot;,&quot;MEAL&quot;,&quot;MEAN&quot;,&quot;MEANING&quot;,&quot;MEANS&quot;,&quot;MEANWHILE&quot;, &quot;MEASURE&quot;,&quot;MECHANISM&quot;,&quot;MEDIA&quot;,&quot;MEDICAL&quot;,&quot;MEET&quot;,&quot;MEETING&quot;,&quot;MEMBER&quot;,&quot;MEMBERSHIP&quot;,&quot;MEMORY&quot;,&quot;MENTAL&quot;, &quot;MENTION&quot;,&quot;MERELY&quot;,&quot;MESSAGE&quot;,&quot;METAL&quot;,&quot;METHOD&quot;,&quot;MIDDLE&quot;,&quot;MIGHT&quot;,&quot;MILE&quot;,&quot;MILITARY&quot;,&quot;MILK&quot;, &quot;MIND&quot;,&quot;MINE&quot;,&quot;MINISTER&quot;,&quot;MINISTRY&quot;,&quot;MINUTE&quot;,&quot;MISS&quot;,&quot;MISTAKE&quot;,&quot;MODEL&quot;,&quot;MODERN&quot;,&quot;MODULE&quot;, &quot;MOMENT&quot;,&quot;MONEY&quot;,&quot;MONTH&quot;,&quot;MORE&quot;,&quot;MORNING&quot;,&quot;MOST&quot;,&quot;MOTHER&quot;,&quot;MOTION&quot;,&quot;MOTOR&quot;,&quot;MOUNTAIN&quot;, &quot;MOUTH&quot;,&quot;MOVE&quot;,&quot;MOVEMENT&quot;,&quot;MUCH&quot;,&quot;MURDER&quot;,&quot;MUSEUM&quot;,&quot;MUSIC&quot;,&quot;MUST&quot;,&quot;MY&quot;,&quot;MYSELF&quot;, &quot;NAME&quot;,&quot;NARROW&quot;,&quot;NATION&quot;,&quot;NATIONAL&quot;,&quot;NATURAL&quot;,&quot;NATURE&quot;,&quot;NEAR&quot;,&quot;NEARLY&quot;,&quot;NECESSARILY&quot;,&quot;NECESSARY&quot;, &quot;NECK&quot;,&quot;NEED&quot;,&quot;NEGOTIATION&quot;,&quot;NEIGHBOUR&quot;,&quot;NEITHER&quot;,&quot;NETWORK&quot;,&quot;NEVER&quot;,&quot;NEVERTHELESS&quot;,&quot;NEW&quot;,&quot;NEWS&quot;, &quot;NEWSPAPER&quot;,&quot;NEXT&quot;,&quot;NICE&quot;,&quot;NIGHT&quot;,&quot;NO&quot;,&quot;NOBODY&quot;,&quot;NOD&quot;,&quot;NOISE&quot;,&quot;NONE&quot;,&quot;NOR&quot;, &quot;NORMAL&quot;,&quot;NORMALLY&quot;,&quot;NORTH&quot;,&quot;NORTHERN&quot;,&quot;NOSE&quot;,&quot;NOT&quot;,&quot;NOTE&quot;,&quot;NOTHING&quot;,&quot;NOTICE&quot;,&quot;NOTION&quot;, &quot;NOW&quot;,&quot;NUCLEAR&quot;,&quot;NUMBER&quot;,&quot;NURSE&quot;,&quot;OBJECT&quot;,&quot;OBJECTIVE&quot;,&quot;OBSERVATION&quot;,&quot;OBSERVE&quot;,&quot;OBTAIN&quot;,&quot;OBVIOUS&quot;, &quot;OBVIOUSLY&quot;,&quot;OCCASION&quot;,&quot;OCCUR&quot;,&quot;ODD&quot;,&quot;OF&quot;,&quot;OFF&quot;,&quot;OFFENCE&quot;,&quot;OFFER&quot;,&quot;OFFICE&quot;,&quot;OFFICER&quot;, &quot;OFFICIAL&quot;,&quot;OFTEN&quot;,&quot;OIL&quot;,&quot;OKAY&quot;,&quot;OLD&quot;,&quot;ON&quot;,&quot;ONCE&quot;,&quot;ONE&quot;,&quot;ONLY&quot;,&quot;ONTO&quot;, &quot;OPEN&quot;,&quot;OPERATE&quot;,&quot;OPERATION&quot;,&quot;OPINION&quot;,&quot;OPPORTUNITY&quot;,&quot;OPPOSITION&quot;,&quot;OPTION&quot;,&quot;OR&quot;,&quot;ORDER&quot;,&quot;ORDINARY&quot;, &quot;ORGANISATION&quot;,&quot;ORGANISE&quot;,&quot;ORGANIZATION&quot;,&quot;ORIGIN&quot;,&quot;ORIGINAL&quot;,&quot;OTHER&quot;,&quot;OTHERWISE&quot;,&quot;OUGHT&quot;,&quot;OUR&quot;,&quot;OURSELVES&quot;, &quot;OUT&quot;,&quot;OUTCOME&quot;,&quot;OUTPUT&quot;,&quot;OUTSIDE&quot;,&quot;OVER&quot;,&quot;OVERALL&quot;,&quot;OWN&quot;,&quot;OWNER&quot;,&quot;PACKAGE&quot;,&quot;PAGE&quot;, &quot;PAIN&quot;,&quot;PAINT&quot;,&quot;PAINTING&quot;,&quot;PAIR&quot;,&quot;PANEL&quot;,&quot;PAPER&quot;,&quot;PARENT&quot;,&quot;PARK&quot;,&quot;PARLIAMENT&quot;,&quot;PART&quot;, &quot;PARTICULAR&quot;,&quot;PARTICULARLY&quot;,&quot;PARTLY&quot;,&quot;PARTNER&quot;,&quot;PARTY&quot;,&quot;PASS&quot;,&quot;PASSAGE&quot;,&quot;PAST&quot;,&quot;PATH&quot;,&quot;PATIENT&quot;, &quot;PATTERN&quot;,&quot;PAY&quot;,&quot;PAYMENT&quot;,&quot;PEACE&quot;,&quot;PENSION&quot;,&quot;PEOPLE&quot;,&quot;PER&quot;,&quot;PERCENT&quot;,&quot;PERFECT&quot;,&quot;PERFORM&quot;, &quot;PERFORMANCE&quot;,&quot;PERHAPS&quot;,&quot;PERIOD&quot;,&quot;PERMANENT&quot;,&quot;PERSON&quot;,&quot;PERSONAL&quot;,&quot;PERSUADE&quot;,&quot;PHASE&quot;,&quot;PHONE&quot;,&quot;PHOTOGRAPH&quot;, &quot;PHYSICAL&quot;,&quot;PICK&quot;,&quot;PICTURE&quot;,&quot;PIECE&quot;,&quot;PLACE&quot;,&quot;PLAN&quot;,&quot;PLANNING&quot;,&quot;PLANT&quot;,&quot;PLASTIC&quot;,&quot;PLATE&quot;, &quot;PLAY&quot;,&quot;PLAYER&quot;,&quot;PLEASE&quot;,&quot;PLEASURE&quot;,&quot;PLENTY&quot;,&quot;PLUS&quot;,&quot;POCKET&quot;,&quot;POINT&quot;,&quot;POLICE&quot;,&quot;POLICY&quot;, &quot;POLITICAL&quot;,&quot;POLITICS&quot;,&quot;POOL&quot;,&quot;POOR&quot;,&quot;POPULAR&quot;,&quot;POPULATION&quot;,&quot;POSITION&quot;,&quot;POSITIVE&quot;,&quot;POSSIBILITY&quot;,&quot;POSSIBLE&quot;, &quot;POSSIBLY&quot;,&quot;POST&quot;,&quot;POTENTIAL&quot;,&quot;POUND&quot;,&quot;POWER&quot;,&quot;POWERFUL&quot;,&quot;PRACTICAL&quot;,&quot;PRACTICE&quot;,&quot;PREFER&quot;,&quot;PREPARE&quot;, &quot;PRESENCE&quot;,&quot;PRESENT&quot;,&quot;PRESIDENT&quot;,&quot;PRESS&quot;,&quot;PRESSURE&quot;,&quot;PRETTY&quot;,&quot;PREVENT&quot;,&quot;PREVIOUS&quot;,&quot;PREVIOUSLY&quot;,&quot;PRICE&quot;, &quot;PRIMARY&quot;,&quot;PRIME&quot;,&quot;PRINCIPLE&quot;,&quot;PRIORITY&quot;,&quot;PRISON&quot;,&quot;PRISONER&quot;,&quot;PRIVATE&quot;,&quot;PROBABLY&quot;,&quot;PROBLEM&quot;,&quot;PROCEDURE&quot;, &quot;PROCESS&quot;,&quot;PRODUCE&quot;,&quot;PRODUCT&quot;,&quot;PRODUCTION&quot;,&quot;PROFESSIONAL&quot;,&quot;PROFIT&quot;,&quot;PROGRAM&quot;,&quot;PROGRAMME&quot;,&quot;PROGRESS&quot;,&quot;PROJECT&quot;, &quot;PROMISE&quot;,&quot;PROMOTE&quot;,&quot;PROPER&quot;,&quot;PROPERLY&quot;,&quot;PROPERTY&quot;,&quot;PROPORTION&quot;,&quot;PROPOSE&quot;,&quot;PROPOSAL&quot;,&quot;PROSPECT&quot;,&quot;PROTECT&quot;, &quot;PROTECTION&quot;,&quot;PROVE&quot;,&quot;PROVIDE&quot;,&quot;PROVIDED&quot;,&quot;PROVISION&quot;,&quot;PUB&quot;,&quot;PUBLIC&quot;,&quot;PUBLICATION&quot;,&quot;PUBLISH&quot;,&quot;PULL&quot;, &quot;PUPIL&quot;,&quot;PURPOSE&quot;,&quot;PUSH&quot;,&quot;PUT&quot;,&quot;QUALITY&quot;,&quot;QUARTER&quot;,&quot;QUESTION&quot;,&quot;QUICK&quot;,&quot;QUICKLY&quot;,&quot;QUIET&quot;, &quot;QUITE&quot;,&quot;RACE&quot;,&quot;RADIO&quot;,&quot;RAILWAY&quot;,&quot;RAIN&quot;,&quot;RAISE&quot;,&quot;RANGE&quot;,&quot;RAPIDLY&quot;,&quot;RARE&quot;,&quot;RATE&quot;, &quot;RATHER&quot;,&quot;REACH&quot;,&quot;REACTION&quot;,&quot;READ&quot;,&quot;READER&quot;,&quot;READING&quot;,&quot;READY&quot;,&quot;REAL&quot;,&quot;REALISE&quot;,&quot;REALITY&quot;, &quot;REALIZE&quot;,&quot;REALLY&quot;,&quot;REASON&quot;,&quot;REASONABLE&quot;,&quot;RECALL&quot;,&quot;RECEIVE&quot;,&quot;RECENT&quot;,&quot;RECENTLY&quot;,&quot;RECOGNISE&quot;,&quot;RECOGNITION&quot;, &quot;RECOGNIZE&quot;,&quot;RECOMMEND&quot;,&quot;RECORD&quot;,&quot;RECOVER&quot;,&quot;RED&quot;,&quot;REDUCE&quot;,&quot;REDUCTION&quot;,&quot;REFER&quot;,&quot;REFERENCE&quot;,&quot;REFLECT&quot;, &quot;REFORM&quot;,&quot;REFUSE&quot;,&quot;REGARD&quot;,&quot;REGION&quot;,&quot;REGIONAL&quot;,&quot;REGULAR&quot;,&quot;REGULATION&quot;,&quot;REJECT&quot;,&quot;RELATE&quot;,&quot;RELATION&quot;, &quot;RELATIONSHIP&quot;,&quot;RELATIVE&quot;,&quot;RELATIVELY&quot;,&quot;RELEASE&quot;,&quot;RELEVANT&quot;,&quot;RELIEF&quot;,&quot;RELIGION&quot;,&quot;RELIGIOUS&quot;,&quot;RELY&quot;,&quot;REMAIN&quot;, &quot;REMEMBER&quot;,&quot;REMIND&quot;,&quot;REMOVE&quot;,&quot;REPEAT&quot;,&quot;REPLACE&quot;,&quot;REPLY&quot;,&quot;REPORT&quot;,&quot;REPRESENT&quot;,&quot;REPRESENTATION&quot;,&quot;REPRESENTATIVE&quot;, &quot;REQUEST&quot;,&quot;REQUIRE&quot;,&quot;REQUIREMENT&quot;,&quot;RESEARCH&quot;,&quot;RESOURCE&quot;,&quot;RESPECT&quot;,&quot;RESPOND&quot;,&quot;RESPONSE&quot;,&quot;RESPONSIBILITY&quot;,&quot;RESPONSIBLE&quot;, &quot;REST&quot;,&quot;RESTAURANT&quot;,&quot;RESULT&quot;,&quot;RETAIN&quot;,&quot;RETURN&quot;,&quot;REVEAL&quot;,&quot;REVENUE&quot;,&quot;REVIEW&quot;,&quot;REVOLUTION&quot;,&quot;RICH&quot;, &quot;RIDE&quot;,&quot;RIGHT&quot;,&quot;RING&quot;,&quot;RISE&quot;,&quot;RISK&quot;,&quot;RIVER&quot;,&quot;ROAD&quot;,&quot;ROCK&quot;,&quot;ROLE&quot;,&quot;ROLL&quot;, &quot;ROOF&quot;,&quot;ROOM&quot;,&quot;ROUND&quot;,&quot;ROUTE&quot;,&quot;ROW&quot;,&quot;ROYAL&quot;,&quot;RULE&quot;,&quot;RUN&quot;,&quot;RURAL&quot;,&quot;SAFE&quot;, &quot;SAFETY&quot;,&quot;SALE&quot;,&quot;SAME&quot;,&quot;SAMPLE&quot;,&quot;SATISFY&quot;,&quot;SAVE&quot;,&quot;SAY&quot;,&quot;SCALE&quot;,&quot;SCENE&quot;,&quot;SCHEME&quot;, &quot;SCHOOL&quot;,&quot;SCIENCE&quot;,&quot;SCIENTIFIC&quot;,&quot;SCIENTIST&quot;,&quot;SCORE&quot;,&quot;SCREEN&quot;,&quot;SEA&quot;,&quot;SEARCH&quot;,&quot;SEASON&quot;,&quot;SEAT&quot;, &quot;SECOND&quot;,&quot;SECONDARY&quot;,&quot;SECRETARY&quot;,&quot;SECTION&quot;,&quot;SECTOR&quot;,&quot;SECURE&quot;,&quot;SECURITY&quot;,&quot;SEE&quot;,&quot;SEEK&quot;,&quot;SEEM&quot;, &quot;SELECT&quot;,&quot;SELECTION&quot;,&quot;SELL&quot;,&quot;SEND&quot;,&quot;SENIOR&quot;,&quot;SENSE&quot;,&quot;SENTENCE&quot;,&quot;SEPARATE&quot;,&quot;SEQUENCE&quot;,&quot;SERIES&quot;, &quot;SERIOUS&quot;,&quot;SERIOUSLY&quot;,&quot;SERVANT&quot;,&quot;SERVE&quot;,&quot;SERVICE&quot;,&quot;SESSION&quot;,&quot;SET&quot;,&quot;SETTLE&quot;,&quot;SETTLEMENT&quot;,&quot;SEVERAL&quot;, &quot;SEVERE&quot;,&quot;SEX&quot;,&quot;SEXUAL&quot;,&quot;SHAKE&quot;,&quot;SHALL&quot;,&quot;SHAPE&quot;,&quot;SHARE&quot;,&quot;SHE&quot;,&quot;SHEET&quot;,&quot;SHIP&quot;, &quot;SHOE&quot;,&quot;SHOOT&quot;,&quot;SHOP&quot;,&quot;SHORT&quot;,&quot;SHOT&quot;,&quot;SHOULD&quot;,&quot;SHOULDER&quot;,&quot;SHOUT&quot;,&quot;SHOW&quot;,&quot;SHUT&quot;, &quot;SIDE&quot;,&quot;SIGHT&quot;,&quot;SIGN&quot;,&quot;SIGNAL&quot;,&quot;SIGNIFICANCE&quot;,&quot;SIGNIFICANT&quot;,&quot;SILENCE&quot;,&quot;SIMILAR&quot;,&quot;SIMPLE&quot;,&quot;SIMPLY&quot;, &quot;SINCE&quot;,&quot;SING&quot;,&quot;SINGLE&quot;,&quot;SIR&quot;,&quot;SISTER&quot;,&quot;SIT&quot;,&quot;SITE&quot;,&quot;SITUATION&quot;,&quot;SIZE&quot;,&quot;SKILL&quot;, &quot;SKIN&quot;,&quot;SKY&quot;,&quot;SLEEP&quot;,&quot;SLIGHTLY&quot;,&quot;SLIP&quot;,&quot;SLOW&quot;,&quot;SLOWLY&quot;,&quot;SMALL&quot;,&quot;SMILE&quot;,&quot;SO&quot;, &quot;SOCIAL&quot;,&quot;SOCIETY&quot;,&quot;SOFT&quot;,&quot;SOFTWARE&quot;,&quot;SOIL&quot;,&quot;SOLDIER&quot;,&quot;SOLICITOR&quot;,&quot;SOLUTION&quot;,&quot;SOME&quot;,&quot;SOMEBODY&quot;, &quot;SOMEONE&quot;,&quot;SOMETHING&quot;,&quot;SOMETIMES&quot;,&quot;SOMEWHAT&quot;,&quot;SOMEWHERE&quot;,&quot;SON&quot;,&quot;SONG&quot;,&quot;SOON&quot;,&quot;SORRY&quot;,&quot;SORT&quot;, &quot;SOUND&quot;,&quot;SOURCE&quot;,&quot;SOUTH&quot;,&quot;SOUTHERN&quot;,&quot;SPACE&quot;,&quot;SPEAK&quot;,&quot;SPEAKER&quot;,&quot;SPECIAL&quot;,&quot;SPECIES&quot;,&quot;SPECIFIC&quot;, &quot;SPEECH&quot;,&quot;SPEED&quot;,&quot;SPEND&quot;,&quot;SPIRIT&quot;,&quot;SPORT&quot;,&quot;SPOT&quot;,&quot;SPREAD&quot;,&quot;SPRING&quot;,&quot;STAFF&quot;,&quot;STAGE&quot;, &quot;STAND&quot;,&quot;STANDARD&quot;,&quot;STAR&quot;,&quot;START&quot;,&quot;STATE&quot;,&quot;STATEMENT&quot;,&quot;STATION&quot;,&quot;STATUS&quot;,&quot;STAY&quot;,&quot;STEAL&quot;, &quot;STEP&quot;,&quot;STICK&quot;,&quot;STILL&quot;,&quot;STOCK&quot;,&quot;STONE&quot;,&quot;STOP&quot;,&quot;STORE&quot;,&quot;STORY&quot;,&quot;STRAIGHT&quot;,&quot;STRANGE&quot;, &quot;STRATEGY&quot;,&quot;STREET&quot;,&quot;STRENGTH&quot;,&quot;STRIKE&quot;,&quot;STRONG&quot;,&quot;STRONGLY&quot;,&quot;STRUCTURE&quot;,&quot;STUDENT&quot;,&quot;STUDIO&quot;,&quot;STUDY&quot;, &quot;STUFF&quot;,&quot;STYLE&quot;,&quot;SUBJECT&quot;,&quot;SUBSTANTIAL&quot;,&quot;SUCCEED&quot;,&quot;SUCCESS&quot;,&quot;SUCCESSFUL&quot;,&quot;SUCH&quot;,&quot;SUDDENLY&quot;,&quot;SUFFER&quot;, &quot;SUFFICIENT&quot;,&quot;SUGGEST&quot;,&quot;SUGGESTION&quot;,&quot;SUITABLE&quot;,&quot;SUM&quot;,&quot;SUMMER&quot;,&quot;SUN&quot;,&quot;SUPPLY&quot;,&quot;SUPPORT&quot;,&quot;SUPPOSE&quot;, &quot;SURE&quot;,&quot;SURELY&quot;,&quot;SURFACE&quot;,&quot;SURPRISE&quot;,&quot;SURROUND&quot;,&quot;SURVEY&quot;,&quot;SURVIVE&quot;,&quot;SWITCH&quot;,&quot;SYSTEM&quot;,&quot;TABLE&quot;, &quot;TAKE&quot;,&quot;TALK&quot;,&quot;TALL&quot;,&quot;TAPE&quot;,&quot;TARGET&quot;,&quot;TASK&quot;,&quot;TAX&quot;,&quot;TEA&quot;,&quot;TEACH&quot;,&quot;TEACHER&quot;, &quot;TEACHING&quot;,&quot;TEAM&quot;,&quot;TEAR&quot;,&quot;TECHNICAL&quot;,&quot;TECHNIQUE&quot;,&quot;TECHNOLOGY&quot;,&quot;TELEPHONE&quot;,&quot;TELEVISION&quot;,&quot;TELL&quot;,&quot;TEMPERATURE&quot;, &quot;TEND&quot;,&quot;TERM&quot;,&quot;TERMS&quot;,&quot;TERRIBLE&quot;,&quot;TEST&quot;,&quot;TEXT&quot;,&quot;THAN&quot;,&quot;THANK&quot;,&quot;THANKS&quot;,&quot;THAT&quot;, &quot;THE&quot;,&quot;THEATRE&quot;,&quot;THEIR&quot;,&quot;THEM&quot;,&quot;THEME&quot;,&quot;THEMSELVES&quot;,&quot;THEN&quot;,&quot;THEORY&quot;,&quot;THERE&quot;,&quot;THEREFORE&quot;, &quot;THESE&quot;,&quot;THEY&quot;,&quot;THIN&quot;,&quot;THING&quot;,&quot;THINK&quot;,&quot;THIS&quot;,&quot;THOSE&quot;,&quot;THOUGH&quot;,&quot;THOUGHT&quot;,&quot;THREAT&quot;, &quot;THREATEN&quot;,&quot;THROUGH&quot;,&quot;THROUGHOUT&quot;,&quot;THROW&quot;,&quot;THUS&quot;,&quot;TICKET&quot;,&quot;TIME&quot;,&quot;TINY&quot;,&quot;TITLE&quot;,&quot;TO&quot;, &quot;TODAY&quot;,&quot;TOGETHER&quot;,&quot;TOMORROW&quot;,&quot;TONE&quot;,&quot;TONIGHT&quot;,&quot;TOO&quot;,&quot;TOOL&quot;,&quot;TOOTH&quot;,&quot;TOP&quot;,&quot;TOTAL&quot;, &quot;TOTALLY&quot;,&quot;TOUCH&quot;,&quot;TOUR&quot;,&quot;TOWARDS&quot;,&quot;TOWN&quot;,&quot;TRACK&quot;,&quot;TRADE&quot;,&quot;TRADITION&quot;,&quot;TRADITIONAL&quot;,&quot;TRAFFIC&quot;, &quot;TRAIN&quot;,&quot;TRAINING&quot;,&quot;TRANSFER&quot;,&quot;TRANSPORT&quot;,&quot;TRAVEL&quot;,&quot;TREAT&quot;,&quot;TREATMENT&quot;,&quot;TREATY&quot;,&quot;TREE&quot;,&quot;TREND&quot;, &quot;TRIAL&quot;,&quot;TRIP&quot;,&quot;TROOP&quot;,&quot;TROUBLE&quot;,&quot;TRUE&quot;,&quot;TRUST&quot;,&quot;TRUTH&quot;,&quot;TRY&quot;,&quot;TURN&quot;,&quot;TWICE&quot;, &quot;TYPE&quot;,&quot;TYPICAL&quot;,&quot;UNABLE&quot;,&quot;UNDER&quot;,&quot;UNDERSTAND&quot;,&quot;UNDERSTANDING&quot;,&quot;UNDERTAKE&quot;,&quot;UNEMPLOYMENT&quot;,&quot;UNFORTUNATELY&quot;,&quot;UNION&quot;, &quot;UNIT&quot;,&quot;UNITED&quot;,&quot;UNIVERSITY&quot;,&quot;UNLESS&quot;,&quot;UNLIKELY&quot;,&quot;UNTIL&quot;,&quot;UP&quot;,&quot;UPON&quot;,&quot;UPPER&quot;,&quot;URBAN&quot;, &quot;US&quot;,&quot;USE&quot;,&quot;USED&quot;,&quot;USEFUL&quot;,&quot;USER&quot;,&quot;USUAL&quot;,&quot;USUALLY&quot;,&quot;VALUE&quot;,&quot;VARIATION&quot;,&quot;VARIETY&quot;, &quot;VARIOUS&quot;,&quot;VARY&quot;,&quot;VAST&quot;,&quot;VEHICLE&quot;,&quot;VERSION&quot;,&quot;VERY&quot;,&quot;VIA&quot;,&quot;VICTIM&quot;,&quot;VICTORY&quot;,&quot;VIDEO&quot;, &quot;VIEW&quot;,&quot;VILLAGE&quot;,&quot;VIOLENCE&quot;,&quot;VISION&quot;,&quot;VISIT&quot;,&quot;VISITOR&quot;,&quot;VITAL&quot;,&quot;VOICE&quot;,&quot;VOLUME&quot;,&quot;VOTE&quot;, &quot;WAGE&quot;,&quot;WAIT&quot;,&quot;WALK&quot;,&quot;WALL&quot;,&quot;WANT&quot;,&quot;WAR&quot;,&quot;WARM&quot;,&quot;WARN&quot;,&quot;WASH&quot;,&quot;WATCH&quot;, &quot;WATER&quot;,&quot;WAVE&quot;,&quot;WAY&quot;,&quot;WE&quot;,&quot;WEAK&quot;,&quot;WEAPON&quot;,&quot;WEAR&quot;,&quot;WEATHER&quot;,&quot;WEEK&quot;,&quot;WEEKEND&quot;, &quot;WEIGHT&quot;,&quot;WELCOME&quot;,&quot;WELFARE&quot;,&quot;WELL&quot;,&quot;WEST&quot;,&quot;WESTERN&quot;,&quot;WHAT&quot;,&quot;WHATEVER&quot;,&quot;WHEN&quot;,&quot;WHERE&quot;, &quot;WHEREAS&quot;,&quot;WHETHER&quot;,&quot;WHICH&quot;,&quot;WHILE&quot;,&quot;WHILST&quot;,&quot;WHITE&quot;,&quot;WHO&quot;,&quot;WHOLE&quot;,&quot;WHOM&quot;,&quot;WHOSE&quot;, &quot;WHY&quot;,&quot;WIDE&quot;,&quot;WIDELY&quot;,&quot;WIFE&quot;,&quot;WILD&quot;,&quot;WILL&quot;,&quot;WIN&quot;,&quot;WIND&quot;,&quot;WINDOW&quot;,&quot;WINE&quot;, &quot;WING&quot;,&quot;WINNER&quot;,&quot;WINTER&quot;,&quot;WISH&quot;,&quot;WITH&quot;,&quot;WITHDRAW&quot;,&quot;WITHIN&quot;,&quot;WITHOUT&quot;,&quot;WOMAN&quot;,&quot;WONDER&quot;, &quot;WONDERFUL&quot;,&quot;WOOD&quot;,&quot;WORD&quot;,&quot;WORK&quot;,&quot;WORKER&quot;,&quot;WORKING&quot;,&quot;WORKS&quot;,&quot;WORLD&quot;,&quot;WORRY&quot;,&quot;WORTH&quot;, &quot;WOULD&quot;,&quot;WRITE&quot;,&quot;WRITER&quot;,&quot;WRITING&quot;,&quot;WRONG&quot;,&quot;YARD&quot;,&quot;YEAH&quot;,&quot;YEAR&quot;,&quot;YES&quot;,&quot;YESTERDAY&quot;, &quot;YET&quot;,&quot;YOU&quot;,&quot;YOUNG&quot;,&quot;YOUR&quot;,&quot;YOURSELF&quot;,&quot;YOUTH&quot;};int main(){ for(int i=0;i&lt;1786;++i) { int sum=0,l=1,r=30; bool flag=false; for(int j=0;s[i][j];++j)sum+=s[i][j]-'A'+1; sum&lt;&lt;=1; while(l&lt;=r) { int mid=(l+r)&gt;&gt;1,tmp=mid*(mid+1); if(tmp==sum) { flag=true; break; } if(tmp&gt;sum)r=mid-1; else l=mid+1; } ans+=flag; } printf(&quot;%d&quot;,ans); return 0;} Problem 43: Sub-string divisibility（本题取 $n=10$） 【思路】构造 $0 \\sim 9$ 全排列，然后合成十位数后判断即可，时间复杂度为 $\\mathcal O(n!10^{\\frac{n}{2}})$： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;const int p[]={2,3,5,7,11,13,17};long long ans;int a[10];bool vis[10];void dfs(int k){ if(k&gt;9) { bool flag=true; for(int i=1;i&lt;=7;++i) { int x=a[i]*100+a[i+1]*10+a[i+2]; if(x%p[i-1]) { flag=false; break; } } if(flag) { long long x=0; for(int i=0;i&lt;=9;++i)x=x*10+a[i]; ans+=x; } return; } for(int i=0;i&lt;=9;++i) { if(vis[i])continue; a[k]=i; vis[i]=true; dfs(k+1); vis[i]=false; }}int main(){ dfs(0); printf(&quot;%lld&quot;,ans); return 0;} Problem 44: Pentagon numbers【思路】选定一个足够大的项数上限 $n$，然后 $\\mathcal O(n^2)$ 枚举，判断的时候采用二分，总体时间复杂度为 $\\mathcal O(n^2 \\log n)$： 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;int ans=1&lt;&lt;30;bool check(int l,int r,int x){ while(l&lt;=r) { int mid=(l+r)&gt;&gt;1,tmp=mid*(3*mid-1); if(tmp==x)return true; if(tmp&gt;x)r=mid-1; else l=mid+1; } return false;}int main(){ for(int i=1;i&lt;=10000;++i) { for(int j=1;j&lt;i;++j) { int pi=i*(i*3-1),pj=j*(j*3-1); if(check(1,i&lt;&lt;1,pi+pj)&amp;&amp;check(1,i,pi-pj)&amp;&amp;pi-pj&lt;ans)ans=pi-pj; } } printf(&quot;%d&quot;,ans&gt;&gt;1); return 0;} Problem 45: Triangular, pentagonal, and hexagonal【思路】不难发现三角形数必然是六边形数，因而我们可以从第 $144$ 项六边形数开始枚举，采用二分找到第一个既是五边形数又是六边形数的整数： 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;math.h&gt;bool check(long long l,long long r,long long x){ while(l&lt;=r) { long long mid=(l+r)&gt;&gt;1,tmp=mid*(mid*3-1); if(tmp==x)return true; if(tmp&gt;x)r=mid-1; else l=mid+1; } return false;}int main(){ for(int i=144;;++i) { long long x=2LL*i*((i&lt;&lt;1)-1); if(check(1,sqrt(x),x)) { printf(&quot;%lld&quot;,x&gt;&gt;1); return 0; } } return 0;} Problem 46: Goldbach’s other conjecture【思路】取一个足够大的上限 $n$，确保最终答案不超过 $n$。我们可以采用欧拉筛得到所有的质数和合数表。注意合数不是按照顺序得到的，需要排序。 接着我们枚举所有在范围内的合数，二分找到不超过它的最大质数，然后判断二者之差是否能表示乘一个完全平方数的两倍即可。 总体时间复杂度为 $\\mathcal O(n \\log n)$： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000;int prime[maxn],composite[maxn];bool vis[maxn];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i*prime[j]&amp;1)composite[++composite[0]]=i*prime[j]; if(i%prime[j]==0)break; } } sort(composite+1,composite+composite[0]+1);}int binary(int l,int r,int x){ while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(prime[mid]&gt;x)r=mid-1; else l=mid+1; } return r;}int main(){ euler(); for(int i=1;i&lt;=composite[0];++i) { int x=composite[i]; bool flag=false; for(int j=binary(1,prime[0],x);j&gt;1;--j) { int y=prime[j],z=sqrt((x-y)&gt;&gt;1); if(z*z&lt;&lt;1==x-y) { flag=true; break; } } if(!flag) { printf(&quot;%d&quot;,x); return 0; } } return 0;} Problem 47: Distinct primes factors【思路】与 Problem 46 类似，我们先取一个足够大的上限 $n$，先欧拉筛得到质数表和合数表。 在判断合数是否有四个不同的质因数时，我们同样可以采取二分，找到不超过它的最大质数，然后倒着循环，统计出它的不同质因数个数即可。 总体时间复杂度为 $\\mathcal O(n \\log n)$： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000000;int prime[maxn],composite[maxn];bool vis[maxn];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; composite[++composite[0]]=i*prime[j]; if(i%prime[j]==0)break; } } sort(composite+1,composite+composite[0]+1);}int binary(int l,int r,int x){ while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(prime[mid]&gt;x)r=mid-1; else l=mid+1; } return r-1;}bool check(int x){ if(!vis[x])return false; int cnt=0,tmp=0; for(int i=binary(1,x,x);i;--i) { bool flag=false; while(x%prime[i]==0) { flag=true; x/=prime[i]; } cnt+=flag; if(cnt==4)return x==1; } return false;}int main(){ euler(); for(int i=1;i&lt;=composite[0];++i) { int x=composite[i]; if(check(x)&amp;&amp;check(x+1)&amp;&amp;check(x+2)&amp;&amp;check(x+3)) { printf(&quot;%d&quot;,x); return 0; } } return 0;} Problem 48: Self powers（本题取 $n=1000$，$m=10^{10}$) 【思路】Python 直接套 pow： 1234mod = int(1e10)ans = 0for i in range(1, 1001): ans = (ans + pow(i, i, mod)) % modprint(ans) 也可以使用快速幂+龟速乘，时间复杂度为 $\\mathcal O(n \\log n \\log m)$。当然快速乘可优化到 $\\mathcal O(n \\log n)$： 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;const long long mod=1e10;long long ans;long long mul(long long a,long long b){ long long s=0; while(b) { if(b&amp;1)s=(s+a)%mod; a=(a&lt;&lt;1)%mod; b&gt;&gt;=1; } return s;}long long power(long long a,long long b){ long long s=1; while(b) { if(b&amp;1)s=mul(s,a)%mod; a=mul(a,a)%mod; b&gt;&gt;=1; } return s;}int main(){ for(int i=1;i&lt;=1000;++i)ans+=power(i,i); printf(&quot;%lld&quot;,ans%mod); return 0;} Problem 49: Prime permutations【思路】先欧拉筛，然后枚举所有四位数的所有排列，最后去重后检验即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=10000;int cnt,prime[maxn],a[5],b[5],ans[5];bool vis[maxn],flag[5];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } }}void dfs(int k){ if(k&gt;4) { int x=0; for(int i=1;i&lt;=4;++i)x=x*10+a[b[i]]; if(!vis[x])ans[++cnt]=x; return; } for(int i=1;i&lt;=4;++i) { if(flag[i])continue; b[k]=i; flag[i]=true; dfs(k+1); flag[i]=false; }}int main(){ euler(); for(int i=1000;i&lt;10000;++i) { a[1]=i/1000; a[2]=i/100%10; a[3]=i/10%10; a[4]=i%10; if(!a[1]||!a[2]||!a[3]||!a[4])continue; memset(flag,false,sizeof(flag)); cnt=0; dfs(1); sort(ans+1,ans+cnt+1); cnt=unique(ans+1,ans+cnt+1)-ans-1; for(int j=1;j&lt;=cnt;++j) { if(ans[j]==1487)continue; for(int k=j+1;k&lt;=cnt;++k) { for(int l=k+1;l&lt;=cnt;++l) { if(ans[l]-ans[k]==ans[k]-ans[j]) { printf(&quot;%d%d%d&quot;,ans[j],ans[k],ans[l]); return 0; } } } } } return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=10000;int cnt,prime[maxn],a[5],ans[5];bool vis[maxn];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } }}int main(){ euler(); for(int i=1000;i&lt;10000;++i) { a[1]=i/1000; a[2]=i/100%10; a[3]=i/10%10; a[4]=i%10; if(!a[1]||!a[2]||!a[3]||!a[4])continue; cnt=0; do { int x=0; for(int i=1;i&lt;=4;++i)x=x*10+a[i]; if(!vis[x])ans[++cnt]=x; }while(next_permutation(a+1,a+5)); sort(ans+1,ans+cnt+1); cnt=unique(ans+1,ans+cnt+1)-ans-1; for(int j=1;j&lt;=cnt;++j) { if(ans[j]==1487)continue; for(int k=j+1;k&lt;=cnt;++k) { for(int l=k+1;l&lt;=cnt;++l) { if(ans[l]-ans[k]==ans[k]-ans[j]) { printf(&quot;%d%d%d&quot;,ans[j],ans[k],ans[l]); return 0; } } } } } return 0;} Problem 50: Consecutive prime sum（本题取 $n=1000000$，$m$ 为不超过 $n$ 的质数个数） 【思路】欧拉筛初始化后，采用前缀和预处理，一旦超过 $n$ 就不再继续做下去，这样会减小后续枚举范围。 紧接着在所有质数中枚举作为起始质数，然后取连续的 $maxl+1$ 个质数得到它们的和（规定 $maxl$ 为当前最多质数的个数），再判断是否为质数即可。 总体时间复杂度为 $\\mathcal O(n+m^2)$： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;const int maxn=1000000;int cnt,ans,maxl,prime[maxn];long long s[maxn];bool vis[maxn];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } }}int main(){ euler(); s[1]=prime[1]; for(int i=2;i&lt;=prime[0];++i) { s[i]=s[i-1]+prime[i]; if(s[i]&gt;1000000) { cnt=i; break; } } for(int i=1;i&lt;=cnt;++i) { int sum=0; for(int j=i+maxl+1;j&lt;=cnt&amp;&amp;s[j]-s[i-1]&lt;=maxn;++j) { if(!vis[s[j]-s[i-1]]) { maxl=j-i; ans=s[j]-s[i-1]; } } } printf(&quot;%d&quot;,ans); return 0;} Problem 51: Prime digit replacements（本题取 $n=1000000$） 【思路】欧拉筛初始化后，对位数及空缺位置进行枚举，再分别判断 $0 \\sim 9$ 填入之后是否为质数即可。 其中，在枚举方面，我们可以在 $0 \\sim 9$ 之外新建一个特殊位 $10$，表示这个位置是待替换的。这样，我们的程序就无形之间被简化了。 总体时间复杂度为 $\\mathcal O(n)$： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000000;int a[7],ans=1&lt;&lt;30,prime[maxn];bool vis[maxn];void euler(){ vis[0]=vis[1]=true; for(int i=2;i&lt;=maxn;++i) { if(!vis[i])prime[++prime[0]]=i; for(int j=1;i*prime[j]&lt;=maxn&amp;&amp;j&lt;=prime[0];++j) { vis[i*prime[j]]=true; if(i%prime[j]==0)break; } }}int main(){ euler(); for(int i=2,j=11;i&lt;=6;++i,j*=11) { for(int k=j;k&lt;j*11;++k) { int kk=k; bool flag=false; for(int l=i;l;--l) { a[l]=kk%11; flag|=(a[l]==10); kk/=11; } if(!flag)continue; int cnt=0,x; for(int l=9;l&gt;=0;--l) { if(!l&amp;&amp;a[1]==10)break; x=0; for(int m=1;m&lt;=i;++m)x=(x&lt;&lt;3)+(x&lt;&lt;1)+(a[m]==10?l:a[m]); cnt+=(!vis[x]); } if(cnt==8)ans=min(ans,x); } if(ans!=1&lt;&lt;30)break; } printf(&quot;%d&quot;,ans); return 0;} 52. Permuted multiples（本题取 $n=142857$） 【思路】从 $1$ 开始向更大的数进行枚举，利用 Python 整型字符串自由转换的功能进行判断，找到符合题意的数即可输出。 总体时间复杂度为 $\\mathcal O(n)$： 12345678910111213141516171819i = 1while True: a = [] for j in range(1, 7): s = [] k = str(i * j) for c in k: s.append(c) s.sort() a.append(s) flag = True for j in range(1, 6): if a[j] != a[j - 1]: flag = False break if flag: print(i) exit() i += 1","link":"/projecteuler/report/"},{"title":"原子轨道","text":"原子轨道的定义： 原子轨道是特定能量的电子在核外空间出现最多的区域。 计算原子在某一位置出现概率的方法： $$\\Psi(r,\\theta,\\varphi)=R(r) \\cdot \\Theta(\\theta) \\cdot \\Phi(\\varphi)$$ 这三个参数被称为量子数。不同的原子、不同的位置都有不同的量子数。 $R(r)$：主量子数 $n$ ——物理含义是距离核的距离 $\\Theta(\\theta)$：角量子数 $l$ ——物理含义是不同位置的角动量 $\\Theta(\\theta) \\cdot \\Phi(\\varphi)$：磁通量 $m$ ——不同伸展方向在磁场中发生分化 1 主量子数 $n$（能层） 主量子数用于确定电子出现几率最大处距离核的距离。 不同的 $n$ 值对应不同的电子壳层（电子层）。 1 2 3 4 5 K L M N O 2 角量子数 $m$（能级） 角量子数决定了函数的形状。 $l$ 的取值为 $[0,n) \\cap \\mathbf Z$，可以理解为表示电子层内部的亚层结构。 0 1 2 3 4 s p d f g 3 磁量子数 $l$ 磁量子数用于确定轨道取向。 $m$ 的取值为 $0,\\pm 1,\\pm 3,\\cdots,\\pm(2l-1)$。 l m 轨道数量 $0(\\text s)$ $0$ $1$ $1(\\text p)$ $0,\\pm 1$ $3$ $2(\\text d)$ $0,\\pm 1,\\pm 3$ $5$ $3(\\text f)$ $0,\\pm 1,\\pm 3,\\pm 5$ $7$ 4 自旋量子数 $m_s$自旋量子数用于描述电子的旋转方向，取值为 $\\pm \\frac{1}{2}$。 练习 写出与轨道量子数相符的轨道名称： $n=3,l=2,m=1$ $n=4,l=2,m=0$ $n=1,l=0,m=0$ $n=2,l=1,m=-1$ 解： $l=2$ 对应 $\\text d$，为 $3 \\text d$。 $l=2$ 对应 $\\text d$，为 $4 \\text d$。 $l=0$ 对应 $\\text s$，为 $1 \\text s$。 $l=1$ 对应 $\\text p$，为 $2 \\text p$。 判断哪些原子轨道不存在： $3 \\text d$ $5 \\text f$ $4 \\text s$ $2 \\text g$ $7 \\text s$ $2 \\text d$ 解：$\\text d,\\text f,\\text s,\\text g,\\text s,\\text d$ 分别对应 $2,3,0,4,0,2$。由于 $4 \\ge 2$ 且 $2 \\ge 2$，因此 $2 \\text g$ 和 $2 \\text d$ 不存在。 思考$\\text H$ 原子有 $2 \\text s$ 轨道吗？ 答：有，因为任何一个原子都可以拥有无数个轨道（只要合法），但只有有限个轨道上有电子。","link":"/chemistry/1%E5%8E%9F%E5%AD%90%E7%9A%84%E6%9E%84%E9%80%A0%E5%8E%9F%E7%90%86/arbital/"},{"title":"原子的构造原理 练习与小结","text":"练习 1下列叙述正确的是 A. 能级就是电子层 B. 每个能层最多可容纳的电子数是 $2n^2$ C. 同一能层中的不同能级的能量高低相同 D. 不同能层中 $\\text s$ 能级的能量高低相同 练习 2主族元素原子失去最外层电子形成阳离子，主族元素的原子得到电子填充在最外层形成阴离子。下列各原子或离子的电子排布式错误的是 A. $\\text{Ca}^{2+}: 1 \\text s^2 2 \\text s^2 2 \\text p^6 3 \\text s^2 3 \\text p^6$ B. $\\text O^{2-}: 1 \\text s^2 2 \\text s^2 2 \\text p^4$ C. $\\text{Cl}^-: 1 \\text s^2 2 \\text s^2 2 \\text p^6 3 \\text s^2 3 \\text p^6$ D. $\\text{Ar}: 1 \\text s^2 2 \\text s^2 2 \\text p^6 3 \\text s^2 3 \\text p^6$ 练习 3$\\text X,\\text Y$ 两元素可形成 $\\text X_2 \\text Y_3$ 型化合物，则 $\\text X,\\text Y$ 原子最外层的电子排布可能是 A. $\\text X: 3 \\text s^2 3 \\text p^1$ $\\text Y: 3 \\text s^2 3 \\text p^5$ B. $\\text X: 2 \\text s^2 2 \\text p^3$ $\\text Y: 2 \\text s^2 2 \\text p^4$ C. $\\text X: 3 \\text s^2 3 \\text p^1$ $\\text Y: 3 \\text s^2 3 \\text p^4$ D. $\\text X: 3 \\text s^2$ $\\text Y: 2 \\text s^2 2 \\text p^3$ 练习 4下列原子或离子核外电子排布不属于基态分布的是 A. $\\text N: 1 \\text s^2 2 \\text s^2 2 \\text p^3$ B. $\\text S^{2-}: 1 \\text s^2 2 \\text s^2 2 \\text p^6 3 \\text s^2 3 \\text p^6$ C. $\\text{Na}: 1 \\text s^2 2 \\text s^2 2 \\text p^5 3 \\text s^2$ D. $\\text{Si}: 1 \\text s^2 2 \\text s^2 2 \\text p^6 3 \\text s^2 3 \\text p^2$ 练习 5某元素基态原子 $3 \\text d$ 轨道上有 $5$ 个电子，则该原子最外层电子的排布可能是 A. $4 \\text s^1$ B. $4 \\text s^2 4 \\text p^1$ C. $4 \\text s^2 4 \\text p^3$ D. $3 \\text s^2 3 \\text p^6 3 \\text d^5$ 练习 6以下对核外电子运动状况的描述正确的是 A. 同一原子中，$2 \\text p$、$3 \\text p$、$4 \\text p$ 能级的轨道依次增多 B. 当碳原子的核外电子排布由 $|\\uparrow \\downarrow|\\uparrow|\\uparrow|\\uparrow|\\uparrow|$ 转化为 $|\\uparrow \\downarrow|\\uparrow \\downarrow|\\uparrow|\\uparrow||$ 时，这一过程释放能量 C. $3 \\text p^2$ 表示 $3 \\text p$ 能级有两个轨道 D. 在同一能级上运动的电子，其运动状态可能相同 章节任务 高考：熟练 $1 \\sim 18$ 号元素的核外电子排布式和排布图，会写前 $36$ 号元素的排布式和排布图 进阶：熟练四个量子数的制约关系，能记住 $\\text{spd}$ 的电子云形状 竞赛：若一个世界主量子数 $n=1,2,3,4,\\dots$，角量子数 $l=0,1,2,3,\\dots,n$，磁量子数 $m=\\pm l$，自旋量子数 $m_s$ 只有 $+\\frac{1}{2}$，且不考虑能级交错，则第三个稀有气体是几号元素？","link":"/chemistry/1%E5%8E%9F%E5%AD%90%E7%9A%84%E6%9E%84%E9%80%A0%E5%8E%9F%E7%90%86/task/"},{"title":"原子的构造原理 题解","text":"练习 1A. 和电子层相关联的是能层而不是能级，A 错误。 B. 每个能层有轨道 $0 \\sim n-1$，因此可容纳的总电子数为 $2 \\sum_{i=0}^{n-1} (2i+1)=2(n^2-n+n)=2n^2$，B 正确。 C. 在不考虑能级交错的情况下，不同能层按能层从小到大的顺序能量从低到高，相同能层按能级从小到大的顺序能量从低到高。而能级交错只是对部分能级的交换，但本身能量没有改变，因此同一能层的不同能级能量不可能相同。C 错误。 D. 与 C 类似，能层不同时层数越大，能量越大。D 错误。 练习 2$\\text O$ 的电子排布为 $1 \\text s^2 2 \\text s^2 2 \\text p^4$。形成阴离子时可直接追加电子，因此 $\\text O^{2-}$ 的电子排布为 $1 \\text s^2 2 \\text s^2 2 \\text p^6$，故 B 错误。 练习 3最外层电子排布可以反映最外层电子数，从而体现元素的化合价。而 $\\text X_2 \\text Y_3$ 这一形式也表明 $\\text X$ 化合价为正，$\\text Y$ 为负。 A. $\\text X$ 和 $\\text Y$ 的最外层电子数分别为 $2+1=3$ 和 $2+5=7$。因此 $\\text X,\\text Y$ 化合价分别为 $+3,-1$，不合题意。 B. $\\text X$ 和 $\\text Y$ 的最外层电子数分别为 $2+3=5$ 和 $2+4=6$。因此 $\\text X,\\text Y$ 化合价分别为 $+5,-2$，不合题意。 C. $\\text X$ 和 $\\text Y$ 的最外层电子数分别为 $2+1=3$ 和 $2+4=6$。因此 $\\text X,\\text Y$ 化合价分别为 $+3,-2$，符合题意。 D. $\\text X$ 和 $\\text Y$ 的最外层电子数分别为 $2$ 和 $2+3=5$。因此 $\\text X,\\text Y$ 化合价分别为 $+2,-3$，不合题意。 练习 4C 中 $2 \\text p$ 没有排满，而该元素又不是 $\\text{Cr}$ 和 $\\text{Cu}$ 的特例，因此 C 不符合题意。 练习 5$3 \\text d$ 轨道上排满后应该有 $6$ 个电子，而现在只有 $5$ 个电子。因此只可能有两种情况： 某一元素排到 $3 \\text d$ 前只差 $5$ 个电子就可以排完。因此该元素电子数为 $2+2+6+2+6+2+5=25$，即为 $_{25}\\text{Mn}$。 该元素符合洪特规则补充条例，即为 $_{24}\\text{Cr}$。 $\\text{Mn}$ 和 $\\text{Cr}$ 的排布式分别为 $3 \\text d^5 4 \\text s^2$ 和 $3 \\text s^2 3 \\text p^6 3 \\text d^5$，因此 D 符合题意。 练习 6A. 同一名称的能级所含轨道数相同，差别只在于能量大小，A 错误。 B. 这一过程部分电子从外侧转移到内侧，因此释放能量，B 正确。 C. $3 \\text p^2$ 表示 $3 \\text p$ 能级上有两个电子，C 错误。 D. 不可能存在两个主量子数、角量子数、磁量子数和自旋量子数都对应相等的电子。因此不可能存在运动状态相同的电子，D 错误。 任务当不考虑能级交错时，这一世界的排布规律如下： 注意到磁量子数为 $\\pm l$，因此只有当角量子数为 $0$ 时每个轨道可容纳 $1$ 个电子，其它情况均可容纳 $2$ 个电子。 题目询问的是第三个稀有气体，因此该元素应该正好排满了前三能层的所有轨道。 因此电子数为 $1+2+1+2+2+1+2+2+2=15$，即对应第 $15$ 号元素。","link":"/chemistry/1%E5%8E%9F%E5%AD%90%E7%9A%84%E6%9E%84%E9%80%A0%E5%8E%9F%E7%90%86/solution/"},{"title":"原子参数","text":"原子的参数包括： 原子半径 电离能：气态原子或离子失去电子所需吸收的能量。 电子亲和能：气态原子或离子得到电子所需放出的能量。 电负性：在一个分子中，一个原子将电子吸引到它自身的能力（得失电子能力 / 氧化或还原能力）。其中电离能和电子亲和能综合起来可以决定电负性。 1 原子半径电子云没有边界，因此目前所有的原子半径都是在结合状态下测定的。半径可以分成下列三种情况： $r \\lt \\frac{d}{2}$ 范德华半径——稀有气体。两个相邻原子之间不直接接触。 $r=\\frac{d}{2}$ 金属半径——金属。原子排列可以视为等径小球的密堆。 $r \\gt \\frac{d}{2}$ 共价半径——其它分子（如水（ ）二氧化碳）。两个相邻原子有一定的重合。 规律 $1$：同一族的元素随着周期的增大，原子半径自上而下增大。 原因：电子层数增多，原子半径增大。 规律 $2$：周期内随着原子序数的增大，原子半径自左向右减小。 原因：电子层数不变的情况下，有效核电荷数的增大导致核对外层电子的引力增大。 练习 比较半径的大小 $r(\\text C)$（ ）$r(\\text N)$（ ）$r(\\text O)$ $r(\\text O)$（ ）$r(\\text S)$（ ）$r(\\text{Se})$ $r(\\text O^{2-})$（ ）$r(\\text F^-)$（ ）$r(\\text{Na}^+)$ $r(\\text{Fe})$（ ）$r(\\text{Fe}^{2+})$ $r(\\text{Fe}^{2+})$（ ）$r(\\text{Fe}^{3+})$ 解： 这三个原子属于同一周期，因此核电荷数越大，半径越小。应填 $\\gt$、$\\gt$。 这三个原子属于同一族，因此核电荷数越大，半径越大。应填 $\\lt$、$\\lt$。 这三个离子的核外电子相同，因此应当比较核电荷数——核电荷数越大，半径越小。应填 $\\gt$、$\\gt$。 这两个离子核电荷数相同，而前者的电子数较多，因此应填 $\\gt$。 同上，应填 $\\gt$。 思考主族元素、过渡元素、镧系锕系元素的原子半径减小幅度如何？ 答： 主族元素：电子增加在最外层，对原来电子的屏蔽参数 $\\sigma$ 小，有效核电荷增大多，原子半径减小幅度大； 过渡元素：电子增加在次外层，对原来电子的屏蔽参数 $\\sigma$ 较大，有效核电荷增大相对少，原子半径减小幅度小很多； 镧系锕系：电子增加在倒数第三层，对原来电子的屏蔽参数 $\\sigma$ 大，有效核电荷增大少，原子半径减小幅度非常小。 2 电离能元素的第一电离能图像： 不难发现，同周期呈上升趋势，同主族呈现下降趋势。$\\text{II A}$、$\\text{III A}$、$\\text{V A}$、$\\text{VI A}$ 附近出现异动，因为此时达到半满或全满的状态，不容易失去（一个）电子。 同理可以通过级别来反映元素丢失对应数量电子所需的电离能。例如，对于氮原子来说： 电离能级数 电离能/eV $\\Delta$/eV $\\Delta_\\Delta$/eV l1 $14.53$ / / l2 $29.60$ $15.07$ / l3 $47.45$ $17.85$ $2.78$ l4 $77.48$ $30.43$ $12.58$ l5 $97.30$ $19.82$ $-10.61$ l6 $552.15$ $454.85$ $435.03$ 注意到，电离能在 l3 和 l4 处变化趋势相比之前较大，而在 l5 和 l6 处变化速度急剧变大。这是由于氮元素 $1 \\text s^2 2 \\text s^2 2 \\text p^3$ 的结构所导致的——连续失去 $3$ 个电子的过程中电离能分布较均匀，但在失去第 $4$ 个电子时会破坏 $2 \\text p$ 层全空的稳定结构，因此变化趋势较大。而在到达 $1 \\text s$ 和 $2 \\text s$ 层的交界处时，由于能层的变化，电离能相比之前变化速度的变化量更加明显。 3 电子亲和能在某种程度上，电子亲和能所表示得到电子的过程可以视为电离能失去电子的逆向过程。 4 电负性 $\\text H \\ 2.1$ $\\text{Li} \\ 1.0$ $\\text{Be} \\ 1.5$ $\\text B \\ 2.0$ $\\text C \\ 2.5$ $\\text N \\ 3.0$ $\\text O \\ 3.5$ $\\text F \\ 4.0$ $\\text{Na} \\ 0.9$ $\\text{Mg} \\ 1.2$ $\\text{Al} \\ 1.5$ $\\text{Si} \\ 1.8$ $\\text P \\ 2.1$ $\\text S \\ 2.5$ $\\text{Cl} \\ 3.0$ $\\text K \\ 0.8$ $\\text{Ca} \\ 1.0$ $\\text{Ga} \\ 1.6$ $\\text{Ge} \\ 1.8$ $\\text{As} \\ 2.0$ $\\text{Se} \\ 2.4$ $\\text{Br} \\ 2.8$ $\\text{Rb} \\ 0.8$ $\\text{Sr} \\ 1.0$ $\\text{In} \\ 1.7$ $\\text{Sn} \\ 1.8$ $\\text{Sb} \\ 1.9$ $\\text{Te} \\ 2.1$ $\\text I \\ 2.5$ $\\text{Cs} \\ 0.7$ $\\text{Ba} \\ 0.9$ $\\text{Tl} \\ 1.8$ $\\text{Pb} \\ 1.9$ $\\text{Bi} \\ 1.9$ $\\text{Po} \\ /$ $\\text{At} \\ /$ 上表给出了部分元素的电负性。电负性的用途较多： 判断元素为金属元素还是非金属元素： 非金属元素：电负性 $\\ge 1.8$；电负性越大，非金属性越强 金属元素：电负性 $\\le 1.8$；电负性越小，金属性越强 判断化合价的正负：在只有两个元素且每个元素化合价一致的化合物中，电负性较大的显负价，较小的显正价。 判断化学键的类型： 成键的两种元素的电负性之差 $\\gt 1.7$：成离子键 成键的两种元素的电负性之差 $\\lt 1.7$：成共价键 对角线规则：左上右下对角线相邻的元素的电负性相近，性质相似。","link":"/chemistry/2%E5%85%83%E7%B4%A0%E5%91%A8%E6%9C%9F%E5%BE%8B/parameter/"},{"title":"能级交错","text":"在电子需要进入原子轨道时，按照一定的规律进行填入： 可以想象有一个与坐标轴正半轴夹角为 $135^\\circ$ 的直线，每次先从右下到左上读出所有元素，然后右移动 $1$ 格，重复操作即可得到所有排布的顺序： 练习 $\\text{Fe}$ 原子的电子排布 解：$\\text{Fe}$ 为 $26$ 号元素，因此有 $26$ 个核外电子。不妨先把前面的轨道列出： $$1 \\text s,2 \\text s,2 \\text p,3 \\text s,3 \\text p,4 \\text s,3 \\text d,4 \\text p,5 \\text s$$ 前六个轨道可容纳 $2(1+1+3+1+3+1)=20$ 个电子，而最后 $6$ 个电子可以直接排列在下一个轨道 $3 \\text d$ 中（$6 \\ge 10$）。 因而电子排布为 $$1 \\text s^2 2 \\text s^2 2 \\text p^6 3 \\text s^2 3 \\text p^6 4 \\text s^2 3 \\text d^6$$ $\\text{Br}$ 原子的电子排布 解：$\\text{Br}$ 为 $35$ 号元素，因此有 $35$ 个核外电子。因而电子排布为 $$1 \\text s^2 2 \\text s^2 2 \\text p^6 3 \\text s^2 3 \\text p^6 4 \\text s^2 3 \\text d^{10} 4 \\text p^5$$ 注意到我们可以列出稀有气体的电子排布式（按照轨道顺序排列）： $\\text{He}$ $1 \\text s^2$ $\\text{Ne}$ $1 \\text s^2 2 \\text s^2 2 \\text p^6$ $\\text{Ar}$ $1 \\text s^2 2 \\text s^2 2 \\text p^6 3 \\text s^2 3 \\text p^6$ $\\text{Kr}$ $1 \\text s^2 2 \\text s^2 2 \\text p^6 3 \\text s^2 3 \\text p^6 3 \\text d^{10} 4 \\text s^2 4 \\text p^6$ $\\text{Xe}$ $1 \\text s^2 2 \\text s^2 2 \\text p^6 3 \\text s^2 3 \\text p^6 3 \\text d^{10} 4 \\text s^2 4 \\text p^6 4 \\text d^{10} 5 \\text s^2 5 \\text p^6$ 这些稀有气体除了 $\\text{He}$ 以外，都以 $n \\text p^6$ 结尾，因此可以用来简化电子的排布： $\\text{Fe}$ $1 \\text s^2 2 \\text s^2 2 \\text p^6 3 \\text s^2 3 \\text p^6 4 \\text s^2 3 \\text d^6 \\to [\\text{Ar}]3 \\text d^6 4 \\text s^2$ 对于阳离子，应当先写出对应离子的排布，再按从外到内的顺序进行丢失： $\\text{Fe}$ $[\\text{Ar}]3 \\text d^6 4 \\text s^2 \\to \\text{Fe}^{3+}$ $[\\text{Ar}]3 \\text d^5$ 洪特规则补充条例在能量相同的轨道中电子全部充满、半充满和全空时相对较稳定。 因此需要补充下面两个特例： $_{24}\\text{Cr}$ 按之前为 $[\\text{Ar}]3 \\text d^4 4 \\text s^2$，但实为 $[\\text{Ar}]3 \\text d^5 4 \\text s^1$。 $_{29}\\text{Cu}$ 按之前为 $[\\text{Ar}]3 \\text d^9 4 \\text s^2$，但实为 $[\\text{Ar}]3 \\text d^{10} 4 \\text s^1$。","link":"/chemistry/1%E5%8E%9F%E5%AD%90%E7%9A%84%E6%9E%84%E9%80%A0%E5%8E%9F%E7%90%86/overlap/"},{"title":"元素周期表","text":"我们不妨先根据构造原理写出每一能层的电子数： $1 \\text s$ $2 \\text s$|$2 \\text p$ $3 \\text s$|$3 \\text p$ $4 \\text s$|$3 \\text d$|$4 \\text p$ $5 \\text s$|$4 \\text d$|$5 \\text p$ $\\cdots$ $2$ $2$|$6$ $2$|$6$ $2$|$10$|$6$ $\\cdots$ $\\cdots$ $2$ $4$|$10$ $12$|$18$ $20$|$30$|$36$ $54$ $\\cdots$ $\\text{He}$ $\\text{Ne}$ $\\text{Ar}$ $\\text{Kr}$ $\\text{Xe}$ $\\text{Rn}$ 根据这些可得到元素周期表的雏形： 因此我们可以归纳出下列的规律： 第 $n$ 周期从 $n \\text s^1$ 开始，到 $n \\text p^6$ 结束（除第一周期外）。 同周期元素红出现的电子排布轨道能量接近，可以称为一个能级组。 思考 列出第 $n$ 周期的能级组 解：第一周期的能级组有 $1 \\text s$，第二周期有 $2 \\text s$ 和 $2 \\text p$。依此类推，可以得到一般规律（该能级组包含对应能级的前提是该能级存在）： $$n \\text s,\\cdots,(n-2) \\text f,(n-1) \\text d,n \\text p$$ 第十周期有多少个原子？ 解法一：第 $n$ 周期有 $2 \\lceil \\frac{n+1}{2} \\rceil^2$ 个原子。将 $n=10$ 代入得共有 $2 \\times 6^2=72$ 个原子。 解法二：根据第 $1$ 题的启发，可以先列出第十周期的能级组。 先列好两端的 $\\text s$ 和 $\\text p$： $$10 \\text s,10 \\text p$$ 再依次添加剩余的轨道： $$10 \\text s,{\\color{green}{9 \\text d}},10 \\text p$$ $$10 \\text s,{\\color{green}{8 \\text f}},9 \\text d,10 \\text p$$ $$10 \\text s,{\\color{green}{7 \\text g}},8 \\text f,9 \\text d,10 \\text p$$ $$10 \\text s,{\\color{green}{6 \\text h}},7 \\text g,8 \\text f,9 \\text d,10 \\text p$$ $$10 \\text s,{\\color{red}{5 \\text i}},6 \\text h,7 \\text g,8 \\text f,9 \\text d,10 \\text p$$ 注意到 $5 \\text i$ 并不存在，因此能级组为： $$10 \\text s,6 \\text h,7 \\text g,8 \\text f,9 \\text d,10 \\text p$$ 进行累加，可得最多可容纳的电子数为 $$2+6+10+14+18+22=\\frac{(2+22) \\times 6}{2}=72$$ 因此第十周期有 $72$ 个原子。","link":"/chemistry/2%E5%85%83%E7%B4%A0%E5%91%A8%E6%9C%9F%E5%BE%8B/periodic/"},{"title":"2022 新高考 I 卷精选好题","text":"合集【泰勒展开】第 7 题【立体几何+导数】第 8 题【三角函数】第 18 题【立体几何】第 19 题","link":"/math/NEMT/2022/newI/"}],"tags":[{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"洛谷","slug":"洛谷","link":"/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"NOI Online","slug":"NOI-Online","link":"/tags/NOI-Online/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"差分","slug":"差分","link":"/tags/%E5%B7%AE%E5%88%86/"},{"name":"OI","slug":"OI","link":"/tags/OI/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二分答案","slug":"二分答案","link":"/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"},{"name":"NOIP","slug":"NOIP","link":"/tags/NOIP/"},{"name":"筛法","slug":"筛法","link":"/tags/%E7%AD%9B%E6%B3%95/"},{"name":"欧拉计划","slug":"欧拉计划","link":"/tags/%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%92/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"CSP","slug":"CSP","link":"/tags/CSP/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"分块","slug":"分块","link":"/tags/%E5%88%86%E5%9D%97/"},{"name":"原子的构造原理","slug":"原子的构造原理","link":"/tags/%E5%8E%9F%E5%AD%90%E7%9A%84%E6%9E%84%E9%80%A0%E5%8E%9F%E7%90%86/"},{"name":"元素周期律","slug":"元素周期律","link":"/tags/%E5%85%83%E7%B4%A0%E5%91%A8%E6%9C%9F%E5%BE%8B/"}],"categories":[],"pages":[{"title":"tags","text":"","link":"/tags/index.html"}]}